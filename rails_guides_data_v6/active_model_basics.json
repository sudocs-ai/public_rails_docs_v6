[{"code":[],"body":"Active Model is a library containing various modules used in developing\nclasses that need some features present on Active Record.\nSome of these modules are explained below.","title":"1 What is Active Model?","anchor":"#what-is-active-model-questionmark"},{"title":"1.1 Attribute Methods","anchor":"#attribute-methods","code":["\nclass Person\n  include ActiveModel::AttributeMethods\n\n  attribute_method_prefix 'reset_'\n  attribute_method_suffix '_highest?'\n  define_attribute_methods 'age'\n\n  attr_accessor :age\n\n  private\n    def reset_attribute(attribute)\n      send(\"#{attribute}=\", 0)\n    end\n\n    def attribute_highest?(attribute)\n      send(attribute) > 100\n    end\nend\n\nclass Person\n  include ActiveModel::AttributeMethods\n\n  attribute_method_prefix 'reset_'\n  attribute_method_suffix '_highest?'\n  define_attribute_methods 'age'\n\n  attr_accessor :age\n\n  private\n    def reset_attribute(attribute)\n      send(\"#{attribute}=\", 0)\n    end\n\n    def attribute_highest?(attribute)\n      send(attribute) > 100\n    end\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.age = 110\nirb> person.age_highest?\n=> true\nirb> person.reset_age\n=> 0\nirb> person.age_highest?\n=> false\n\nperson = Person.new\nperson.age = 110\nperson.age_highest?\nperson.reset_age\nperson.age_highest?\n\nCopy\n"],"body":"The ActiveModel::AttributeMethods module can add custom prefixes and suffixes\non methods of a class. It is used by defining the prefixes and suffixes and\nwhich methods on the object will use them."},{"code":["\nclass Person\n  extend ActiveModel::Callbacks\n\n  define_model_callbacks :update\n\n  before_update :reset_me\n\n  def update\n    run_callbacks(:update) do\n      # This method is called when update is called on an object.\n    end\n  end\n\n  def reset_me\n    # This method is called when update is called on an object as a before_update callback is defined.\n  end\nend\n\nclass Person\n  extend ActiveModel::Callbacks\n\n  define_model_callbacks :update\n\n  before_update :reset_me\n\n  def update\n    run_callbacks(:update) do\n      # This method is called when update is called on an object.\n    end\n  end\n\n  def reset_me\n    # This method is called when update is called on an object as a before_update callback is defined.\n  end\nend\n\nCopy\n"],"body":"ActiveModel::Callbacks gives Active Record style callbacks. This provides an\nability to define callbacks which run at appropriate times.\nAfter defining callbacks, you can wrap them with before, after, and around\ncustom methods.","title":"1.2 Callbacks","anchor":"#callbacks"},{"code":["\nclass Person\n  include ActiveModel::Conversion\n\n  def persisted?\n    false\n  end\n\n  def id\n    nil\n  end\nend\n\nclass Person\n  include ActiveModel::Conversion\n\n  def persisted?\n    false\n  end\n\n  def id\n    nil\n  end\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.to_model == person\n=> true\nirb> person.to_key\n=> nil\nirb> person.to_param\n=> nil\n\nperson = Person.new\nperson.to_model == person\nperson.to_key\nperson.to_param\n\nCopy\n"],"body":"If a class defines persisted? and id methods, then you can include the\nActiveModel::Conversion module in that class, and call the Rails conversion\nmethods on objects of that class.","title":"1.3 Conversion","anchor":"#conversion"},{"code":["\nclass Person\n  include ActiveModel::Dirty\n  define_attribute_methods :first_name, :last_name\n\n  def first_name\n    @first_name\n  end\n\n  def first_name=(value)\n    first_name_will_change!\n    @first_name = value\n  end\n\n  def last_name\n    @last_name\n  end\n\n  def last_name=(value)\n    last_name_will_change!\n    @last_name = value\n  end\n\n  def save\n    # do save work...\n    changes_applied\n  end\nend\n\nclass Person\n  include ActiveModel::Dirty\n  define_attribute_methods :first_name, :last_name\n\n  def first_name\n    @first_name\n  end\n\n  def first_name=(value)\n    first_name_will_change!\n    @first_name = value\n  end\n\n  def last_name\n    @last_name\n  end\n\n  def last_name=(value)\n    last_name_will_change!\n    @last_name = value\n  end\n\n  def save\n    # do save work...\n    changes_applied\n  end\nend\n\nCopy\n"],"body":"An object becomes dirty when it has gone through one or more changes to its\nattributes and has not been saved. ActiveModel::Dirty gives the ability to\ncheck whether an object has been changed or not. It also has attribute based\naccessor methods. Let's consider a Person class with attributes first_name\nand last_name:","title":"1.4 Dirty","anchor":"#dirty"},{"code":["\nirb> person = Person.new\nirb> person.changed?\n=> false\n\nirb> person.first_name = \"First Name\"\nirb> person.first_name\n=> \"First Name\"\n\n# Returns true if any of the attributes have unsaved changes.\nirb> person.changed?\n=> true\n\n# Returns a list of attributes that have changed before saving.\nirb> person.changed\n=> [\"first_name\"]\n\n# Returns a Hash of the attributes that have changed with their original values.\nirb> person.changed_attributes\n=> {\"first_name\"=>nil}\n\n# Returns a Hash of changes, with the attribute names as the keys, and the values as an array of the old and new values for that field.\nirb> person.changes\n=> {\"first_name\"=>[nil, \"First Name\"]}\n\nperson = Person.new\nperson.changed?\nperson.first_name = \"First Name\"\nperson.first_name\nperson.changed?\nperson.changed\nperson.changed_attributes\nperson.changes\n\nCopy\n"],"body":"","title":"1.4.1 Querying object directly for its list of all changed attributes.","anchor":"#querying-object-directly-for-its-list-of-all-changed-attributes"},{"code":["\nirb> person.first_name\n=> \"First Name\"\n\n# attr_name_changed?\nirb> person.first_name_changed?\n=> true\n\nperson.first_name\nperson.first_name_changed?\n\nCopy\n","\n# attr_name_was accessor\nirb> person.first_name_was\n=> nil\n\nperson.first_name_was\n\nCopy\n","\n# attr_name_change\nirb> person.first_name_change\n=> [nil, \"First Name\"]\nirb> person.last_name_change\n=> nil\n\nperson.first_name_change\nperson.last_name_change\n\nCopy\n"],"body":"Track whether the particular attribute has been changed or not.Track the previous value of the attribute.Track both previous and current value of the changed attribute. Returns an array\nif changed, otherwise returns nil.","title":"1.4.2 Attribute based accessor methods","anchor":"#attribute-based-accessor-methods"},{"code":["\nclass Person\n  include ActiveModel::Validations\n\n  attr_accessor :name, :email, :token\n\n  validates :name, presence: true\n  validates_format_of :email, with: /\\A([^\\s]+)((?:[-a-z0-9]\\.)[a-z]{2,})\\z/i\n  validates! :token, presence: true\nend\n\nclass Person\n  include ActiveModel::Validations\n\n  attr_accessor :name, :email, :token\n\n  validates :name, presence: true\n  validates_format_of :email, with: /\\A([^\\s]+)((?:[-a-z0-9]\\.)[a-z]{2,})\\z/i\n  validates! :token, presence: true\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.token = \"2b1f325\"\nirb> person.valid?\n=> false\nirb> person.name = 'vishnu'\nirb> person.email = 'me'\nirb> person.valid?\n=> false\nirb> person.email = 'me@vishnuatrai.com'\nirb> person.valid?\n=> true\nirb> person.token = nil\nirb> person.valid?\nActiveModel::StrictValidationFailed\n\nperson = Person.new\nperson.token = \"2b1f325\"\nperson.valid?\nperson.name = 'vishnu'\nperson.email = 'me'\nperson.valid?\nperson.email = 'me@vishnuatrai.com'\nperson.valid?\nperson.token = nil\nperson.valid?\n\nCopy\n"],"body":"The ActiveModel::Validations module adds the ability to validate objects\nlike in Active Record.","title":"1.5 Validations","anchor":"#validations"},{"code":["\nclass Person\n  extend ActiveModel::Naming\nend\n\nPerson.model_name.name                # => \"Person\"\nPerson.model_name.singular            # => \"person\"\nPerson.model_name.plural              # => \"people\"\nPerson.model_name.element             # => \"person\"\nPerson.model_name.human               # => \"Person\"\nPerson.model_name.collection          # => \"people\"\nPerson.model_name.param_key           # => \"person\"\nPerson.model_name.i18n_key            # => :person\nPerson.model_name.route_key           # => \"people\"\nPerson.model_name.singular_route_key  # => \"person\"\n\nclass Person\n  extend ActiveModel::Naming\nend\n\nPerson.model_name.name                # => \"Person\"\nPerson.model_name.singular            # => \"person\"\nPerson.model_name.plural              # => \"people\"\nPerson.model_name.element             # => \"person\"\nPerson.model_name.human               # => \"Person\"\nPerson.model_name.collection          # => \"people\"\nPerson.model_name.param_key           # => \"person\"\nPerson.model_name.i18n_key            # => :person\nPerson.model_name.route_key           # => \"people\"\nPerson.model_name.singular_route_key  # => \"person\"\n\nCopy\n"],"body":"ActiveModel::Naming adds a number of class methods which make naming and routing\neasier to manage. The module defines the model_name class method which\nwill define a number of accessors using some ActiveSupport::Inflector methods.","title":"1.6 Naming","anchor":"#naming"},{"code":["\nclass EmailContact\n  include ActiveModel::Model\n\n  attr_accessor :name, :email, :message\n  validates :name, :email, :message, presence: true\n\n  def deliver\n    if valid?\n      # deliver email\n    end\n  end\nend\n\nclass EmailContact\n  include ActiveModel::Model\n\n  attr_accessor :name, :email, :message\n  validates :name, :email, :message, presence: true\n\n  def deliver\n    if valid?\n      # deliver email\n    end\n  end\nend\n\nCopy\n","\nirb> email_contact = EmailContact.new(name: 'David', email: 'david@example.com', message: 'Hello World')\nirb> email_contact.name\n=> \"David\"\nirb> email_contact.email\n=> \"david@example.com\"\nirb> email_contact.valid?\n=> true\nirb> email_contact.persisted?\n=> false\n\nemail_contact = EmailContact.new(name: 'David', email: 'david@example.com', message: 'Hello World')\nemail_contact.name\nemail_contact.email\nemail_contact.valid?\nemail_contact.persisted?\n\nCopy\n"],"body":"ActiveModel::Model adds the ability for a class to work with Action Pack and\nAction View right out of the box.When including ActiveModel::Model you get some features like:It also gives you the ability to initialize an object with a hash of attributes,\nmuch like any Active Record object.Any class that includes ActiveModel::Model can be used with form_with,\nrender and any other Action View helper methods, just like Active Record\nobjects.","title":"1.7 Model","anchor":"#model"},{"title":"1.8 Serialization","anchor":"#serialization","code":["\nclass Person\n  include ActiveModel::Serialization\n\n  attr_accessor :name\n\n  def attributes\n    {'name' => nil}\n  end\nend\n\nclass Person\n  include ActiveModel::Serialization\n\n  attr_accessor :name\n\n  def attributes\n    {'name' => nil}\n  end\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.serializable_hash\n=> {\"name\"=>nil}\nirb> person.name = \"Bob\"\nirb> person.serializable_hash\n=> {\"name\"=>\"Bob\"}\n\nperson = Person.new\nperson.serializable_hash\nperson.name = \"Bob\"\nperson.serializable_hash\n\nCopy\n"],"body":"ActiveModel::Serialization provides basic serialization for your object.\nYou need to declare an attributes Hash which contains the attributes you want to\nserialize. Attributes must be strings, not symbols.Now you can access a serialized Hash of your object using the serializable_hash method."},{"code":["\nclass Person\n  include ActiveModel::Serializers::JSON\n\n  attr_accessor :name\n\n  def attributes\n    {'name' => nil}\n  end\nend\n\nclass Person\n  include ActiveModel::Serializers::JSON\n\n  attr_accessor :name\n\n  def attributes\n    {'name' => nil}\n  end\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.as_json\n=> {\"name\"=>nil}\nirb> person.name = \"Bob\"\nirb> person.as_json\n=> {\"name\"=>\"Bob\"}\n\nperson = Person.new\nperson.as_json\nperson.name = \"Bob\"\nperson.as_json\n\nCopy\n","\nclass Person\n  include ActiveModel::Serializers::JSON\n\n  attr_accessor :name\n\n  def attributes=(hash)\n    hash.each do |key, value|\n      send(\"#{key}=\", value)\n    end\n  end\n\n  def attributes\n    {'name' => nil}\n  end\nend\n\nclass Person\n  include ActiveModel::Serializers::JSON\n\n  attr_accessor :name\n\n  def attributes=(hash)\n    hash.each do |key, value|\n      send(\"#{key}=\", value)\n    end\n  end\n\n  def attributes\n    {'name' => nil}\n  end\nend\n\nCopy\n","\nirb> json = { name: 'Bob' }.to_json\nirb> person = Person.new\nirb> person.from_json(json)\n=> #<Person:0x00000100c773f0 @name=\"Bob\">\nirb> person.name\n=> \"Bob\"\n\njson = { name: 'Bob' }.to_json\nperson = Person.new\nperson.from_json(json)\nperson.name\n\nCopy\n"],"body":"Active Model also provides the ActiveModel::Serializers::JSON module\nfor JSON serializing / deserializing. This module automatically includes the\npreviously discussed ActiveModel::Serialization module.To use ActiveModel::Serializers::JSON you only need to change the\nmodule you are including from ActiveModel::Serialization to ActiveModel::Serializers::JSON.The as_json method, similar to serializable_hash, provides a Hash representing\nthe model.You can also define the attributes for a model from a JSON string.\nHowever, you need to define the attributes= method on your class:Now it is possible to create an instance of Person and set attributes using from_json.","title":"1.8.1 ActiveModel::Serializers","anchor":"#activemodel-serializers"},{"code":["\nclass Person\n  extend ActiveModel::Translation\nend\n\nclass Person\n  extend ActiveModel::Translation\nend\n\nCopy\n","\npt-BR:\n  activemodel:\n    attributes:\n      person:\n        name: 'Nome'\n\npt-BR:\n  activemodel:\n    attributes:\n      person:\n        name: 'Nome'\n\nCopy\n","\nPerson.human_attribute_name('name') # => \"Nome\"\n\nPerson.human_attribute_name('name') # => \"Nome\"\n\nCopy\n"],"body":"ActiveModel::Translation provides integration between your object and the Rails\ninternationalization (i18n) framework.With the human_attribute_name method, you can transform attribute names into a\nmore human-readable format. The human-readable format is defined in your locale file(s).","title":"1.9 Translation","anchor":"#translation"},{"code":["\n$ bin/rails test\n\nRun options: --seed 14596\n\n# Running:\n\n......\n\nFinished in 0.024899s, 240.9735 runs/s, 1204.8677 assertions/s.\n\n6 runs, 30 assertions, 0 failures, 0 errors, 0 skips\n\nbin/rails test\n\nCopy\n"],"body":"ActiveModel::Lint::Tests allows you to test whether an object is compliant with\nthe Active Model API.An object is not required to implement all APIs in order to work with\nAction Pack. This module only intends to provide guidance in case you want all\nfeatures out of the box.","title":"1.10 Lint Tests","anchor":"#lint-tests"},{"title":"1.11 SecurePassword","anchor":"#securepassword","code":[],"body":"ActiveModel::SecurePassword provides a way to securely store any\npassword in an encrypted form. When you include this module, a\nhas_secure_password class method is provided which defines\na password accessor with certain validations on it by default."},{"title":"1.11.1 Requirements","anchor":"#requirements","code":[],"body":"ActiveModel::SecurePassword depends on bcrypt,\nso include this gem in your Gemfile to use ActiveModel::SecurePassword correctly.\nIn order to make this work, the model must have an accessor named XXX_digest.\nWhere XXX is the attribute name of your desired password.\nThe following validations are added automatically:"},{"code":["\nclass Person\n  include ActiveModel::SecurePassword\n  has_secure_password\n  has_secure_password :recovery_password, validations: false\n\n  attr_accessor :password_digest, :recovery_password_digest\nend\n\nclass Person\n  include ActiveModel::SecurePassword\n  has_secure_password\n  has_secure_password :recovery_password, validations: false\n\n  attr_accessor :password_digest, :recovery_password_digest\nend\n\nCopy\n","\nirb> person = Person.new\n\n# When password is blank.\nirb> person.valid?\n=> false\n\n# When the confirmation doesn't match the password.\nirb> person.password = 'aditya'\nirb> person.password_confirmation = 'nomatch'\nirb> person.valid?\n=> false\n\n# When the length of password exceeds 72.\nirb> person.password = person.password_confirmation = 'a' * 100\nirb> person.valid?\n=> false\n\n# When only password is supplied with no password_confirmation.\nirb> person.password = 'aditya'\nirb> person.valid?\n=> true\n\n# When all validations are passed.\nirb> person.password = person.password_confirmation = 'aditya'\nirb> person.valid?\n=> true\n\nirb> person.recovery_password = \"42password\"\n\nirb> person.authenticate('aditya')\n=> #<Person> # == person\nirb> person.authenticate('notright')\n=> false\nirb> person.authenticate_password('aditya')\n=> #<Person> # == person\nirb> person.authenticate_password('notright')\n=> false\n\nirb> person.authenticate_recovery_password('42password')\n=> #<Person> # == person\nirb> person.authenticate_recovery_password('notright')\n=> false\n\nirb> person.password_digest\n=> \"$2a$04$gF8RfZdoXHvyTjHhiU4ZsO.kQqV9oonYZu31PRE4hLQn3xM2qkpIy\"\nirb> person.recovery_password_digest\n=> \"$2a$04$iOfhwahFymCs5weB3BNH/uXkTG65HR.qpW.bNhEjFP3ftli3o5DQC\"\n\nperson = Person.new\nperson.valid?\nperson.password = 'aditya'\nperson.password_confirmation = 'nomatch'\nperson.valid?\nperson.password = person.password_confirmation = 'a' * 100\nperson.valid?\nperson.password = 'aditya'\nperson.valid?\nperson.password = person.password_confirmation = 'aditya'\nperson.valid?\nperson.recovery_password = \"42password\"\nperson.authenticate('aditya')\nperson.authenticate('notright')\nperson.authenticate_password('aditya')\nperson.authenticate_password('notright')\nperson.authenticate_recovery_password('42password')\nperson.authenticate_recovery_password('notright')\nperson.password_digest\nperson.recovery_password_digest\n\nCopy\n"],"body":"","title":"1.11.2 Examples","anchor":"#examples"}]