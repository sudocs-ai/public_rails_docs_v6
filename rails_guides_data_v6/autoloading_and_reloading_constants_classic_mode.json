[{"code":["\nrequire \"application_controller\"\nrequire \"post\"\n\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nrequire \"application_controller\"\nrequire \"post\"\n\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nCopy\n","\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nCopy\n"],"body":"Ruby on Rails allows applications to be written as if their code was preloaded.In a normal Ruby program classes need to load their dependencies:Our Rubyist instinct quickly sees some redundancy in there: If classes were\ndefined in files matching their name, couldn't their loading be automated\nsomehow? We could save scanning the file for dependencies, which is brittle.Moreover, Kernel#require loads files once, but development is much more smooth\nif code gets refreshed when it changes without restarting the server. It would\nbe nice to be able to use Kernel#load in development, and Kernel#require in\nproduction.Indeed, those features are provided by Ruby on Rails, where we just writeThis guide documents how that works.","title":"1 Introduction","anchor":"#introduction"},{"title":"2 Constants Refresher","anchor":"#constants-refresher","code":[],"body":"While constants are trivial in most programming languages, they are a rich\ntopic in Ruby.It is beyond the scope of this guide to document Ruby constants, but we are\nnevertheless going to highlight a few key topics. Truly grasping the following\nsections is instrumental to understanding constant autoloading and reloading."},{"title":"2.1 Nesting","anchor":"#nesting","code":["\nmodule XML\n  class SAXParser\n    # (1)\n  end\nend\n\nmodule XML\n  class SAXParser\n    # (1)\n  end\nend\n\nCopy\n","\n[XML::SAXParser, XML]\n\n[XML::SAXParser, XML]\n\nCopy\n","\nclass XML::SAXParser\n  # (2)\nend\n\nclass XML::SAXParser\n  # (2)\nend\n\nCopy\n","\n[XML::SAXParser]\n\n[XML::SAXParser]\n\nCopy\n","\nmodule X\n  module Y\n  end\nend\n\nmodule A\n  module B\n  end\nend\n\nmodule X::Y\n  module A::B\n    # (3)\n  end\nend\n\nmodule X\n  module Y\n  end\nend\n\nmodule A\n  module B\n  end\nend\n\nmodule X::Y\n  module A::B\n    # (3)\n  end\nend\n\nCopy\n","\n[A::B, X::Y]\n\n[A::B, X::Y]\n\nCopy\n"],"body":"Class and module definitions can be nested to create namespaces:The nesting at any given place is the collection of enclosing nested class and\nmodule objects outwards. The nesting at any given place can be inspected with\nModule.nesting. For example, in the previous example, the nesting at\n(1) isIt is important to understand that the nesting is composed of class and module\nobjects, it has nothing to do with the constants used to access them, and is\nalso unrelated to their names.For instance, while this definition is similar to the previous one:the nesting in (2) is different:XML does not belong to it.We can see in this example that the name of a class or module that belongs to a\ncertain nesting does not necessarily correlate with the namespaces at the spot.Even more, they are totally independent, take for instanceThe nesting in (3) consists of two module objects:So, it not only doesn't end in A, which does not even belong to the nesting,\nbut it also contains X::Y, which is independent from A::B.The nesting is an internal stack maintained by the interpreter, and it gets\nmodified according to these rules:It is interesting to observe that blocks do not modify the stack. In particular\nthe blocks that may be passed to Class.new and Module.new do not get the\nclass or module being defined pushed to their nesting. That's one of the\ndifferences between defining classes and modules in one way or another."},{"title":"2.2 Class and Module Definitions are Constant Assignments","anchor":"#class-and-module-definitions-are-constant-assignments","code":["\nclass C\nend\n\nclass C\nend\n\nCopy\n","\nclass Project < ApplicationRecord\nend\n\nclass Project < ApplicationRecord\nend\n\nCopy\n","\nProject = Class.new(ApplicationRecord)\n\nProject = Class.new(ApplicationRecord)\n\nCopy\n","\nProject.name # => \"Project\"\n\nProject.name # => \"Project\"\n\nCopy\n","\nmodule Admin\nend\n\nmodule Admin\nend\n\nCopy\n","\nAdmin = Module.new\n\nAdmin = Module.new\n\nCopy\n","\nAdmin.name # => \"Admin\"\n\nAdmin.name # => \"Admin\"\n\nCopy\n","\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nCopy\n"],"body":"Let's suppose the following snippet creates a class (rather than reopening it):Ruby creates a constant C in Object and stores in that constant a class\nobject. The name of the class instance is \"C\", a string, named after the\nconstant.That is,performs a constant assignment equivalent toincluding setting the name of the class as a side-effect:Constant assignment has a special rule to make that happen: if the object\nbeing assigned is an anonymous class or module, Ruby sets the object's name to\nthe name of the constant.Similarly, module creation using the module keyword as inperforms a constant assignment equivalent toincluding setting the name as a side-effect:Thus, an informal expression like \"the String class\" technically means the\nclass object stored in the constant called \"String\". That constant, in turn,\nbelongs to the class object stored in the constant called \"Object\".String is an ordinary constant, and everything related to them such as\nresolution algorithms applies to it.Likewise, in the controllerPost is not syntax for a class. Rather, Post is a regular Ruby constant. If\nall is good, the constant is evaluated to an object that responds to all.That is why we talk about constant autoloading, Rails has the ability to\nload constants on the fly."},{"title":"2.3 Constants are Stored in Modules","anchor":"#constants-are-stored-in-modules","code":["\nmodule Colors\n  RED = '0xff0000'\nend\n\nmodule Colors\n  RED = '0xff0000'\nend\n\nCopy\n"],"body":"Constants belong to modules in a very literal sense. Classes and modules have\na constant table; think of it as a hash table.Let's analyze an example to really understand what that means. While common\nabuses of language like \"the String class\" are convenient, the exposition is\ngoing to be precise here for didactic purposes.Let's consider the following module definition:First, when the module keyword is processed, the interpreter creates a new\nentry in the constant table of the class object stored in the Object constant.\nSaid entry associates the name \"Colors\" to a newly created module object.\nFurthermore, the interpreter sets the name of the new module object to be the\nstring \"Colors\".Later, when the body of the module definition is interpreted, a new entry is\ncreated in the constant table of the module object stored in the Colors\nconstant. That entry maps the name \"RED\" to the string \"0xff0000\".In particular, Colors::RED is totally unrelated to any other RED constant\nthat may live in any other class or module object. If there were any, they\nwould have separate entries in their respective constant tables.Pay special attention in the previous paragraphs to the distinction between\nclass and module objects, constant names, and value objects associated to them\nin constant tables."},{"title":"2.4 Resolution Algorithms","anchor":"#resolution-algorithms","code":[],"body":""},{"title":"2.4.1 Resolution Algorithm for Relative Constants","anchor":"#resolution-algorithm-for-relative-constants","code":[],"body":"At any given place in the code, let's define cref to be the first element of\nthe nesting if it is not empty, or Object otherwise.Without getting too much into the details, the resolution algorithm for relative\nconstant references goes like this:Rails autoloading does not emulate this algorithm, but its starting point is\nthe name of the constant to be autoloaded, and the cref. See more in Relative\nReferences."},{"title":"2.4.2 Resolution Algorithm for Qualified Constants","anchor":"#resolution-algorithm-for-qualified-constants","code":["\nBilling::Invoice\n\nBilling::Invoice\n\nCopy\n"],"body":"Qualified constants look like this:Billing::Invoice is composed of two constants: Billing is relative and is\nresolved using the algorithm of the previous section.Invoice on the other hand is qualified by Billing and we are going to see\nits resolution next. Let's define parent to be that qualifying class or module\nobject, that is, Billing in the example above. The algorithm for qualified\nconstants goes like this:As you see, this algorithm is simpler than the one for relative constants. In\nparticular, the nesting plays no role here, and modules are not special-cased,\nif neither they nor their ancestors have the constants, Object is not\nchecked.Rails autoloading does not emulate this algorithm, but its starting point is\nthe name of the constant to be autoloaded, and the parent. See more in\nQualified References."},{"title":"3 Vocabulary","anchor":"#vocabulary","code":[],"body":""},{"title":"3.1 Parent Namespaces","anchor":"#parent-namespaces","code":[],"body":"Given a string with a constant path we define its parent namespace to be the\nstring that results from removing its rightmost segment.For example, the parent namespace of the string \"A::B::C\" is the string \"A::B\",\nthe parent namespace of \"A::B\" is \"A\", and the parent namespace of \"A\" is \"\".The interpretation of a parent namespace when thinking about classes and modules\nis tricky though. Let's consider a module M named \"A::B\":The idea of a parent namespace is at the core of the autoloading algorithms\nand helps explain and understand their motivation intuitively, but as you see\nthat metaphor leaks easily. Given an edge case to reason about, take always into\naccount that by \"parent namespace\" the guide means exactly that specific string\nderivation."},{"title":"3.2 Loading Mechanism","anchor":"#loading-mechanism","code":[],"body":"Rails autoloads files with Kernel#load when config.cache_classes is false,\nthe default in development mode, and with Kernel#require otherwise, the\ndefault in production mode.Kernel#load allows Rails to execute files more than once if constant\nreloading is enabled.This guide uses the word \"load\" freely to mean a given file is interpreted, but\nthe actual mechanism can be Kernel#load or Kernel#require depending on that\nflag."},{"title":"4 Autoloading Availability","anchor":"#autoloading-availability","code":["\n$ bin/rails runner 'p User.column_names'\n[\"id\", \"email\", \"created_at\", \"updated_at\"]\n\nbin/rails runner 'p User.column_names'\n\nCopy\n","\nclass BeachHouse < House\nend\n\nclass BeachHouse < House\nend\n\nCopy\n"],"body":"Rails is always able to autoload provided its environment is in place. For\nexample the runner command autoloads:The console autoloads, the test suite autoloads, and of course the application\nautoloads.By default, Rails eager loads the application files when it boots in production\nmode, so most of the autoloading going on in development does not happen. But\nautoloading may still be triggered during eager loading.For example, givenif House is still unknown when app/models/beach_house.rb is being eager\nloaded, Rails autoloads it."},{"title":"5 autoload_paths and eager_load_paths","anchor":"#autoload-paths-and-eager-load-paths","code":["\nrequire \"erb\"\n\nrequire \"erb\"\n\nCopy\n","\n$ bin/rails runner 'puts ActiveSupport::Dependencies.autoload_paths'\n.../app/assets\n.../app/channels\n.../app/controllers\n.../app/controllers/concerns\n.../app/helpers\n.../app/jobs\n.../app/mailers\n.../app/models\n.../app/models/concerns\n.../activestorage/app/assets\n.../activestorage/app/controllers\n.../activestorage/app/javascript\n.../activestorage/app/jobs\n.../activestorage/app/models\n.../actioncable/app/assets\n.../actionview/app/assets\n.../test/mailers/previews\n\nbin/rails runner 'puts ActiveSupport::Dependencies.autoload_paths'\n\nCopy\n"],"body":"As you probably know, when require gets a relative file name:Ruby looks for the file in the directories listed in $LOAD_PATH. That is, Ruby\niterates over all its directories and for each one of them checks whether they\nhave a file called \"erb.rb\", or \"erb.so\", or \"erb.o\", or \"erb.dll\". If it finds\nany of them, the interpreter loads it and ends the search. Otherwise, it tries\nagain in the next directory of the list. If the list gets exhausted, LoadError\nis raised.We are going to cover how constant autoloading works in more detail later, but\nthe idea is that when a constant like Post is hit and missing, if there's a\npost.rb file for example in app/models Rails is going to find it, evaluate\nit, and have Post defined as a side-effect.All right, Rails has a collection of directories similar to $LOAD_PATH in which\nto look up post.rb. That collection is called autoload_paths and by\ndefault it contains:eager_load_paths is initially the app paths aboveHow files are autoloaded depends on eager_load and cache_classes config settings which typically vary in development, production, and test modes:What is described above are the defaults with a newly generated Rails app.\nThere are multiple ways this can be configured differently (see Configuring\nRails Applications). In the past, before\nRails 5, developers might configure autoload_paths to add in extra locations\n(e.g. lib which used to be an autoload path list years ago, but no longer\nis). However this is now discouraged for most purposes, as it is likely to\nlead to production-only errors. It is possible to add new locations to both\nconfig.eager_load_paths and config.autoload_paths but use at your own risk.See also Autoloading in the Test Environment.The value of autoload_paths can be inspected. In a just-generated application\nit is (edited):"},{"title":"6 Autoloading Algorithms","anchor":"#autoloading-algorithms","code":[],"body":""},{"title":"6.1 Relative References","anchor":"#autoloading-algorithms-relative-references","code":["\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nclass PostsController < ApplicationController\n  def index\n    @posts = Post.all\n  end\nend\n\nCopy\n"],"body":"A relative constant reference may appear in several places, for example, inall three constant references are relative."},{"title":"6.1.1 Constants after the class and module Keywords","anchor":"#constants-after-the-class-and-module-keywords","code":[],"body":"Ruby performs a lookup for the constant that follows a class or module\nkeyword because it needs to know if the class or module is going to be created\nor reopened.If the constant is not defined at that point it is not considered to be a\nmissing constant, autoloading is not triggered.So, in the previous example, if PostsController is not defined when the file\nis interpreted Rails autoloading is not going to be triggered, Ruby will just\ndefine the controller."},{"title":"6.1.2 Top-Level Constants","anchor":"#top-level-constants","code":["\nunable to autoload constant ApplicationController, expected\n<full path to application_controller.rb> to define it (LoadError)\n\nunable to autoload constant ApplicationController, expected\n<full path to application_controller.rb> to define it (LoadError)\n\nCopy\n"],"body":"On the contrary, if ApplicationController is unknown, the constant is\nconsidered missing and an autoload is going to be attempted by Rails.In order to load ApplicationController, Rails iterates over autoload_paths.\nFirst it checks if app/assets/application_controller.rb exists. If it does not,\nwhich is normally the case, it continues and finds\napp/controllers/application_controller.rb.If the file defines the constant ApplicationController all is fine, otherwise\nLoadError is raised:"},{"title":"6.1.3 Namespaces","anchor":"#namespaces","code":["\nmodule Admin\n  class BaseController < ApplicationController\n    @@all_roles = Role.all\n  end\nend\n\nmodule Admin\n  class BaseController < ApplicationController\n    @@all_roles = Role.all\n  end\nend\n\nCopy\n","\nAdmin::BaseController::Role\nAdmin::Role\nRole\n\nAdmin::BaseController::Role\nAdmin::Role\nRole\n\nCopy\n","\nadmin/base_controller/role.rb\nadmin/role.rb\nrole.rb\n\nadmin/base_controller/role.rb\nadmin/role.rb\nrole.rb\n\nCopy\n","\napp/assets/posts_controller/post.rb\napp/controllers/posts_controller/post.rb\napp/helpers/posts_controller/post.rb\n...\ntest/mailers/previews/posts_controller/post.rb\n\napp/assets/posts_controller/post.rb\napp/controllers/posts_controller/post.rb\napp/helpers/posts_controller/post.rb\n...\ntest/mailers/previews/posts_controller/post.rb\n\nCopy\n","\napp/assets/posts_controller/post\napp/controllers/posts_controller/post\napp/helpers/posts_controller/post\n...\ntest/mailers/previews/posts_controller/post\n\napp/assets/posts_controller/post\napp/controllers/posts_controller/post\napp/helpers/posts_controller/post\n...\ntest/mailers/previews/posts_controller/post\n\nCopy\n","\napp/assets/post.rb\napp/controllers/post.rb\napp/helpers/post.rb\napp/mailers/post.rb\napp/models/post.rb\n\napp/assets/post.rb\napp/controllers/post.rb\napp/helpers/post.rb\napp/mailers/post.rb\napp/models/post.rb\n\nCopy\n"],"body":"Autoloading ApplicationController looks directly under the directories of\nautoload_paths because the nesting in that spot is empty. The situation of\nPost is different, the nesting in that line is [PostsController] and support\nfor namespaces comes into play.The basic idea is that givento autoload Role we are going to check if it is defined in the current or\nparent namespaces, one at a time. So, conceptually we want to try to autoload\nany ofin that order. That's the idea. To do so, Rails looks in autoload_paths\nrespectively for file names like these:modulus some additional directory lookups we are going to cover soon.Let's see how Rails autoloads the Post constant in the PostsController\nabove assuming the application has a Post model defined in\napp/models/post.rb.First it checks for posts_controller/post.rb in autoload_paths:Since the lookup is exhausted without success, a similar search for a directory\nis performed, we are going to see why in the next section:If all those attempts fail, then Rails starts the lookup again in the parent\nnamespace. In this case only the top-level remains:A matching file is found in app/models/post.rb. The lookup stops there and the\nfile is loaded. If the file actually defines Post all is fine, otherwise\nLoadError is raised."},{"title":"6.2 Qualified References","anchor":"#autoloading-algorithms-qualified-references","code":["\nmodule Admin\n  User\nend\n\nmodule Admin\n  User\nend\n\nCopy\n","\nAdmin::User\n\nAdmin::User\n\nCopy\n","\nAdmin::User\n\nAdmin::User\n\nCopy\n","\nmodule Admin\n  User\nend\n\nmodule Admin\n  User\nend\n\nCopy\n"],"body":"When a qualified constant is missing Rails does not look for it in the parent\nnamespaces. But there is a caveat: when a constant is missing, Rails is\nunable to tell if the trigger was a relative reference or a qualified one.For example, considerandIf User is missing, in either case all Rails knows is that a constant called\n\"User\" was missing in a module called \"Admin\".If there is a top-level User Ruby would resolve it in the former example, but\nwouldn't in the latter. In general, Rails does not emulate the Ruby constant\nresolution algorithms, but in this case it tries using the following heuristic:For example, if this code triggers autoloadingand the User constant is already present in Object, it is not possible that\nthe situation isbecause otherwise Ruby would have resolved User and no autoloading would have\nbeen triggered in the first place. Thus, Rails assumes a qualified reference and\nconsiders the file admin/user.rb and directory admin/user to be the only\nvalid options.In practice, this works quite well as long as the nesting matches all parent\nnamespaces respectively and the constants that make the rule apply are known at\nthat time.However, autoloading happens on demand. If by chance the top-level User was\nnot yet loaded, then Rails assumes a relative reference by contract.Naming conflicts of this kind are rare in practice, but if one occurs,\nrequire_dependency provides a solution by ensuring that the constant needed\nto trigger the heuristic is defined in the conflicting place."},{"title":"6.3 Automatic Modules","anchor":"#automatic-modules","code":[],"body":"When a module acts as a namespace, Rails does not require the application to\ndefine a file for it, a directory matching the namespace is enough.Suppose an application has a back office whose controllers are stored in\napp/controllers/admin. If the Admin module is not yet loaded when\nAdmin::UsersController is hit, Rails needs first to autoload the constant\nAdmin.If autoload_paths has a file called admin.rb Rails is going to load that\none, but if there's no such file and a directory called admin is found, Rails\ncreates an empty module and assigns it to the Admin constant on the fly."},{"title":"6.4 Generic Procedure","anchor":"#generic-procedure","code":["\nif the class or module in which C is missing is Object\n  let ns = ''\nelse\n  let M = the class or module in which C is missing\n\n  if M is anonymous\n    let ns = ''\n  else\n    let ns = M.name\n  end\nend\n\nloop do\n  # Look for a regular file.\n  for dir in autoload_paths\n    if the file \"#{dir}/#{ns.underscore}/c.rb\" exists\n      load/require \"#{dir}/#{ns.underscore}/c.rb\"\n\n      if C is now defined\n        return\n      else\n        raise LoadError\n      end\n    end\n  end\n\n  # Look for an automatic module.\n  for dir in autoload_paths\n    if the directory \"#{dir}/#{ns.underscore}/c\" exists\n      if ns is an empty string\n        let C = Module.new in Object and return\n      else\n        let C = Module.new in ns.constantize and return\n      end\n    end\n  end\n\n  if ns is empty\n    # We reached the top-level without finding the constant.\n    raise NameError\n  else\n    if C exists in any of the parent namespaces\n      # Qualified constants heuristic.\n      raise NameError\n    else\n      # Try again in the parent namespace.\n      let ns = the parent namespace of ns and retry\n    end\n  end\nend\n\nif the class or module in which C is missing is Object\n  let ns = ''\nelse\n  let M = the class or module in which C is missing\n\n  if M is anonymous\n    let ns = ''\n  else\n    let ns = M.name\n  end\nend\n\nloop do\n  # Look for a regular file.\n  for dir in autoload_paths\n    if the file \"#{dir}/#{ns.underscore}/c.rb\" exists\n      load/require \"#{dir}/#{ns.underscore}/c.rb\"\n\n      if C is now defined\n        return\n      else\n        raise LoadError\n      end\n    end\n  end\n\n  # Look for an automatic module.\n  for dir in autoload_paths\n    if the directory \"#{dir}/#{ns.underscore}/c\" exists\n      if ns is an empty string\n        let C = Module.new in Object and return\n      else\n        let C = Module.new in ns.constantize and return\n      end\n    end\n  end\n\n  if ns is empty\n    # We reached the top-level without finding the constant.\n    raise NameError\n  else\n    if C exists in any of the parent namespaces\n      # Qualified constants heuristic.\n      raise NameError\n    else\n      # Try again in the parent namespace.\n      let ns = the parent namespace of ns and retry\n    end\n  end\nend\n\nCopy\n"],"body":"Relative references are reported to be missing in the cref where they were hit,\nand qualified references are reported to be missing in their parent (see\nResolution Algorithm for Relative\nConstants at the beginning of\nthis guide for the definition of cref, and Resolution Algorithm for Qualified\nConstants for the definition of\nparent).The procedure to autoload constant C in an arbitrary situation is as follows:"},{"code":[],"body":"Constant autoloading is triggered on demand and therefore code that uses a\ncertain constant may have it already defined or may trigger an autoload. That\ndepends on the execution path and it may vary between runs.There are times, however, in which you want to make sure a certain constant is\nknown when the execution reaches some code. require_dependency provides a way\nto load a file using the current loading mechanism, and\nkeeping track of constants defined in that file as if they were autoloaded to\nhave them reloaded as needed.require_dependency is rarely needed, but see a couple of use cases in\nAutoloading and STI and When Constants aren't\nTriggered.","title":"7 require_dependency","anchor":"#require-dependency"},{"title":"8 Constant Reloading","anchor":"#constant-reloading","code":["\nirb> reload!\n\nreload!\n\nCopy\n"],"body":"When config.cache_classes is false Rails is able to reload autoloaded\nconstants.For example, if you're in a console session and edit some file behind the\nscenes, the code can be reloaded with the reload! command:When the application runs, code is reloaded when something relevant to this\nlogic changes. In order to do that, Rails monitors a number of things:If anything in there changes, there is a middleware that detects it and reloads\nthe code.Autoloading keeps track of autoloaded constants. Reloading is implemented by\nremoving them all from their respective classes and modules using\nModule#remove_const. That way, when the code goes on, those constants are\ngoing to be unknown again, and files reloaded on demand."},{"title":"9 Common Gotchas","anchor":"#common-gotchas","code":[],"body":""},{"title":"9.1 Nesting and Qualified Constants","anchor":"#nesting-and-qualified-constants","code":["\nmodule Admin\n  class UsersController < ApplicationController\n    def index\n      @users = User.all\n    end\n  end\nend\n\nmodule Admin\n  class UsersController < ApplicationController\n    def index\n      @users = User.all\n    end\n  end\nend\n\nCopy\n","\nclass Admin::UsersController < ApplicationController\n  def index\n    @users = User.all\n  end\nend\n\nclass Admin::UsersController < ApplicationController\n  def index\n    @users = User.all\n  end\nend\n\nCopy\n","\nmodule Admin\n  class UsersController < ApplicationController\n    def index\n      @users = User.all\n    end\n  end\nend\n\nmodule Admin\n  class UsersController < ApplicationController\n    def index\n      @users = User.all\n    end\n  end\nend\n\nCopy\n"],"body":"Let's considerandTo resolve User Ruby checks Admin in the former case, but it does not in\nthe latter because it does not belong to the nesting (see Nesting\nand Resolution Algorithms).Unfortunately Rails autoloading does not know the nesting in the spot where the\nconstant was missing and so it is not able to act as Ruby would. In particular,\nAdmin::User will get autoloaded in either case.Albeit qualified constants with class and module keywords may technically\nwork with autoloading in some cases, it is preferable to use relative constants\ninstead:"},{"code":["\n# app/models/blog.rb\nmodule Blog\n  def self.table_name_prefix\n    \"blog_\"\n  end\nend\n\n# app/models/blog.rb\nmodule Blog\n  def self.table_name_prefix\n    \"blog_\"\n  end\nend\n\nCopy\n","\n# app/models/blog/post.rb\nmodule Blog\n  class Post < ApplicationRecord\n  end\nend\n\n# app/models/blog/post.rb\nmodule Blog\n  class Post < ApplicationRecord\n  end\nend\n\nCopy\n","\n# app/models/blog/post.rb\n\nrequire_dependency \"blog\"\n\nmodule Blog\n  class Post < ApplicationRecord\n  end\nend\n\n# app/models/blog/post.rb\n\nrequire_dependency \"blog\"\n\nmodule Blog\n  class Post < ApplicationRecord\n  end\nend\n\nCopy\n"],"body":"Let's consider:The table name for Blog::Post should be blog_posts due to the existence of\nthe method Blog.table_name_prefix. However, if app/models/blog/post.rb is\nexecuted before app/models/blog.rb is, Active Record is not aware of the\nexistence of such method, and assumes the table is posts.To resolve a situation like this, it helps thinking clearly about which file\ndefines the Blog module (app/models/blog.rb), and which one reopens it\n(app/models/blog/post.rb). Then, you ensure that the definition is executed\nfirst using require_dependency:","title":"9.2 Defining vs Reopening Namespaces","anchor":"#defining-vs-reopening-namespaces"},{"code":["\n# app/models/polygon.rb\nclass Polygon < ApplicationRecord\nend\n\n# app/models/polygon.rb\nclass Polygon < ApplicationRecord\nend\n\nCopy\n","\n# app/models/triangle.rb\nclass Triangle < Polygon\nend\n\n# app/models/triangle.rb\nclass Triangle < Polygon\nend\n\nCopy\n","\n# app/models/rectangle.rb\nclass Rectangle < Polygon\nend\n\n# app/models/rectangle.rb\nclass Rectangle < Polygon\nend\n\nCopy\n","\nSELECT \"polygons\".* FROM \"polygons\"\nWHERE \"polygons\".\"type\" IN (\"Rectangle\")\n\nSELECT \"polygons\".* FROM \"polygons\"\nWHERE \"polygons\".\"type\" IN (\"Rectangle\")\n\nCopy\n","\n# app/models/square.rb\nclass Square < Rectangle\nend\n\n# app/models/square.rb\nclass Square < Rectangle\nend\n\nCopy\n","\nSELECT \"polygons\".* FROM \"polygons\"\nWHERE \"polygons\".\"type\" IN (\"Rectangle\", \"Square\")\n\nSELECT \"polygons\".* FROM \"polygons\"\nWHERE \"polygons\".\"type\" IN (\"Rectangle\", \"Square\")\n\nCopy\n","\nSELECT \"polygons\".* FROM \"polygons\"\nWHERE \"polygons\".\"type\" IN (\"Rectangle\")\n\nSELECT \"polygons\".* FROM \"polygons\"\nWHERE \"polygons\".\"type\" IN (\"Rectangle\")\n\nCopy\n","\n# app/models/rectangle.rb\nclass Rectangle < Polygon\nend\nrequire_dependency 'square'\n\n# app/models/rectangle.rb\nclass Rectangle < Polygon\nend\nrequire_dependency 'square'\n\nCopy\n"],"body":"Single Table Inheritance (STI) is a feature of Active Record that enables\nstoring a hierarchy of models in one single table. The API of such models is\naware of the hierarchy and encapsulates some common needs. For example, given\nthese classes:Triangle.create creates a row that represents a triangle, and\nRectangle.create creates a row that represents a rectangle. If id is the\nID of an existing record, Polygon.find(id) returns an object of the correct\ntype.Methods that operate on collections are also aware of the hierarchy. For\nexample, Polygon.all returns all the records of the table, because all\nrectangles and triangles are polygons. Active Record takes care of returning\ninstances of their corresponding class in the result set.Types are autoloaded as needed. For example, if Polygon.first is a rectangle\nand Rectangle has not yet been loaded, Active Record autoloads it and the\nrecord is correctly instantiated.All good, but if instead of performing queries based on the root class we need\nto work on some subclass, things get interesting.While working with Polygon you do not need to be aware of all its descendants,\nbecause anything in the table is by definition a polygon, but when working with\nsubclasses Active Record needs to be able to enumerate the types it is looking\nfor. Let's see an example.Rectangle.all only loads rectangles by adding a type constraint to the query:Let's introduce now a subclass of Rectangle:Rectangle.all should now return rectangles and squares:But there's a caveat here: How does Active Record know that the class Square\nexists at all?Even if the file app/models/square.rb exists and defines the Square class,\nif no code yet used that class, Rectangle.all issues the queryThat is not a bug, the query includes all known descendants of Rectangle.A way to ensure this works correctly regardless of the order of execution is to\nmanually load the direct subclasses at the bottom of the file that defines each\nintermediate class:This needs to happen for every intermediate (non-root and non-leaf) class. The\nroot class does not scope the query by type, and therefore does not necessarily\nhave to know all its descendants.","title":"9.3 Autoloading and STI","anchor":"#autoloading-and-sti"},{"title":"9.4 Autoloading and require","anchor":"#autoloading-and-require","code":["\nrequire \"user\" # DO NOT DO THIS\n\nclass UsersController < ApplicationController\n  # ...\nend\n\nrequire \"user\" # DO NOT DO THIS\n\nclass UsersController < ApplicationController\n  # ...\nend\n\nCopy\n"],"body":"Files defining constants to be autoloaded should never be required:There are two possible gotchas here in development mode:Just follow the flow and use constant autoloading always, never mix\nautoloading and require. As a last resort, if some file absolutely needs to\nload a certain file use require_dependency to play nice with constant\nautoloading. This option is rarely needed in practice, though.Of course, using require in autoloaded files to load ordinary 3rd party\nlibraries is fine, and Rails is able to distinguish their constants, they are\nnot marked as autoloaded."},{"title":"9.5 Autoloading and Initializers","anchor":"#autoloading-and-initializers","code":["\nAUTH_SERVICE = if Rails.env.production?\n  RealAuthService\nelse\n  MockedAuthService\nend\n\nAUTH_SERVICE = if Rails.env.production?\n  RealAuthService\nelse\n  MockedAuthService\nend\n\nCopy\n","\nclass C\n  def quack\n    'quack!'\n  end\nend\n\nX = C\nObject.instance_eval { remove_const(:C) }\nX.new.quack # => quack!\nX.name      # => C\nC           # => uninitialized constant C (NameError)\n\nclass C\n  def quack\n    'quack!'\n  end\nend\n\nX = C\nObject.instance_eval { remove_const(:C) }\nX.new.quack # => quack!\nX.name      # => C\nC           # => uninitialized constant C (NameError)\n\nCopy\n","\n# app/models/auth_service.rb\nclass AuthService\n  if Rails.env.production?\n    def self.instance\n      RealAuthService\n    end\n  else\n    def self.instance\n      MockedAuthService\n    end\n  end\nend\n\n# app/models/auth_service.rb\nclass AuthService\n  if Rails.env.production?\n    def self.instance\n      RealAuthService\n    end\n  else\n    def self.instance\n      MockedAuthService\n    end\n  end\nend\n\nCopy\n"],"body":"Consider this assignment in config/initializers/set_auth_service.rb:The purpose of this setup would be that the application uses the class that\ncorresponds to the environment via AUTH_SERVICE. In development mode\nMockedAuthService gets autoloaded when the initializer runs. Let's suppose\nwe do some requests, change its implementation, and hit the application again.\nTo our surprise the changes are not reflected. Why?As we saw earlier, Rails removes autoloaded constants,\nbut AUTH_SERVICE stores the original class object. Stale, non-reachable\nusing the original constant, but perfectly functional.The following code summarizes the situation:Because of that, it is not a good idea to autoload constants on application\ninitialization.In the case above we could implement a dynamic access point:and have the application use AuthService.instance instead. AuthService\nwould be loaded on demand and be autoload-friendly."},{"title":"9.6 require_dependency and Initializers","anchor":"#require-dependency-and-initializers","code":[],"body":"As we saw before, require_dependency loads files in an autoloading-friendly\nway. Normally, though, such a call does not make sense in an initializer.One could think about doing some require_dependency\ncalls in an initializer to make sure certain constants are loaded upfront, for\nexample as an attempt to address the gotcha with STIs.Problem is, in development mode autoloaded constants are wiped\nif there is any relevant change in the file system. If that happens then\nwe are in the very same situation the initializer wanted to avoid!Calls to require_dependency have to be strategically written in autoloaded\nspots."},{"title":"9.7 When Constants aren't Missed","anchor":"#when-constants-aren-t-missed","code":[],"body":""},{"title":"9.7.1 Relative References","anchor":"#when-constants-aren-t-missed-relative-references","code":["\n# app/models/flight_model.rb\nclass FlightModel\nend\n\n# app/models/flight_model.rb\nclass FlightModel\nend\n\nCopy\n","\n# app/models/bell_x1/flight_model.rb\nmodule BellX1\n  class FlightModel < FlightModel\n  end\nend\n\n# app/models/bell_x1/flight_model.rb\nmodule BellX1\n  class FlightModel < FlightModel\n  end\nend\n\nCopy\n","\n# app/models/bell_x1/aircraft.rb\nmodule BellX1\n  class Aircraft\n    def initialize\n      @flight_model = FlightModel.new\n    end\n  end\nend\n\n# app/models/bell_x1/aircraft.rb\nmodule BellX1\n  class Aircraft\n    def initialize\n      @flight_model = FlightModel.new\n    end\n  end\nend\n\nCopy\n","\nmodule BellX1\n  class Plane\n    def flight_model\n      @flight_model ||= BellX1::FlightModel.new\n    end\n  end\nend\n\nmodule BellX1\n  class Plane\n    def flight_model\n      @flight_model ||= BellX1::FlightModel.new\n    end\n  end\nend\n\nCopy\n","\nrequire_dependency 'bell_x1/flight_model'\n\nmodule BellX1\n  class Plane\n    def flight_model\n      @flight_model ||= FlightModel.new\n    end\n  end\nend\n\nrequire_dependency 'bell_x1/flight_model'\n\nmodule BellX1\n  class Plane\n    def flight_model\n      @flight_model ||= FlightModel.new\n    end\n  end\nend\n\nCopy\n"],"body":"Let's consider a flight simulator. The application has a default flight modelthat can be overridden by each airplane, for instanceThe initializer wants to create a BellX1::FlightModel and nesting has\nBellX1, that looks good. But if the default flight model is loaded and the\none for the Bell-X1 is not, the interpreter is able to resolve the top-level\nFlightModel and autoloading is thus not triggered for BellX1::FlightModel.That code depends on the execution path.These kind of ambiguities can often be resolved using qualified constants:Also, require_dependency is a solution:"},{"code":["\n# app/models/hotel.rb\nclass Hotel\nend\n\n# app/models/hotel.rb\nclass Hotel\nend\n\nCopy\n","\n# app/models/image.rb\nclass Image\nend\n\n# app/models/image.rb\nclass Image\nend\n\nCopy\n","\n# app/models/hotel/image.rb\nclass Hotel\n  class Image < Image\n  end\nend\n\n# app/models/hotel/image.rb\nclass Hotel\n  class Image < Image\n  end\nend\n\nCopy\n","\n$ bin/rails runner 'Image; p Hotel::Image' 2>/dev/null\nImage # NOT Hotel::Image!\n\nbin/rails runner 'Image; p Hotel::Image' 2>/dev/null\n\nCopy\n","\nwarning: toplevel constant Image referenced by Hotel::Image\n\nwarning: toplevel constant Image referenced by Hotel::Image\n\nCopy\n","\nirb(main):001:0> String::Array\n(irb):1: warning: toplevel constant Array referenced by String::Array\n=> Array\n\nString::Array\n\nCopy\n"],"body":"Giventhe expression Hotel::Image is ambiguous because it depends on the execution\npath.As we saw before, Ruby looks\nup the constant in Hotel and its ancestors. If app/models/image.rb has\nbeen loaded but app/models/hotel/image.rb hasn't, Ruby does not find Image\nin Hotel, but it does in Object:The code evaluating Hotel::Image needs to make sure\napp/models/hotel/image.rb has been loaded, possibly with\nrequire_dependency.In these cases the interpreter issues a warning though:This surprising constant resolution can be observed with any qualifying class:","title":"9.7.2 Qualified References","anchor":"#when-constants-aren-t-missed-qualified-references"},{"title":"9.8 Autoloading within Singleton Classes","anchor":"#autoloading-within-singleton-classes","code":["\n# app/models/hotel/services.rb\nmodule Hotel\n  class Services\n  end\nend\n\n# app/models/hotel/services.rb\nmodule Hotel\n  class Services\n  end\nend\n\nCopy\n","\n# app/models/hotel/geo_location.rb\nmodule Hotel\n  class GeoLocation\n    class << self\n      Services\n    end\n  end\nend\n\n# app/models/hotel/geo_location.rb\nmodule Hotel\n  class GeoLocation\n    class << self\n      Services\n    end\n  end\nend\n\nCopy\n","\nmodule Hotel\n  class GeoLocation\n    class << self\n      Hotel::Services\n    end\n  end\nend\n\nmodule Hotel\n  class GeoLocation\n    class << self\n      Hotel::Services\n    end\n  end\nend\n\nCopy\n"],"body":"Let's suppose we have these class definitions:If Hotel::Services is known by the time app/models/hotel/geo_location.rb\nis being loaded, Services is resolved by Ruby because Hotel belongs to the\nnesting when the singleton class of Hotel::GeoLocation is opened.But if Hotel::Services is not known, Rails is not able to autoload it, the\napplication raises NameError.The reason is that autoloading is triggered for the singleton class, which is\nanonymous, and as we saw before, Rails only checks the\ntop-level namespace in that edge case.An easy solution to this caveat is to qualify the constant:"},{"code":["\nclass C < BasicObject\n  String # NameError: uninitialized constant C::String\nend\n\nclass C < BasicObject\n  String # NameError: uninitialized constant C::String\nend\n\nCopy\n","\nclass C < BasicObject\n  def user\n    User # WRONG\n  end\nend\n\nclass C < BasicObject\n  def user\n    User # WRONG\n  end\nend\n\nCopy\n","\nc = C.new\nc.user # surprisingly fine, User\nc.user # NameError: uninitialized constant C::User\n\nc = C.new\nc.user # surprisingly fine, User\nc.user # NameError: uninitialized constant C::User\n\nCopy\n","\nclass C < BasicObject\n  ::String # RIGHT\n\n  def user\n    ::User # RIGHT\n  end\nend\n\nclass C < BasicObject\n  ::String # RIGHT\n\n  def user\n    ::User # RIGHT\n  end\nend\n\nCopy\n"],"body":"Direct descendants of BasicObject do not have Object among their ancestors\nand cannot resolve top-level constants:When autoloading is involved that plot has a twist. Let's consider:Since Rails checks the top-level namespace User gets autoloaded just fine the\nfirst time the user method is invoked. You only get the exception if the\nUser constant is known at that point, in particular in a second call to\nuser:because it detects that a parent namespace already has the constant (see Qualified\nReferences).As with pure Ruby, within the body of a direct descendant of BasicObject use\nalways absolute constant paths:","title":"9.9 Autoloading in BasicObject","anchor":"#autoloading-in-basicobject"},{"code":[],"body":"When configuring the test environment for autoloading you might consider multiple factors.For example it might be worth running your tests with an identical setup to production (config.eager_load = true, config.cache_classes = true) in order to catch any problems before they hit production (this is compensation for the lack of dev-prod parity). However this will slow down the boot time for individual tests on a dev machine (and is not immediately compatible with spring see below). So one possibility is to do this on a\nCI machine only (which should run without spring).On a development machine you can then have your tests running with whatever is fastest (ideally config.eager_load = false).With the Spring pre-loader (included with new Rails apps), you ideally keep config.eager_load = false as per development. Sometimes you may end up with a hybrid configuration (config.eager_load = true, config.cache_classes = true AND config.enable_dependency_loading = true), see spring issue. However it might be simpler to keep the same configuration as development, and work out whatever it is that is causing autoloading to fail (perhaps by the results of your CI test results).Occasionally you may need to explicitly eager_load by using Rails\n.application.eager_load! in the setup of your tests -- this might occur if your tests involve multithreading.","title":"9.10 Autoloading in the Test Environment","anchor":"#autoloading-in-the-test-environment"},{"title":"10 Troubleshooting","anchor":"#troubleshooting","code":[],"body":""},{"title":"10.1 Tracing Autoloads","anchor":"#tracing-autoloads","code":["\nActiveSupport::Dependencies.logger = Rails.logger\nActiveSupport::Dependencies.verbose = true\n\nActiveSupport::Dependencies.logger = Rails.logger\nActiveSupport::Dependencies.verbose = true\n\nCopy\n"],"body":"Active Support is able to report constants as they are autoloaded. To enable these traces in a Rails application, put the following two lines in some initializer:"},{"code":["\nputs caller\n\nputs caller\n\nCopy\n"],"body":"If constant Foo is being autoloaded, and you'd like to know where is that autoload coming from, just throwat the top of foo.rb and inspect the printed stack trace.","title":"10.2 Where is a Given Autoload Triggered?","anchor":"#where-is-a-given-autoload-triggered-questionmark"},{"title":"10.3 Which Constants Have Been Autoloaded?","anchor":"#which-constants-have-been-autoloaded-questionmark","code":["\nActiveSupport::Dependencies.autoloaded_constants\n\nActiveSupport::Dependencies.autoloaded_constants\n\nCopy\n"],"body":"At any given time,has the collection of constants that have been autoloaded so far."}]