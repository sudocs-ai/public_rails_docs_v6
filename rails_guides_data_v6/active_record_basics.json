[{"code":[],"body":"Active Record is the M in MVC - the\nmodel - which is the layer of the system responsible for representing business\ndata and logic. Active Record facilitates the creation and use of business\nobjects whose data requires persistent storage to a database. It is an\nimplementation of the Active Record pattern which itself is a description of an\nObject Relational Mapping system.","title":"1 What is Active Record?","anchor":"#what-is-active-record-questionmark"},{"title":"1.1 The Active Record Pattern","anchor":"#the-active-record-pattern","code":[],"body":"Active Record was described by Martin Fowler\nin his book Patterns of Enterprise Application Architecture. In\nActive Record, objects carry both persistent data and behavior which\noperates on that data. Active Record takes the opinion that ensuring\ndata access logic as part of the object will educate users of that\nobject on how to write to and read from the database."},{"title":"1.2 Object Relational Mapping","anchor":"#object-relational-mapping","code":[],"body":"Object Relational Mapping, commonly referred to as its abbreviation ORM, is\na technique that connects the rich objects of an application to tables in\na relational database management system. Using ORM, the properties and\nrelationships of the objects in an application can be easily stored and\nretrieved from a database without writing SQL statements directly and with less\noverall database access code."},{"title":"1.3 Active Record as an ORM Framework","anchor":"#active-record-as-an-orm-framework","code":[],"body":"Active Record gives us several mechanisms, the most important being the ability\nto:"},{"code":[],"body":"When writing applications using other programming languages or frameworks, it\nmay be necessary to write a lot of configuration code. This is particularly true\nfor ORM frameworks in general. However, if you follow the conventions adopted by\nRails, you'll need to write very little configuration (in some cases no\nconfiguration at all) when creating Active Record models. The idea is that if\nyou configure your applications in the very same way most of the time then this\nshould be the default way. Thus, explicit configuration would be needed\nonly in those cases where you can't follow the standard convention.","title":"2 Convention over Configuration in Active Record","anchor":"#convention-over-configuration-in-active-record"},{"title":"2.1 Naming Conventions","anchor":"#naming-conventions","code":[],"body":"By default, Active Record uses some naming conventions to find out how the\nmapping between models and database tables should be created. Rails will\npluralize your class names to find the respective database table. So, for\na class Book, you should have a database table called books. The Rails\npluralization mechanisms are very powerful, being capable of pluralizing (and\nsingularizing) both regular and irregular words. When using class names composed\nof two or more words, the model class name should follow the Ruby conventions,\nusing the CamelCase form, while the table name must contain the words separated\nby underscores. Examples:"},{"code":[],"body":"Active Record uses naming conventions for the columns in database tables,\ndepending on the purpose of these columns.There are also some optional column names that will add additional features\nto Active Record instances:","title":"2.2 Schema Conventions","anchor":"#schema-conventions"},{"title":"3 Creating Active Record Models","anchor":"#creating-active-record-models","code":["\nclass Product < ApplicationRecord\nend\n\nclass Product < ApplicationRecord\nend\n\nCopy\n","\nCREATE TABLE products (\n  id int(11) NOT NULL auto_increment,\n  name varchar(255),\n  PRIMARY KEY  (id)\n);\n\nCREATE TABLE products (\n  id int(11) NOT NULL auto_increment,\n  name varchar(255),\n  PRIMARY KEY  (id)\n);\n\nCopy\n","\np = Product.new\np.name = \"Some Book\"\nputs p.name # \"Some Book\"\n\np = Product.new\np.name = \"Some Book\"\nputs p.name # \"Some Book\"\n\nCopy\n"],"body":"To create Active Record models, subclass the ApplicationRecord class and you're good to go:This will create a Product model, mapped to a products table at the\ndatabase. By doing this you'll also have the ability to map the columns of each\nrow in that table with the attributes of the instances of your model. Suppose\nthat the products table was created using an SQL (or one of its extensions) statement like:The schema above declares a table with two columns: id and name. Each row of\nthis table represents a certain product with these two parameters. Thus, you\nwould be able to write code like the following:"},{"code":["\nclass Product < ApplicationRecord\n  self.table_name = \"my_products\"\nend\n\nclass Product < ApplicationRecord\n  self.table_name = \"my_products\"\nend\n\nCopy\n","\nclass ProductTest < ActiveSupport::TestCase\n  set_fixture_class my_products: Product\n  fixtures :my_products\n  # ...\nend\n\nclass ProductTest < ActiveSupport::TestCase\n  set_fixture_class my_products: Product\n  fixtures :my_products\n  # ...\nend\n\nCopy\n","\nclass Product < ApplicationRecord\n  self.primary_key = \"product_id\"\nend\n\nclass Product < ApplicationRecord\n  self.primary_key = \"product_id\"\nend\n\nCopy\n"],"body":"What if you need to follow a different naming convention or need to use your\nRails application with a legacy database? No problem, you can easily override\nthe default conventions.ApplicationRecord inherits from ActiveRecord::Base, which defines a\nnumber of helpful methods. You can use the ActiveRecord::Base.table_name=\nmethod to specify the table name that should be used:If you do so, you will have to define manually the class name that is hosting\nthe fixtures (my_products.yml) using the set_fixture_class method in your test\ndefinition:It's also possible to override the column that should be used as the table's\nprimary key using the ActiveRecord::Base.primary_key= method:","title":"4 Overriding the Naming Conventions","anchor":"#overriding-the-naming-conventions"},{"title":"5 CRUD: Reading and Writing Data","anchor":"#crud-reading-and-writing-data","code":[],"body":"CRUD is an acronym for the four verbs we use to operate on data: Create,\nRead, Update and Delete. Active Record automatically creates methods\nto allow an application to read and manipulate data stored within its tables."},{"title":"5.1 Create","anchor":"#create","code":["\nuser = User.create(name: \"David\", occupation: \"Code Artist\")\n\nuser = User.create(name: \"David\", occupation: \"Code Artist\")\n\nCopy\n","\nuser = User.new\nuser.name = \"David\"\nuser.occupation = \"Code Artist\"\n\nuser = User.new\nuser.name = \"David\"\nuser.occupation = \"Code Artist\"\n\nCopy\n","\nuser = User.new do |u|\n  u.name = \"David\"\n  u.occupation = \"Code Artist\"\nend\n\nuser = User.new do |u|\n  u.name = \"David\"\n  u.occupation = \"Code Artist\"\nend\n\nCopy\n"],"body":"Active Record objects can be created from a hash, a block, or have their\nattributes manually set after creation. The new method will return a new\nobject while create will return the object and save it to the database.For example, given a model User with attributes of name and occupation,\nthe create method call will create and save a new record into the database:Using the new method, an object can be instantiated without being saved:A call to user.save will commit the record to the database.Finally, if a block is provided, both create and new will yield the new\nobject to that block for initialization:"},{"code":["\n# return a collection with all users\nusers = User.all\n\n# return a collection with all users\nusers = User.all\n\nCopy\n","\n# return the first user\nuser = User.first\n\n# return the first user\nuser = User.first\n\nCopy\n","\n# return the first user named David\ndavid = User.find_by(name: 'David')\n\n# return the first user named David\ndavid = User.find_by(name: 'David')\n\nCopy\n","\n# find all users named David who are Code Artists and sort by created_at in reverse chronological order\nusers = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)\n\n# find all users named David who are Code Artists and sort by created_at in reverse chronological order\nusers = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)\n\nCopy\n"],"body":"Active Record provides a rich API for accessing data within a database. Below\nare a few examples of different data access methods provided by Active Record.You can learn more about querying an Active Record model in the Active Record\nQuery Interface guide.","title":"5.2 Read","anchor":"#read"},{"title":"5.3 Update","anchor":"#update","code":["\nuser = User.find_by(name: 'David')\nuser.name = 'Dave'\nuser.save\n\nuser = User.find_by(name: 'David')\nuser.name = 'Dave'\nuser.save\n\nCopy\n","\nuser = User.find_by(name: 'David')\nuser.update(name: 'Dave')\n\nuser = User.find_by(name: 'David')\nuser.update(name: 'Dave')\n\nCopy\n","\nUser.update_all \"max_login_attempts = 3, must_change_password = 'true'\"\n\nUser.update_all \"max_login_attempts = 3, must_change_password = 'true'\"\n\nCopy\n"],"body":"Once an Active Record object has been retrieved, its attributes can be modified\nand it can be saved to the database.A shorthand for this is to use a hash mapping attribute names to the desired\nvalue, like so:This is most useful when updating several attributes at once. If, on the other\nhand, you'd like to update several records in bulk, you may find the\nupdate_all class method useful:"},{"code":["\nuser = User.find_by(name: 'David')\nuser.destroy\n\nuser = User.find_by(name: 'David')\nuser.destroy\n\nCopy\n","\n# find and delete all users named David\nUser.destroy_by(name: 'David')\n\n# delete all users\nUser.destroy_all\n\n# find and delete all users named David\nUser.destroy_by(name: 'David')\n\n# delete all users\nUser.destroy_all\n\nCopy\n"],"body":"Likewise, once retrieved an Active Record object can be destroyed which removes\nit from the database.If you'd like to delete several records in bulk, you may use destroy_by\nor destroy_all method:","title":"5.4 Delete","anchor":"#delete"},{"code":["\nclass User < ApplicationRecord\n  validates :name, presence: true\nend\n\nclass User < ApplicationRecord\n  validates :name, presence: true\nend\n\nCopy\n","\nirb> user = User.new\nirb> user.save\n=> false\nirb> user.save!\nActiveRecord::RecordInvalid: Validation failed: Name can't be blank\n\nuser = User.new\nuser.save\nuser.save!\n\nCopy\n"],"body":"Active Record allows you to validate the state of a model before it gets written\ninto the database. There are several methods that you can use to check your\nmodels and validate that an attribute value is not empty, is unique and not\nalready in the database, follows a specific format, and many more.Validation is a very important issue to consider when persisting to the database, so\nthe methods save and update take it into account when\nrunning: they return false when validation fails and they don't actually\nperform any operations on the database. All of these have a bang counterpart (that\nis, save! and update!), which are stricter in that\nthey raise the exception ActiveRecord::RecordInvalid if validation fails.\nA quick example to illustrate:You can learn more about validations in the Active Record Validations\nguide.","title":"6 Validations","anchor":"#validations"},{"title":"7 Callbacks","anchor":"#callbacks","code":[],"body":"Active Record callbacks allow you to attach code to certain events in the\nlife-cycle of your models. This enables you to add behavior to your models by\ntransparently executing code when those events occur, like when you create a new\nrecord, update it, destroy it, and so on. You can learn more about callbacks in\nthe Active Record Callbacks guide."},{"title":"8 Migrations","anchor":"#migrations","code":["\nclass CreatePublications < ActiveRecord::Migration[6.0]\n  def change\n    create_table :publications do |t|\n      t.string :title\n      t.text :description\n      t.references :publication_type\n      t.integer :publisher_id\n      t.string :publisher_type\n      t.boolean :single_issue\n\n      t.timestamps\n    end\n    add_index :publications, :publication_type_id\n  end\nend\n\nclass CreatePublications < ActiveRecord::Migration[6.0]\n  def change\n    create_table :publications do |t|\n      t.string :title\n      t.text :description\n      t.references :publication_type\n      t.integer :publisher_id\n      t.string :publisher_type\n      t.boolean :single_issue\n\n      t.timestamps\n    end\n    add_index :publications, :publication_type_id\n  end\nend\n\nCopy\n"],"body":"Rails provides a domain-specific language for managing a database schema called\nmigrations. Migrations are stored in files which are executed against any\ndatabase that Active Record supports using rake. Here's a migration that\ncreates a table:Rails keeps track of which files have been committed to the database and\nprovides rollback features. To actually create the table, you'd run bin/rails db:migrate,\nand to roll it back, bin/rails db:rollback.Note that the above code is database-agnostic: it will run in MySQL,\nPostgreSQL, Oracle, and others. You can learn more about migrations in the\nActive Record Migrations guide."}]