[{"code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nCopy\n","\nirb> Person.create(name: \"John Doe\").valid?\n=> true\nirb> Person.create(name: nil).valid?\n=> false\n\nPerson.create(name: \"John Doe\").valid?\nPerson.create(name: nil).valid?\n\nCopy\n"],"body":"Here's an example of a very simple validation:As you can see, our validation lets us know that our Person is not valid\nwithout a name attribute. The second Person will not be persisted to the\ndatabase.Before we dig into more details, let's talk about how validations fit into the\nbig picture of your application.","title":"1 Validations Overview","anchor":"#validations-overview"},{"title":"1.1 Why Use Validations?","anchor":"#why-use-validations-questionmark","code":[],"body":"Validations are used to ensure that only valid data is saved into your\ndatabase. For example, it may be important to your application to ensure that\nevery user provides a valid email address and mailing address. Model-level\nvalidations are the best way to ensure that only valid data is saved into your\ndatabase. They are database agnostic, cannot be bypassed by end users, and are\nconvenient to test and maintain. Rails provides built-in helpers for common\nneeds, and allows you to create your own validation methods as well.There are several other ways to validate data before it is saved into your\ndatabase, including native database constraints, client-side validations and\ncontroller-level validations. Here's a summary of the pros and cons:Choose these in certain, specific cases. It's the opinion of the Rails team\nthat model-level validations are the most appropriate in most circumstances."},{"title":"1.2 When Does Validation Happen?","anchor":"#when-does-validation-happen-questionmark","code":["\nclass Person < ApplicationRecord\nend\n\nclass Person < ApplicationRecord\nend\n\nCopy\n","\nirb> p = Person.new(name: \"John Doe\")\n=> #<Person id: nil, name: \"John Doe\", created_at: nil, updated_at: nil>\n\nirb> p.new_record?\n=> true\n\nirb> p.save\n=> true\n\nirb> p.new_record?\n=> false\n\np = Person.new(name: \"John Doe\")\np.new_record?\np.save\np.new_record?\n\nCopy\n"],"body":"There are two kinds of Active Record objects: those that correspond to a row\ninside your database and those that do not. When you create a fresh object, for\nexample using the new method, that object does not belong to the database\nyet. Once you call save upon that object it will be saved into the\nappropriate database table. Active Record uses the new_record? instance\nmethod to determine whether an object is already in the database or not.\nConsider the following Active Record class:We can see how it works by looking at some bin/rails console output:Creating and saving a new record will send an SQL INSERT operation to the\ndatabase. Updating an existing record will send an SQL UPDATE operation\ninstead. Validations are typically run before these commands are sent to the\ndatabase. If any validations fail, the object will be marked as invalid and\nActive Record will not perform the INSERT or UPDATE operation. This avoids\nstoring an invalid object in the database. You can choose to have specific\nvalidations run when an object is created, saved, or updated.The following methods trigger validations, and will save the object to the\ndatabase only if the object is valid:The bang versions (e.g. save!) raise an exception if the record is invalid.\nThe non-bang versions don't: save and update return false, and\ncreate returns the object."},{"title":"1.3 Skipping Validations","anchor":"#skipping-validations","code":[],"body":"The following methods skip validations, and will save the object to the\ndatabase regardless of its validity. They should be used with caution.Note that save also has the ability to skip validations if passed validate:\nfalse as an argument. This technique should be used with caution."},{"code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nCopy\n","\nirb> Person.create(name: \"John Doe\").valid?\n=> true\nirb> Person.create(name: nil).valid?\n=> false\n\nPerson.create(name: \"John Doe\").valid?\nPerson.create(name: nil).valid?\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nCopy\n","\nirb> p = Person.new\n=> #<Person id: nil, name: nil>\nirb> p.errors.size\n=> 0\n\nirb> p.valid?\n=> false\nirb> p.errors.objects.first.full_message\n=> \"Name can't be blank\"\n\nirb> p = Person.create\n=> #<Person id: nil, name: nil>\nirb> p.errors.objects.first.full_message\n=> \"Name can't be blank\"\n\nirb> p.save\n=> false\n\nirb> p.save!\nActiveRecord::RecordInvalid: Validation failed: Name can't be blank\n\nirb> Person.create!\nActiveRecord::RecordInvalid: Validation failed: Name can't be blank\n\np = Person.new\np.errors.size\np.valid?\np.errors.objects.first.full_message\np = Person.create\np.errors.objects.first.full_message\np.save\np.save!\nPerson.create!\n\nCopy\n"],"body":"Before saving an Active Record object, Rails runs your validations.\nIf these validations produce any errors, Rails does not save the object.You can also run these validations on your own. valid? triggers your validations\nand returns true if no errors were found in the object, and false otherwise.\nAs you saw above:After Active Record has performed validations, any errors found can be accessed\nthrough the errors instance method, which returns a collection of errors.\nBy definition, an object is valid if this collection is empty after running\nvalidations.Note that an object instantiated with new will not report errors\neven if it's technically invalid, because validations are automatically run\nonly when the object is saved, such as with the create or save methods.invalid? is the inverse of valid?. It triggers your validations,\nreturning true if any errors were found in the object, and false otherwise.","title":"1.4 valid? and invalid?","anchor":"#valid-questionmark-and-invalid-questionmark"},{"title":"1.5 errors[]","anchor":"#validations-overview-errors","code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true\nend\n\nCopy\n","\nirb> Person.new.errors[:name].any?\n=> false\nirb> Person.create.errors[:name].any?\n=> true\n\nPerson.new.errors[:name].any?\nPerson.create.errors[:name].any?\n\nCopy\n"],"body":"To verify whether or not a particular attribute of an object is valid, you can\nuse errors[:attribute]. It returns an array of all the error messages for\n:attribute. If there are no errors on the specified attribute, an empty array\nis returned.This method is only useful after validations have been run, because it only\ninspects the errors collection and does not trigger validations itself. It's\ndifferent from the ActiveRecord::Base#invalid? method explained above because\nit doesn't verify the validity of the object as a whole. It only checks to see\nwhether there are errors found on an individual attribute of the object.We'll cover validation errors in greater depth in the Working with Validation\nErrors section."},{"title":"2 Validation Helpers","anchor":"#validation-helpers","code":[],"body":"Active Record offers many pre-defined validation helpers that you can use\ndirectly inside your class definitions. These helpers provide common validation\nrules. Every time a validation fails, an error is added to the object's\nerrors collection, and this is associated with the attribute being\nvalidated.Each helper accepts an arbitrary number of attribute names, so with a single\nline of code you can add the same kind of validation to several attributes.All of them accept the :on and :message options, which define when the\nvalidation should be run and what message should be added to the errors\ncollection if it fails, respectively. The :on option takes one of the values\n:create or :update. There is a default error\nmessage for each one of the validation helpers. These messages are used when\nthe :message option isn't specified. Let's take a look at each one of the\navailable helpers."},{"title":"2.1 acceptance","anchor":"#acceptance","code":["\nclass Person < ApplicationRecord\n  validates :terms_of_service, acceptance: true\nend\n\nclass Person < ApplicationRecord\n  validates :terms_of_service, acceptance: true\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :terms_of_service, acceptance: { message: 'must be abided' }\nend\n\nclass Person < ApplicationRecord\n  validates :terms_of_service, acceptance: { message: 'must be abided' }\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :terms_of_service, acceptance: { accept: 'yes' }\n  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }\nend\n\nclass Person < ApplicationRecord\n  validates :terms_of_service, acceptance: { accept: 'yes' }\n  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }\nend\n\nCopy\n"],"body":"This method validates that a checkbox on the user interface was checked when a\nform was submitted. This is typically used when the user needs to agree to your\napplication's terms of service, confirm that some text is read, or any similar\nconcept.This check is performed only if terms_of_service is not nil.\nThe default error message for this helper is \"must be accepted\".\nYou can also pass in a custom message via the message option.It can also receive an :accept option, which determines the allowed values\nthat will be considered as accepted. It defaults to ['1', true] and can be\neasily changed.This validation is very specific to web applications and this\n'acceptance' does not need to be recorded anywhere in your database. If you\ndon't have a field for it, the helper will create a virtual attribute. If\nthe field does exist in your database, the accept option must be set to\nor include true or else the validation will not run."},{"title":"2.2 validates_associated","anchor":"#validates-associated","code":["\nclass Library < ApplicationRecord\n  has_many :books\n  validates_associated :books\nend\n\nclass Library < ApplicationRecord\n  has_many :books\n  validates_associated :books\nend\n\nCopy\n"],"body":"You should use this helper when your model has associations with other models\nand they also need to be validated. When you try to save your object, valid?\nwill be called upon each one of the associated objects.This validation will work with all of the association types.The default error message for validates_associated is \"is invalid\". Note\nthat each associated object will contain its own errors collection; errors do\nnot bubble up to the calling model."},{"title":"2.3 confirmation","anchor":"#confirmation","code":["\nclass Person < ApplicationRecord\n  validates :email, confirmation: true\nend\n\nclass Person < ApplicationRecord\n  validates :email, confirmation: true\nend\n\nCopy\n","\n<%= text_field :person, :email %>\n<%= text_field :person, :email_confirmation %>\n\n<%= text_field :person, :email %>\n<%= text_field :person, :email_confirmation %>\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :email, confirmation: true\n  validates :email_confirmation, presence: true\nend\n\nclass Person < ApplicationRecord\n  validates :email, confirmation: true\n  validates :email_confirmation, presence: true\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :email, confirmation: { case_sensitive: false }\nend\n\nclass Person < ApplicationRecord\n  validates :email, confirmation: { case_sensitive: false }\nend\n\nCopy\n"],"body":"You should use this helper when you have two text fields that should receive\nexactly the same content. For example, you may want to confirm an email address\nor a password. This validation creates a virtual attribute whose name is the\nname of the field that has to be confirmed with \"_confirmation\" appended.In your view template you could use something likeThis check is performed only if email_confirmation is not nil. To require\nconfirmation, make sure to add a presence check for the confirmation attribute\n(we'll take a look at presence later on in this guide):There is also a :case_sensitive option that you can use to define whether the\nconfirmation constraint will be case sensitive or not. This option defaults to\ntrue.The default error message for this helper is \"doesn't match confirmation\"."},{"title":"2.4 exclusion","anchor":"#exclusion","code":["\nclass Account < ApplicationRecord\n  validates :subdomain, exclusion: { in: %w(www us ca jp),\n    message: \"%{value} is reserved.\" }\nend\n\nclass Account < ApplicationRecord\n  validates :subdomain, exclusion: { in: %w(www us ca jp),\n    message: \"%{value} is reserved.\" }\nend\n\nCopy\n"],"body":"This helper validates that the attributes' values are not included in a given\nset. In fact, this set can be any enumerable object.The exclusion helper has an option :in that receives the set of values that\nwill not be accepted for the validated attributes. The :in option has an\nalias called :within that you can use for the same purpose, if you'd like to.\nThis example uses the :message option to show how you can include the\nattribute's value. For full options to the message argument please see the\nmessage documentation.The default error message is \"is reserved\"."},{"title":"2.5 format","anchor":"#format","code":["\nclass Product < ApplicationRecord\n  validates :legacy_code, format: { with: /\\A[a-zA-Z]+\\z/,\n    message: \"only allows letters\" }\nend\n\nclass Product < ApplicationRecord\n  validates :legacy_code, format: { with: /\\A[a-zA-Z]+\\z/,\n    message: \"only allows letters\" }\nend\n\nCopy\n"],"body":"This helper validates the attributes' values by testing whether they match a\ngiven regular expression, which is specified using the :with option.Alternatively, you can require that the specified attribute does not match the regular expression by using the :without option.The default error message is \"is invalid\"."},{"title":"2.6 inclusion","anchor":"#inclusion","code":["\nclass Coffee < ApplicationRecord\n  validates :size, inclusion: { in: %w(small medium large),\n    message: \"%{value} is not a valid size\" }\nend\n\nclass Coffee < ApplicationRecord\n  validates :size, inclusion: { in: %w(small medium large),\n    message: \"%{value} is not a valid size\" }\nend\n\nCopy\n"],"body":"This helper validates that the attributes' values are included in a given set.\nIn fact, this set can be any enumerable object.The inclusion helper has an option :in that receives the set of values that\nwill be accepted. The :in option has an alias called :within that you can\nuse for the same purpose, if you'd like to. The previous example uses the\n:message option to show how you can include the attribute's value. For full\noptions please see the message documentation.The default error message for this helper is \"is not included in the list\"."},{"title":"2.7 length","anchor":"#length","code":["\nclass Person < ApplicationRecord\n  validates :name, length: { minimum: 2 }\n  validates :bio, length: { maximum: 500 }\n  validates :password, length: { in: 6..20 }\n  validates :registration_number, length: { is: 6 }\nend\n\nclass Person < ApplicationRecord\n  validates :name, length: { minimum: 2 }\n  validates :bio, length: { maximum: 500 }\n  validates :password, length: { in: 6..20 }\n  validates :registration_number, length: { is: 6 }\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :bio, length: { maximum: 1000,\n    too_long: \"%{count} characters is the maximum allowed\" }\nend\n\nclass Person < ApplicationRecord\n  validates :bio, length: { maximum: 1000,\n    too_long: \"%{count} characters is the maximum allowed\" }\nend\n\nCopy\n"],"body":"This helper validates the length of the attributes' values. It provides a\nvariety of options, so you can specify length constraints in different ways:The possible length constraint options are:The default error messages depend on the type of length validation being\nperformed. You can customize these messages using the :wrong_length,\n:too_long, and :too_short options and %{count} as a placeholder for the\nnumber corresponding to the length constraint being used. You can still use the\n:message option to specify an error message.Note that the default error messages are plural (e.g., \"is too short (minimum\nis %{count} characters)\"). For this reason, when :minimum is 1 you should\nprovide a custom message or use presence: true instead. When\n:in or :within have a lower limit of 1, you should either provide a\ncustom message or call presence prior to length."},{"title":"2.8 numericality","anchor":"#numericality","code":["\n/\\A[+-]?\\d+\\z/\n\n/\\A[+-]?\\d+\\z/\n\nCopy\n","\nclass Player < ApplicationRecord\n  validates :points, numericality: true\n  validates :games_played, numericality: { only_integer: true }\nend\n\nclass Player < ApplicationRecord\n  validates :points, numericality: true\n  validates :games_played, numericality: { only_integer: true }\nend\n\nCopy\n"],"body":"This helper validates that your attributes have only numeric values. By\ndefault, it will match an optional sign followed by an integral or floating\npoint number.To specify that only integral numbers are allowed,\nset :only_integer to true. Then it will use theregular expression to validate the attribute's value. Otherwise, it will try to\nconvert the value to a number using Float. Floats are casted to BigDecimal using the column's precision value or 15.The default error message for :only_integer is \"must be an integer\".Besides :only_integer, this helper also accepts the following options to add\nconstraints to acceptable values:The default error message when no options are specified is \"is not a number\"."},{"title":"2.9 presence","anchor":"#presence","code":["\nclass Person < ApplicationRecord\n  validates :name, :login, :email, presence: true\nend\n\nclass Person < ApplicationRecord\n  validates :name, :login, :email, presence: true\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account\n  validates :account, presence: true\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account\n  validates :account, presence: true\nend\n\nCopy\n","\nclass Order < ApplicationRecord\n  has_many :line_items, inverse_of: :order\nend\n\nclass Order < ApplicationRecord\n  has_many :line_items, inverse_of: :order\nend\n\nCopy\n","\nvalidates :boolean_field_name, inclusion: [true, false]\nvalidates :boolean_field_name, exclusion: [nil]\n\nvalidates :boolean_field_name, inclusion: [true, false]\nvalidates :boolean_field_name, exclusion: [nil]\n\nCopy\n"],"body":"This helper validates that the specified attributes are not empty. It uses the\nblank? method to check if the value is either nil or a blank string, that\nis, a string that is either empty or consists of whitespace.If you want to be sure that an association is present, you'll need to test\nwhether the associated object itself is present, and not the foreign key used\nto map the association. This way, it is not only checked that the foreign key\nis not empty but also that the referenced object exists.In order to validate associated records whose presence is required, you must\nspecify the :inverse_of option for the association:If you validate the presence of an object associated via a has_one or\nhas_many relationship, it will check that the object is neither blank? nor\nmarked_for_destruction?.Since false.blank? is true, if you want to validate the presence of a boolean\nfield you should use one of the following validations:By using one of these validations, you will ensure the value will NOT be nil\nwhich would result in a NULL value in most cases."},{"title":"2.10 absence","anchor":"#absence","code":["\nclass Person < ApplicationRecord\n  validates :name, :login, :email, absence: true\nend\n\nclass Person < ApplicationRecord\n  validates :name, :login, :email, absence: true\nend\n\nCopy\n","\nclass LineItem < ApplicationRecord\n  belongs_to :order\n  validates :order, absence: true\nend\n\nclass LineItem < ApplicationRecord\n  belongs_to :order\n  validates :order, absence: true\nend\n\nCopy\n","\nclass Order < ApplicationRecord\n  has_many :line_items, inverse_of: :order\nend\n\nclass Order < ApplicationRecord\n  has_many :line_items, inverse_of: :order\nend\n\nCopy\n"],"body":"This helper validates that the specified attributes are absent. It uses the\npresent? method to check if the value is not either nil or a blank string, that\nis, a string that is either empty or consists of whitespace.If you want to be sure that an association is absent, you'll need to test\nwhether the associated object itself is absent, and not the foreign key used\nto map the association.In order to validate associated records whose absence is required, you must\nspecify the :inverse_of option for the association:If you validate the absence of an object associated via a has_one or\nhas_many relationship, it will check that the object is neither present? nor\nmarked_for_destruction?.Since false.present? is false, if you want to validate the absence of a boolean\nfield you should use validates :field_name, exclusion: { in: [true, false] }.The default error message is \"must be blank\"."},{"title":"2.11 uniqueness","anchor":"#uniqueness","code":["\nclass Account < ApplicationRecord\n  validates :email, uniqueness: true\nend\n\nclass Account < ApplicationRecord\n  validates :email, uniqueness: true\nend\n\nCopy\n","\nclass Holiday < ApplicationRecord\n  validates :name, uniqueness: { scope: :year,\n    message: \"should happen once per year\" }\nend\n\nclass Holiday < ApplicationRecord\n  validates :name, uniqueness: { scope: :year,\n    message: \"should happen once per year\" }\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :name, uniqueness: { case_sensitive: false }\nend\n\nclass Person < ApplicationRecord\n  validates :name, uniqueness: { case_sensitive: false }\nend\n\nCopy\n"],"body":"This helper validates that the attribute's value is unique right before the\nobject gets saved. It does not create a uniqueness constraint in the database,\nso it may happen that two different database connections create two records\nwith the same value for a column that you intend to be unique. To avoid that,\nyou must create a unique index on that column in your database.The validation happens by performing an SQL query into the model's table,\nsearching for an existing record with the same value in that attribute.There is a :scope option that you can use to specify one or more attributes that\nare used to limit the uniqueness check:Should you wish to create a database constraint to prevent possible violations of a uniqueness validation using the :scope option, you must create a unique index on both columns in your database. See the MySQL manual for more details about multiple column indexes or the PostgreSQL manual for examples of unique constraints that refer to a group of columns.There is also a :case_sensitive option that you can use to define whether the\nuniqueness constraint will be case sensitive or not. This option defaults to\ntrue.The default error message is \"has already been taken\"."},{"title":"2.12 validates_with","anchor":"#validates-with","code":["\nclass GoodnessValidator < ActiveModel::Validator\n  def validate(record)\n    if record.first_name == \"Evil\"\n      record.errors.add :base, \"This person is evil\"\n    end\n  end\nend\n\nclass Person < ApplicationRecord\n  validates_with GoodnessValidator\nend\n\nclass GoodnessValidator < ActiveModel::Validator\n  def validate(record)\n    if record.first_name == \"Evil\"\n      record.errors.add :base, \"This person is evil\"\n    end\n  end\nend\n\nclass Person < ApplicationRecord\n  validates_with GoodnessValidator\nend\n\nCopy\n","\nclass GoodnessValidator < ActiveModel::Validator\n  def validate(record)\n    if options[:fields].any? { |field| record.send(field) == \"Evil\" }\n      record.errors.add :base, \"This person is evil\"\n    end\n  end\nend\n\nclass Person < ApplicationRecord\n  validates_with GoodnessValidator, fields: [:first_name, :last_name]\nend\n\nclass GoodnessValidator < ActiveModel::Validator\n  def validate(record)\n    if options[:fields].any? { |field| record.send(field) == \"Evil\" }\n      record.errors.add :base, \"This person is evil\"\n    end\n  end\nend\n\nclass Person < ApplicationRecord\n  validates_with GoodnessValidator, fields: [:first_name, :last_name]\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  validate do |person|\n    GoodnessValidator.new(person).validate\n  end\nend\n\nclass GoodnessValidator\n  def initialize(person)\n    @person = person\n  end\n\n  def validate\n    if some_complex_condition_involving_ivars_and_private_methods?\n      @person.errors.add :base, \"This person is evil\"\n    end\n  end\n\n  # ...\nend\n\nclass Person < ApplicationRecord\n  validate do |person|\n    GoodnessValidator.new(person).validate\n  end\nend\n\nclass GoodnessValidator\n  def initialize(person)\n    @person = person\n  end\n\n  def validate\n    if some_complex_condition_involving_ivars_and_private_methods?\n      @person.errors.add :base, \"This person is evil\"\n    end\n  end\n\n  # ...\nend\n\nCopy\n"],"body":"This helper passes the record to a separate class for validation.The validates_with helper takes a class, or a list of classes to use for\nvalidation. There is no default error message for validates_with. You must\nmanually add errors to the record's errors collection in the validator class.To implement the validate method, you must have a record parameter defined,\nwhich is the record to be validated.Like all other validations, validates_with takes the :if, :unless and\n:on options. If you pass any other options, it will send those options to the\nvalidator class as options:Note that the validator will be initialized only once for the whole application\nlife cycle, and not on each validation run, so be careful about using instance\nvariables inside it.If your validator is complex enough that you want instance variables, you can\neasily use a plain old Ruby object instead:"},{"code":["\nclass Person < ApplicationRecord\n  validates_each :name, :surname do |record, attr, value|\n    record.errors.add(attr, 'must start with upper case') if value =~ /\\A[[:lower:]]/\n  end\nend\n\nclass Person < ApplicationRecord\n  validates_each :name, :surname do |record, attr, value|\n    record.errors.add(attr, 'must start with upper case') if value =~ /\\A[[:lower:]]/\n  end\nend\n\nCopy\n"],"body":"This helper validates attributes against a block. It doesn't have a predefined\nvalidation function. You should create one using a block, and every attribute\npassed to validates_each will be tested against it. In the following example,\nwe don't want names and surnames to begin with lower case.The block receives the record, the attribute's name, and the attribute's value.\nYou can do anything you like to check for valid data within the block. If your\nvalidation fails, you should add an error to the model, therefore\nmaking it invalid.","title":"2.13 validates_each","anchor":"#validates-each"},{"title":"3 Common Validation Options","anchor":"#common-validation-options","code":[],"body":"These are common validation options:"},{"title":"3.1 :allow_nil","anchor":"#allow-nil","code":["\nclass Coffee < ApplicationRecord\n  validates :size, inclusion: { in: %w(small medium large),\n    message: \"%{value} is not a valid size\" }, allow_nil: true\nend\n\nclass Coffee < ApplicationRecord\n  validates :size, inclusion: { in: %w(small medium large),\n    message: \"%{value} is not a valid size\" }, allow_nil: true\nend\n\nCopy\n"],"body":"The :allow_nil option skips the validation when the value being validated is\nnil.For full options to the message argument please see the\nmessage documentation."},{"title":"3.2 :allow_blank","anchor":"#allow-blank","code":["\nclass Topic < ApplicationRecord\n  validates :title, length: { is: 5 }, allow_blank: true\nend\n\nclass Topic < ApplicationRecord\n  validates :title, length: { is: 5 }, allow_blank: true\nend\n\nCopy\n","\nirb> Topic.create(title: \"\").valid?\n=> true\nirb> Topic.create(title: nil).valid?\n=> true\n\nTopic.create(title: \"\").valid?\nTopic.create(title: nil).valid?\n\nCopy\n"],"body":"The :allow_blank option is similar to the :allow_nil option. This option\nwill let validation pass if the attribute's value is blank?, like nil or an\nempty string for example."},{"code":["\nclass Person < ApplicationRecord\n  # Hard-coded message\n  validates :name, presence: { message: \"must be given please\" }\n\n  # Message with dynamic attribute value. %{value} will be replaced\n  # with the actual value of the attribute. %{attribute} and %{model}\n  # are also available.\n  validates :age, numericality: { message: \"%{value} seems wrong\" }\n\n  # Proc\n  validates :username,\n    uniqueness: {\n      # object = person object being validated\n      # data = { model: \"Person\", attribute: \"Username\", value: <username> }\n      message: ->(object, data) do\n        \"Hey #{object.name}, #{data[:value]} is already taken.\"\n      end\n    }\nend\n\nclass Person < ApplicationRecord\n  # Hard-coded message\n  validates :name, presence: { message: \"must be given please\" }\n\n  # Message with dynamic attribute value. %{value} will be replaced\n  # with the actual value of the attribute. %{attribute} and %{model}\n  # are also available.\n  validates :age, numericality: { message: \"%{value} seems wrong\" }\n\n  # Proc\n  validates :username,\n    uniqueness: {\n      # object = person object being validated\n      # data = { model: \"Person\", attribute: \"Username\", value: <username> }\n      message: ->(object, data) do\n        \"Hey #{object.name}, #{data[:value]} is already taken.\"\n      end\n    }\nend\n\nCopy\n"],"body":"As you've already seen, the :message option lets you specify the message that\nwill be added to the errors collection when validation fails. When this\noption is not used, Active Record will use the respective default error message\nfor each validation helper. The :message option accepts a String or Proc.A String :message value can optionally contain any/all of %{value},\n%{attribute}, and %{model} which will be dynamically replaced when\nvalidation fails. This replacement is done using the I18n gem, and the\nplaceholders must match exactly, no spaces are allowed.A Proc :message value is given two arguments: the object being validated, and\na hash with :model, :attribute, and :value key-value pairs.","title":"3.3 :message","anchor":"#message"},{"code":["\nclass Person < ApplicationRecord\n  # it will be possible to update email with a duplicated value\n  validates :email, uniqueness: true, on: :create\n\n  # it will be possible to create the record with a non-numerical age\n  validates :age, numericality: true, on: :update\n\n  # the default (validates on both create and update)\n  validates :name, presence: true\nend\n\nclass Person < ApplicationRecord\n  # it will be possible to update email with a duplicated value\n  validates :email, uniqueness: true, on: :create\n\n  # it will be possible to create the record with a non-numerical age\n  validates :age, numericality: true, on: :update\n\n  # the default (validates on both create and update)\n  validates :name, presence: true\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :email, uniqueness: true, on: :account_setup\n  validates :age, numericality: true, on: :account_setup\nend\n\nclass Person < ApplicationRecord\n  validates :email, uniqueness: true, on: :account_setup\n  validates :age, numericality: true, on: :account_setup\nend\n\nCopy\n","\nirb> person = Person.new(age: 'thirty-three')\nirb> person.valid?\n=> true\nirb> person.valid?(:account_setup)\n=> false\nirb> person.errors.messages\n=> {:email=>[\"has already been taken\"], :age=>[\"is not a number\"]}\n\nperson = Person.new(age: 'thirty-three')\nperson.valid?\nperson.valid?(:account_setup)\nperson.errors.messages\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :email, uniqueness: true, on: :account_setup\n  validates :age, numericality: true, on: :account_setup\n  validates :name, presence: true\nend\n\nclass Person < ApplicationRecord\n  validates :email, uniqueness: true, on: :account_setup\n  validates :age, numericality: true, on: :account_setup\n  validates :name, presence: true\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.valid?(:account_setup)\n=> false\nirb> person.errors.messages\n=> {:email=>[\"has already been taken\"], :age=>[\"is not a number\"], :name=>[\"can't be blank\"]}\n\nperson = Person.new\nperson.valid?(:account_setup)\nperson.errors.messages\n\nCopy\n"],"body":"The :on option lets you specify when the validation should happen. The\ndefault behavior for all the built-in validation helpers is to be run on save\n(both when you're creating a new record and when you're updating it). If you\nwant to change it, you can use on: :create to run the validation only when a\nnew record is created or on: :update to run the validation only when a record\nis updated.You can also use on: to define custom contexts. Custom contexts need to be\ntriggered explicitly by passing the name of the context to valid?,\ninvalid?, or save.person.valid?(:account_setup) executes both the validations without saving\nthe model. person.save(context: :account_setup) validates person in the\naccount_setup context before saving.When triggered by an explicit context, validations are run for that context,\nas well as any validations without a context.","title":"3.4 :on","anchor":"#on"},{"code":["\nclass Person < ApplicationRecord\n  validates :name, presence: { strict: true }\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: { strict: true }\nend\n\nCopy\n","\nirb> Person.new.valid?\nActiveModel::StrictValidationFailed: Name can't be blank\n\nPerson.new.valid?\n\nCopy\n","\nclass Person < ApplicationRecord\n  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException\nend\n\nclass Person < ApplicationRecord\n  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException\nend\n\nCopy\n","\nirb> Person.new.valid?\nTokenGenerationException: Token can't be blank\n\nPerson.new.valid?\n\nCopy\n"],"body":"You can also specify validations to be strict and raise\nActiveModel::StrictValidationFailed when the object is invalid.There is also the ability to pass a custom exception to the :strict option.","title":"4 Strict Validations","anchor":"#strict-validations"},{"code":[],"body":"Sometimes it will make sense to validate an object only when a given predicate\nis satisfied. You can do that by using the :if and :unless options, which\ncan take a symbol, a Proc or an Array. You may use the :if\noption when you want to specify when the validation should happen. If you\nwant to specify when the validation should not happen, then you may use the\n:unless option.","title":"5 Conditional Validation","anchor":"#conditional-validation"},{"title":"5.1 Using a Symbol with :if and :unless","anchor":"#using-a-symbol-with-if-and-unless","code":["\nclass Order < ApplicationRecord\n  validates :card_number, presence: true, if: :paid_with_card?\n\n  def paid_with_card?\n    payment_type == \"card\"\n  end\nend\n\nclass Order < ApplicationRecord\n  validates :card_number, presence: true, if: :paid_with_card?\n\n  def paid_with_card?\n    payment_type == \"card\"\n  end\nend\n\nCopy\n"],"body":"You can associate the :if and :unless options with a symbol corresponding\nto the name of a method that will get called right before validation happens.\nThis is the most commonly used option."},{"code":["\nclass Account < ApplicationRecord\n  validates :password, confirmation: true,\n    unless: Proc.new { |a| a.password.blank? }\nend\n\nclass Account < ApplicationRecord\n  validates :password, confirmation: true,\n    unless: Proc.new { |a| a.password.blank? }\nend\n\nCopy\n","\nvalidates :password, confirmation: true, unless: -> { password.blank? }\n\nvalidates :password, confirmation: true, unless: -> { password.blank? }\n\nCopy\n"],"body":"It is possible to associate :if and :unless with a Proc object\nwhich will be called. Using a Proc object gives you the ability to write an\ninline condition instead of a separate method. This option is best suited for\none-liners.As Lambdas are a type of Proc, they can also be used to write inline\nconditions in a shorter way.","title":"5.2 Using a Proc with :if and :unless","anchor":"#using-a-proc-with-if-and-unless"},{"code":["\nclass User < ApplicationRecord\n  with_options if: :is_admin? do |admin|\n    admin.validates :password, length: { minimum: 10 }\n    admin.validates :email, presence: true\n  end\nend\n\nclass User < ApplicationRecord\n  with_options if: :is_admin? do |admin|\n    admin.validates :password, length: { minimum: 10 }\n    admin.validates :email, presence: true\n  end\nend\n\nCopy\n"],"body":"Sometimes it is useful to have multiple validations use one condition. It can\nbe easily achieved using with_options.All validations inside of the with_options block will have automatically\npassed the condition if: :is_admin?","title":"5.3 Grouping Conditional validations","anchor":"#grouping-conditional-validations"},{"title":"5.4 Combining Validation Conditions","anchor":"#combining-validation-conditions","code":["\nclass Computer < ApplicationRecord\n  validates :mouse, presence: true,\n                    if: [Proc.new { |c| c.market.retail? }, :desktop?],\n                    unless: Proc.new { |c| c.trackpad.present? }\nend\n\nclass Computer < ApplicationRecord\n  validates :mouse, presence: true,\n                    if: [Proc.new { |c| c.market.retail? }, :desktop?],\n                    unless: Proc.new { |c| c.trackpad.present? }\nend\n\nCopy\n"],"body":"On the other hand, when multiple conditions define whether or not a validation\nshould happen, an Array can be used. Moreover, you can apply both :if and\n:unless to the same validation.The validation only runs when all the :if conditions and none of the\n:unless conditions are evaluated to true."},{"title":"6 Performing Custom Validations","anchor":"#performing-custom-validations","code":[],"body":"When the built-in validation helpers are not enough for your needs, you can\nwrite your own validators or validation methods as you prefer."},{"title":"6.1 Custom Validators","anchor":"#custom-validators","code":["\nclass MyValidator < ActiveModel::Validator\n  def validate(record)\n    unless record.name.start_with? 'X'\n      record.errors.add :name, \"Need a name starting with X please!\"\n    end\n  end\nend\n\nclass Person\n  include ActiveModel::Validations\n  validates_with MyValidator\nend\n\nclass MyValidator < ActiveModel::Validator\n  def validate(record)\n    unless record.name.start_with? 'X'\n      record.errors.add :name, \"Need a name starting with X please!\"\n    end\n  end\nend\n\nclass Person\n  include ActiveModel::Validations\n  validates_with MyValidator\nend\n\nCopy\n","\nclass EmailValidator < ActiveModel::EachValidator\n  def validate_each(record, attribute, value)\n    unless value =~ /\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/i\n      record.errors.add attribute, (options[:message] || \"is not an email\")\n    end\n  end\nend\n\nclass Person < ApplicationRecord\n  validates :email, presence: true, email: true\nend\n\nclass EmailValidator < ActiveModel::EachValidator\n  def validate_each(record, attribute, value)\n    unless value =~ /\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/i\n      record.errors.add attribute, (options[:message] || \"is not an email\")\n    end\n  end\nend\n\nclass Person < ApplicationRecord\n  validates :email, presence: true, email: true\nend\n\nCopy\n"],"body":"Custom validators are classes that inherit from ActiveModel::Validator. These\nclasses must implement the validate method which takes a record as an argument\nand performs the validation on it. The custom validator is called using the\nvalidates_with method.The easiest way to add custom validators for validating individual attributes\nis with the convenient ActiveModel::EachValidator. In this case, the custom\nvalidator class must implement a validate_each method which takes three\narguments: record, attribute, and value. These correspond to the instance, the\nattribute to be validated, and the value of the attribute in the passed\ninstance.As shown in the example, you can also combine standard validations with your\nown custom validators."},{"title":"6.2 Custom Methods","anchor":"#custom-methods","code":["\nclass Invoice < ApplicationRecord\n  validate :expiration_date_cannot_be_in_the_past,\n    :discount_cannot_be_greater_than_total_value\n\n  def expiration_date_cannot_be_in_the_past\n    if expiration_date.present? && expiration_date < Date.today\n      errors.add(:expiration_date, \"can't be in the past\")\n    end\n  end\n\n  def discount_cannot_be_greater_than_total_value\n    if discount > total_value\n      errors.add(:discount, \"can't be greater than total value\")\n    end\n  end\nend\n\nclass Invoice < ApplicationRecord\n  validate :expiration_date_cannot_be_in_the_past,\n    :discount_cannot_be_greater_than_total_value\n\n  def expiration_date_cannot_be_in_the_past\n    if expiration_date.present? && expiration_date < Date.today\n      errors.add(:expiration_date, \"can't be in the past\")\n    end\n  end\n\n  def discount_cannot_be_greater_than_total_value\n    if discount > total_value\n      errors.add(:discount, \"can't be greater than total value\")\n    end\n  end\nend\n\nCopy\n","\nclass Invoice < ApplicationRecord\n  validate :active_customer, on: :create\n\n  def active_customer\n    errors.add(:customer_id, \"is not active\") unless customer.active?\n  end\nend\n\nclass Invoice < ApplicationRecord\n  validate :active_customer, on: :create\n\n  def active_customer\n    errors.add(:customer_id, \"is not active\") unless customer.active?\n  end\nend\n\nCopy\n"],"body":"You can also create methods that verify the state of your models and add\nerrors to the errors collection when they are invalid. You must then\nregister these methods by using the validate\nclass method, passing in the symbols for the validation methods' names.You can pass more than one symbol for each class method and the respective\nvalidations will be run in the same order as they were registered.The valid? method will verify that the errors collection is empty,\nso your custom validation methods should add errors to it when you\nwish validation to fail:By default, such validations will run every time you call valid?\nor save the object. But it is also possible to control when to run these\ncustom validations by giving an :on option to the validate method,\nwith either: :create or :update."},{"code":[],"body":"The valid? and invalid? methods only provide a summary status on validity. However you can dig deeper into each individual error by using various methods from the errors collection.The following is a list of the most commonly used methods. Please refer to the ActiveModel::Errors documentation for a list of all the available methods.","title":"7 Working with Validation Errors","anchor":"#working-with-validation-errors"},{"title":"7.1 errors","anchor":"#working-with-validation-errors-errors","code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.valid?\n=> false\nirb> person.errors.full_messages\n=> [\"Name can't be blank\", \"Name is too short (minimum is 3 characters)\"]\n\nirb> person = Person.new(name: \"John Doe\")\nirb> person.valid?\n=> true\nirb> person.errors.full_messages\n=> []\n\nperson = Person.new\nperson.valid?\nperson.errors.full_messages\nperson = Person.new(name: \"John Doe\")\nperson.valid?\nperson.errors.full_messages\n\nCopy\n"],"body":"The gateway through which you can drill down into various details of each error.This returns an instance of the class ActiveModel::Errors containing all errors,\neach error is represented by an ActiveModel::Error object."},{"code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nCopy\n","\nirb> person = Person.new(name: \"John Doe\")\nirb> person.valid?\n=> true\nirb> person.errors[:name]\n=> []\n\nirb> person = Person.new(name: \"JD\")\nirb> person.valid?\n=> false\nirb> person.errors[:name]\n=> [\"is too short (minimum is 3 characters)\"]\n\nirb> person = Person.new\nirb> person.valid?\n=> false\nirb> person.errors[:name]\n=> [\"can't be blank\", \"is too short (minimum is 3 characters)\"]\n\nperson = Person.new(name: \"John Doe\")\nperson.valid?\nperson.errors[:name]\nperson = Person.new(name: \"JD\")\nperson.valid?\nperson.errors[:name]\nperson = Person.new\nperson.valid?\nperson.errors[:name]\n\nCopy\n"],"body":"errors[] is used when you want to check the error messages for a specific attribute. It returns an array of strings with all error messages for the given attribute, each string with one error message. If there are no errors related to the attribute, it returns an empty array.","title":"7.2 errors[]","anchor":"#errors"},{"code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.valid?\n=> false\n\nirb> person.errors.where(:name)\n=> [ ... ] # all errors for :name attribute\n\nirb> person.errors.where(:name, :too_short)\n=> [ ... ] # :too_short errors for :name attribute\n\nperson = Person.new\nperson.valid?\nperson.errors.where(:name)\nperson.errors.where(:name, :too_short)\n\nCopy\n","\nirb> error = person.errors.where(:name).last\n\nirb> error.attribute\n=> :name\nirb> error.type\n=> :too_short\nirb> error.options[:count]\n=> 3\n\nerror = person.errors.where(:name).last\nerror.attribute\nerror.type\nerror.options[:count]\n\nCopy\n","\nirb> error.message\n=> \"is too short (minimum is 3 characters)\"\nirb> error.full_message\n=> \"Name is too short (minimum is 3 characters)\"\n\nerror.message\nerror.full_message\n\nCopy\n"],"body":"Sometimes we may need more information about each error beside its message. Each error is encapsulated as an ActiveModel::Error object, and where method is the most common way of access.where returns an array of error objects, filtered by various degree of conditions.You can read various information from these error objects:You can also generate the error message:The full_message method generates a more user-friendly message, with the capitalized attribute name prepended.","title":"7.3 errors.where and error object","anchor":"#errors-where-and-error-object"},{"title":"7.4 errors.add","anchor":"#errors-add","code":["\nclass Person < ApplicationRecord\n  validate do |person|\n    errors.add :name, :too_plain, message: \"is not cool enough\"\n  end\nend\n\nclass Person < ApplicationRecord\n  validate do |person|\n    errors.add :name, :too_plain, message: \"is not cool enough\"\n  end\nend\n\nCopy\n","\nirb> person = Person.create\nirb> person.errors.where(:name).first.type\n=> :too_plain\nirb> person.errors.where(:name).first.full_message\n=> \"Name is not cool enough\"\n\nperson = Person.create\nperson.errors.where(:name).first.type\nperson.errors.where(:name).first.full_message\n\nCopy\n"],"body":"The add method creates the error object by taking the attribute, the error type and additional options hash. This is useful for writing your own validator."},{"code":["\nclass Person < ApplicationRecord\n  validate do |person|\n    errors.add :base, :invalid, message: \"This person is invalid because ...\"\n  end\nend\n\nclass Person < ApplicationRecord\n  validate do |person|\n    errors.add :base, :invalid, message: \"This person is invalid because ...\"\n  end\nend\n\nCopy\n","\nirb> person = Person.create\nirb> person.errors.where(:base).first.full_message\n=> \"This person is invalid because ...\"\n\nperson = Person.create\nperson.errors.where(:base).first.full_message\n\nCopy\n"],"body":"You can add errors that are related to the object's state as a whole, instead of being related to a specific attribute. You can add errors to :base when you want to say that the object is invalid, no matter the values of its attributes.","title":"7.5 errors[:base]","anchor":"#errors-base"},{"code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.valid?\n=> false\nirb> person.errors.empty?\n=> false\n\nirb> person.errors.clear\nirb> person.errors.empty?\n=> true\n\nirb> person.save\n=> false\n\nirb> person.errors.empty?\n=> false\n\nperson = Person.new\nperson.valid?\nperson.errors.empty?\nperson.errors.clear\nperson.errors.empty?\nperson.save\nperson.errors.empty?\n\nCopy\n"],"body":"The clear method is used when you intentionally want to clear the errors collection. Of course, calling errors.clear upon an invalid object won't actually make it valid: the errors collection will now be empty, but the next time you call valid? or any method that tries to save this object to the database, the validations will run again. If any of the validations fail, the errors collection will be filled again.","title":"7.6 errors.clear","anchor":"#errors-clear"},{"code":["\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nclass Person < ApplicationRecord\n  validates :name, presence: true, length: { minimum: 3 }\nend\n\nCopy\n","\nirb> person = Person.new\nirb> person.valid?\n=> false\nirb> person.errors.size\n=> 2\n\nirb> person = Person.new(name: \"Andrea\", email: \"andrea@example.com\")\nirb> person.valid?\n=> true\nirb> person.errors.size\n=> 0\n\nperson = Person.new\nperson.valid?\nperson.errors.size\nperson = Person.new(name: \"Andrea\", email: \"andrea@example.com\")\nperson.valid?\nperson.errors.size\n\nCopy\n"],"body":"The size method returns the total number of errors for the object.","title":"7.7 errors.size","anchor":"#errors-size"},{"code":["\n<% if @article.errors.any? %>\n  <div id=\"error_explanation\">\n    <h2><%= pluralize(@article.errors.count, \"error\") %> prohibited this article from being saved:</h2>\n\n    <ul>\n      <% @article.errors.each do |error| %>\n        <li><%= error.full_message %></li>\n      <% end %>\n    </ul>\n  </div>\n<% end %>\n\n<% if @article.errors.any? %>\n  <div id=\"error_explanation\">\n    <h2><%= pluralize(@article.errors.count, \"error\") %> prohibited this article from being saved:</h2>\n\n    <ul>\n      <% @article.errors.each do |error| %>\n        <li><%= error.full_message %></li>\n      <% end %>\n    </ul>\n  </div>\n<% end %>\n\nCopy\n","\n<div class=\"field_with_errors\">\n  <input id=\"article_title\" name=\"article[title]\" size=\"30\" type=\"text\" value=\"\">\n</div>\n\n<div class=\"field_with_errors\">\n  <input id=\"article_title\" name=\"article[title]\" size=\"30\" type=\"text\" value=\"\">\n</div>\n\nCopy\n","\n.field_with_errors {\n  padding: 2px;\n  background-color: red;\n  display: table;\n}\n\n.field_with_errors {\n  padding: 2px;\n  background-color: red;\n  display: table;\n}\n\nCopy\n"],"body":"Once you've created a model and added validations, if that model is created via\na web form, you probably want to display an error message when one of the\nvalidations fail.Because every application handles this kind of thing differently, Rails does\nnot include any view helpers to help you generate these messages directly.\nHowever, due to the rich number of methods Rails gives you to interact with\nvalidations in general, you can build your own. In addition, when\ngenerating a scaffold, Rails will put some ERB into the _form.html.erb that\nit generates that displays the full list of errors on that model.Assuming we have a model that's been saved in an instance variable named\n@article, it looks like this:Furthermore, if you use the Rails form helpers to generate your forms, when\na validation error occurs on a field, it will generate an extra <div> around\nthe entry.You can then style this div however you'd like. The default scaffold that\nRails generates, for example, adds this CSS rule:This means that any field with an error ends up with a 2 pixel red border.","title":"8 Displaying Validation Errors in Views","anchor":"#displaying-validation-errors-in-views"}]