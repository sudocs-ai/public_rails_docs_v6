[{"code":[],"body":"In Rails, web requests are handled by Action Controller and Action View. Typically, Action Controller is concerned with communicating with the database and performing CRUD actions where necessary. Action View is then responsible for compiling the response.Action View templates are written using embedded Ruby in tags mingled with HTML. To avoid cluttering the templates with boilerplate code, a number of helper classes provide common behavior for forms, dates, and strings. It's also easy to add new helpers to your application as it evolves.","title":"1 What is Action View?","anchor":"#what-is-action-view-questionmark"},{"title":"2 Using Action View with Rails","anchor":"#using-action-view-with-rails","code":["\n$ bin/rails generate scaffold article\n      [...]\n      invoke  scaffold_controller\n      create    app/controllers/articles_controller.rb\n      invoke    erb\n      create      app/views/articles\n      create      app/views/articles/index.html.erb\n      create      app/views/articles/edit.html.erb\n      create      app/views/articles/show.html.erb\n      create      app/views/articles/new.html.erb\n      create      app/views/articles/_form.html.erb\n      [...]\n\nbin/rails generate scaffold article\n\nCopy\n"],"body":"For each controller there is an associated directory in the app/views directory which holds the template files that make up the views associated with that controller. These files are used to display the view that results from each controller action.Let's take a look at what Rails does by default when creating a new resource using the scaffold generator:There is a naming convention for views in Rails. Typically, the views share their name with the associated controller action, as you can see above.\nFor example, the index controller action of the articles_controller.rb will use the index.html.erb view file in the app/views/articles directory.\nThe complete HTML returned to the client is composed of a combination of this ERB file, a layout template that wraps it, and all the partials that the view may reference. Within this guide you will find more detailed documentation about each of these three components."},{"title":"3 Templates, Partials, and Layouts","anchor":"#templates-partials-and-layouts","code":[],"body":"As mentioned, the final HTML output is a composition of three Rails elements: Templates, Partials and Layouts.\nBelow is a brief overview of each of them."},{"title":"3.1 Templates","anchor":"#templates","code":[],"body":"Action View templates can be written in several ways. If the template file has a .erb extension then it uses a mixture of ERB (Embedded Ruby) and HTML. If the template file has a .builder extension then the Builder::XmlMarkup library is used.Rails supports multiple template systems and uses a file extension to distinguish amongst them. For example, an HTML file using the ERB template system will have .html.erb as a file extension."},{"title":"3.1.1 ERB","anchor":"#erb","code":["\n<h1>Names of all the people</h1>\n<% @people.each do |person| %>\n  Name: <%= person.name %><br>\n<% end %>\n\n<h1>Names of all the people</h1>\n<% @people.each do |person| %>\n  Name: <%= person.name %><br>\n<% end %>\n\nCopy\n","\n<%# WRONG %>\nHi, Mr. <% puts \"Frodo\" %>\n\n<%# WRONG %>\nHi, Mr. <% puts \"Frodo\" %>\n\nCopy\n"],"body":"Within an ERB template, Ruby code can be included using both <% %> and <%= %> tags. The <% %> tags are used to execute Ruby code that does not return anything, such as conditions, loops, or blocks, and the <%= %> tags are used when you want output.Consider the following loop for names:The loop is set up using regular embedding tags (<% %>) and the name is inserted using the output embedding tags (<%= %>). Note that this is not just a usage suggestion: regular output functions such as print and puts won't be rendered to the view with ERB templates. So this would be wrong:To suppress leading and trailing whitespaces, you can use <%- -%> interchangeably with <% and %>."},{"title":"3.1.2 Builder","anchor":"#builder","code":["\nxml.em(\"emphasized\")\nxml.em { xml.b(\"emph & bold\") }\nxml.a(\"A Link\", \"href\" => \"https://rubyonrails.org\")\nxml.target(\"name\" => \"compile\", \"option\" => \"fast\")\n\nxml.em(\"emphasized\")\nxml.em { xml.b(\"emph & bold\") }\nxml.a(\"A Link\", \"href\" => \"https://rubyonrails.org\")\nxml.target(\"name\" => \"compile\", \"option\" => \"fast\")\n\nCopy\n","\n<em>emphasized</em>\n<em><b>emph &amp; bold</b></em>\n<a href=\"https://rubyonrails.org\">A link</a>\n<target option=\"fast\" name=\"compile\" />\n\n<em>emphasized</em>\n<em><b>emph &amp; bold</b></em>\n<a href=\"https://rubyonrails.org\">A link</a>\n<target option=\"fast\" name=\"compile\" />\n\nCopy\n","\nxml.div {\n  xml.h1(@person.name)\n  xml.p(@person.bio)\n}\n\nxml.div {\n  xml.h1(@person.name)\n  xml.p(@person.bio)\n}\n\nCopy\n","\n<div>\n  <h1>David Heinemeier Hansson</h1>\n  <p>A product of Danish Design during the Winter of '79...</p>\n</div>\n\n<div>\n  <h1>David Heinemeier Hansson</h1>\n  <p>A product of Danish Design during the Winter of '79...</p>\n</div>\n\nCopy\n","\nxml.rss(\"version\" => \"2.0\", \"xmlns:dc\" => \"http://purl.org/dc/elements/1.1/\") do\n  xml.channel do\n    xml.title(@feed_title)\n    xml.link(@url)\n    xml.description \"Basecamp: Recent items\"\n    xml.language \"en-us\"\n    xml.ttl \"40\"\n\n    for item in @recent_items\n      xml.item do\n        xml.title(item_title(item))\n        xml.description(item_description(item)) if item_description(item)\n        xml.pubDate(item_pubDate(item))\n        xml.guid(@person.firm.account.url + @recent_items.url(item))\n        xml.link(@person.firm.account.url + @recent_items.url(item))\n        xml.tag!(\"dc:creator\", item.author_name) if item_has_creator?(item)\n      end\n    end\n  end\nend\n\nxml.rss(\"version\" => \"2.0\", \"xmlns:dc\" => \"http://purl.org/dc/elements/1.1/\") do\n  xml.channel do\n    xml.title(@feed_title)\n    xml.link(@url)\n    xml.description \"Basecamp: Recent items\"\n    xml.language \"en-us\"\n    xml.ttl \"40\"\n\n    for item in @recent_items\n      xml.item do\n        xml.title(item_title(item))\n        xml.description(item_description(item)) if item_description(item)\n        xml.pubDate(item_pubDate(item))\n        xml.guid(@person.firm.account.url + @recent_items.url(item))\n        xml.link(@person.firm.account.url + @recent_items.url(item))\n        xml.tag!(\"dc:creator\", item.author_name) if item_has_creator?(item)\n      end\n    end\n  end\nend\n\nCopy\n"],"body":"Builder templates are a more programmatic alternative to ERB. They are especially useful for generating XML content. An XmlMarkup object named xml is automatically made available to templates with a .builder extension.Here are some basic examples:which would produce:Any method with a block will be treated as an XML markup tag with nested markup in the block. For example, the following:would produce something like:Below is a full-length RSS example actually used on Basecamp:"},{"code":["\ngem 'jbuilder'\n\ngem 'jbuilder'\n\nCopy\n","\njson.name(\"Alex\")\njson.email(\"alex@example.com\")\n\njson.name(\"Alex\")\njson.email(\"alex@example.com\")\n\nCopy\n","\n{\n  \"name\": \"Alex\",\n  \"email\": \"alex@example.com\"\n}\n\n{\n  \"name\": \"Alex\",\n  \"email\": \"alex@example.com\"\n}\n\nCopy\n"],"body":"Jbuilder is a gem that's\nmaintained by the Rails team and included in the default Rails Gemfile.\nIt's similar to Builder, but is used to generate JSON, instead of XML.If you don't have it, you can add the following to your Gemfile:A Jbuilder object named json is automatically made available to templates with\na .jbuilder extension.Here is a basic example:would produce:See the Jbuilder documentation for\nmore examples and information.","title":"3.1.3 Jbuilder","anchor":"#jbuilder"},{"title":"3.1.4 Template Caching","anchor":"#template-caching","code":[],"body":"By default, Rails will compile each template to a method in order to render it. In the development environment, when you alter a template, Rails will check the file's modification time and recompile it."},{"title":"3.2 Partials","anchor":"#partials","code":[],"body":"Partial templates - usually just called \"partials\" - are another device for breaking the rendering process into more manageable chunks. With partials, you can extract pieces of code from your templates to separate files and also reuse them throughout your templates."},{"title":"3.2.1 Naming Partials","anchor":"#naming-partials","code":["\n<%= render \"menu\" %>\n\n<%= render \"menu\" %>\n\nCopy\n","\n<%= render \"shared/menu\" %>\n\n<%= render \"shared/menu\" %>\n\nCopy\n"],"body":"To render a partial as part of a view, you use the render method within the view:This will render a file named _menu.html.erb at that point within the view that is being rendered. Note the leading underscore character: partials are named with a leading underscore to distinguish them from regular views, even though they are referred to without the underscore. This holds true even when you're pulling in a partial from another folder:That code will pull in the partial from app/views/shared/_menu.html.erb."},{"title":"3.2.2 Using Partials to simplify Views","anchor":"#using-partials-to-simplify-views","code":["\n<%= render \"shared/ad_banner\" %>\n\n<h1>Products</h1>\n\n<p>Here are a few of our fine products:</p>\n<% @products.each do |product| %>\n  <%= render partial: \"product\", locals: { product: product } %>\n<% end %>\n\n<%= render \"shared/footer\" %>\n\n<%= render \"shared/ad_banner\" %>\n\n<h1>Products</h1>\n\n<p>Here are a few of our fine products:</p>\n<% @products.each do |product| %>\n  <%= render partial: \"product\", locals: { product: product } %>\n<% end %>\n\n<%= render \"shared/footer\" %>\n\nCopy\n"],"body":"One way to use partials is to treat them as the equivalent of subroutines; a way to move details out of a view so that you can grasp what's going on more easily. For example, you might have a view that looks like this:Here, the _ad_banner.html.erb and _footer.html.erb partials could contain content that is shared among many pages in your application. You don't need to see the details of these sections when you're concentrating on a particular page."},{"title":"3.2.3 render without partial and locals options","anchor":"#render-without-partial-and-locals-options","code":["\n<%= render partial: \"product\", locals: { product: @product } %>\n\n<%= render partial: \"product\", locals: { product: @product } %>\n\nCopy\n","\n<%= render \"product\", product: @product %>\n\n<%= render \"product\", product: @product %>\n\nCopy\n"],"body":"In the above example, render takes 2 options: partial and locals. But if\nthese are the only options you want to pass, you can skip using these options.\nFor example, instead of:You can also do:"},{"code":["\n<%= render partial: \"product\" %>\n\n<%= render partial: \"product\" %>\n\nCopy\n","\n<%= render partial: \"product\", locals: { product: @product } %>\n\n<%= render partial: \"product\", locals: { product: @product } %>\n\nCopy\n","\n<%= render partial: \"product\", locals: { product: @item } %>\n\n<%= render partial: \"product\", locals: { product: @item } %>\n\nCopy\n","\n<%= render partial: \"product\", object: @item %>\n\n<%= render partial: \"product\", object: @item %>\n\nCopy\n","\n<%= render partial: \"product\", object: @item, as: \"item\" %>\n\n<%= render partial: \"product\", object: @item, as: \"item\" %>\n\nCopy\n","\n<%= render partial: \"product\", locals: { item: @item } %>\n\n<%= render partial: \"product\", locals: { item: @item } %>\n\nCopy\n"],"body":"By default ActionView::Partials::PartialRenderer has its object in a local variable with the same name as the template. So, given:within _product partial we'll get @product in the local variable product,\nas if we had written:The object option can be used to directly specify which object is rendered into the partial; useful when the template's object is elsewhere (e.g. in a different instance variable or in a local variable).For example, instead of:we would do:With the as option we can specify a different name for the said local variable. For example, if we wanted it to be item instead of product we would do:This is equivalent to","title":"3.2.4 The as and object options","anchor":"#the-as-and-object-options"},{"code":["\n<% @products.each do |product| %>\n  <%= render partial: \"product\", locals: { product: product } %>\n<% end %>\n\n<% @products.each do |product| %>\n  <%= render partial: \"product\", locals: { product: product } %>\n<% end %>\n\nCopy\n","\n<%= render partial: \"product\", collection: @products %>\n\n<%= render partial: \"product\", collection: @products %>\n\nCopy\n","\n<%= render @products %>\n\n<%= render @products %>\n\nCopy\n"],"body":"It is very common that a template will need to iterate over a collection and render a sub-template for each of the elements. This pattern has been implemented as a single method that accepts an array and renders a partial for each one of the elements in the array.So this example for rendering all the products:can be rewritten in a single line:When a partial is called with a collection, the individual instances of the partial have access to the member of the collection being rendered via a variable named after the partial. In this case, the partial is _product, and within it you can refer to product to get the collection member that is being rendered.You can use a shorthand syntax for rendering collections. Assuming @products is a collection of Product instances, you can simply write the following to produce the same result:Rails determines the name of the partial to use by looking at the model name in the collection, Product in this case. In fact, you can even render a collection made up of instances of different models using this shorthand, and Rails will choose the proper partial for each member of the collection.","title":"3.2.5 Rendering Collections","anchor":"#rendering-collections"},{"title":"3.2.6 Spacer Templates","anchor":"#spacer-templates","code":["\n<%= render partial: @products, spacer_template: \"product_ruler\" %>\n\n<%= render partial: @products, spacer_template: \"product_ruler\" %>\n\nCopy\n"],"body":"You can also specify a second partial to be rendered between instances of the main partial by using the :spacer_template option:Rails will render the _product_ruler partial (with no data passed to it) between each pair of _product partials."},{"title":"3.3 Layouts","anchor":"#layouts","code":[],"body":"Layouts can be used to render a common view template around the results of Rails controller actions. Typically, a Rails application will have a couple of layouts that pages will be rendered within. For example, a site might have one layout for a logged in user and another for the marketing or sales side of the site. The logged in user layout might include top-level navigation that should be present across many controller actions. The sales layout for a SaaS app might include top-level navigation for things like \"Pricing\" and \"Contact Us\" pages. You would expect each layout to have a different look and feel. You can read about layouts in more detail in the Layouts and Rendering in Rails guide."},{"title":"4 Partial Layouts","anchor":"#partial-layouts","code":["\nArticle.create(body: 'Partial Layouts are cool!')\n\nArticle.create(body: 'Partial Layouts are cool!')\n\nCopy\n","\n<%= render partial: 'article', layout: 'box', locals: { article: @article } %>\n\n<%= render partial: 'article', layout: 'box', locals: { article: @article } %>\n\nCopy\n","\n<div class='box'>\n  <%= yield %>\n</div>\n\n<div class='box'>\n  <%= yield %>\n</div>\n\nCopy\n","\n<% render(layout: 'box', locals: { article: @article }) do %>\n  <div>\n    <p><%= article.body %></p>\n  </div>\n<% end %>\n\n<% render(layout: 'box', locals: { article: @article }) do %>\n  <div>\n    <p><%= article.body %></p>\n  </div>\n<% end %>\n\nCopy\n"],"body":"Partials can have their own layouts applied to them. These layouts are different from those applied to a controller action, but they work in a similar fashion.Let's say we're displaying an article on a page which should be wrapped in a div for display purposes. Firstly, we'll create a new Article:In the show template, we'll render the _article partial wrapped in the box layout:articles/show.html.erbThe box layout simply wraps the _article partial in a div:articles/_box.html.erbNote that the partial layout has access to the local article variable that was passed into the render call. However, unlike application-wide layouts, partial layouts still have the underscore prefix.You can also render a block of code within a partial layout instead of calling yield. For example, if we didn't have the _article partial, we could do this instead:articles/show.html.erbSupposing we use the same _box partial from above, this would produce the same output as the previous example."},{"title":"5 View Paths","anchor":"#view-paths","code":[],"body":"When rendering a response, the controller needs to resolve where the different\nviews are located. By default it only looks inside the app/views directory.We can add other locations and give them a certain precedence when resolving\npaths using the prepend_view_path and append_view_path methods."},{"title":"5.1 Prepend view path","anchor":"#prepend-view-path","code":["\nprepend_view_path \"app/views/#{request.subdomain}\"\n\nprepend_view_path \"app/views/#{request.subdomain}\"\n\nCopy\n"],"body":"This can be helpful for example, when we want to put views inside a different\ndirectory for subdomains.We can do this by using:Then Action View will look first in this directory when resolving views."},{"title":"5.2 Append view path","anchor":"#append-view-path","code":["\nappend_view_path \"app/views/direct\"\n\nappend_view_path \"app/views/direct\"\n\nCopy\n"],"body":"Similarly, we can append paths:This will add app/views/direct to the end of the lookup paths."},{"title":"6 Helpers","anchor":"#helpers","code":[],"body":"Rails provides many helper methods to use with Action View. These include methods for:You can learn more about helpers in the Action View Helpers\nGuide and the Action View Form Helpers\nGuide."},{"title":"7 Localized Views","anchor":"#localized-views","code":["\nbefore_action :set_expert_locale\n\ndef set_expert_locale\n  I18n.locale = :expert if current_user.expert?\nend\n\nbefore_action :set_expert_locale\n\ndef set_expert_locale\n  I18n.locale = :expert if current_user.expert?\nend\n\nCopy\n"],"body":"Action View has the ability to render different templates depending on the current locale.For example, suppose you have an ArticlesController with a show action. By default, calling this action will render app/views/articles/show.html.erb. But if you set I18n.locale = :de, then app/views/articles/show.de.html.erb will be rendered instead. If the localized template isn't present, the undecorated version will be used. This means you're not required to provide localized views for all cases, but they will be preferred and used if available.You can use the same technique to localize the rescue files in your public directory. For example, setting I18n.locale = :de and creating public/500.de.html and public/404.de.html would allow you to have localized rescue pages.Since Rails doesn't restrict the symbols that you use to set I18n.locale, you can leverage this system to display different content depending on anything you like. For example, suppose you have some \"expert\" users that should see different pages from \"normal\" users. You could add the following to app/controllers/application.rb:Then you could create special views like app/views/articles/show.expert.html.erb that would only be displayed to expert users.You can read more about the Rails Internationalization (I18n) API here."}]