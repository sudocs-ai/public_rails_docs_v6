[{"code":["\nproduction:\n  database: my_primary_database\n  username: root\n  password: <%= ENV['ROOT_PASSWORD'] %>\n  adapter: mysql2\n\nproduction:\n  database: my_primary_database\n  username: root\n  password: <%= ENV['ROOT_PASSWORD'] %>\n  adapter: mysql2\n\nCopy\n","\nproduction:\n  primary:\n    database: my_primary_database\n    username: root\n    password: <%= ENV['ROOT_PASSWORD'] %>\n    adapter: mysql2\n  primary_replica:\n    database: my_primary_database\n    username: root_readonly\n    password: <%= ENV['ROOT_READONLY_PASSWORD'] %>\n    adapter: mysql2\n    replica: true\n  animals:\n    database: my_animals_database\n    username: animals_root\n    password: <%= ENV['ANIMALS_ROOT_PASSWORD'] %>\n    adapter: mysql2\n    migrations_paths: db/animals_migrate\n  animals_replica:\n    database: my_animals_database\n    username: animals_readonly\n    password: <%= ENV['ANIMALS_READONLY_PASSWORD'] %>\n    adapter: mysql2\n    replica: true\n\nproduction:\n  primary:\n    database: my_primary_database\n    username: root\n    password: <%= ENV['ROOT_PASSWORD'] %>\n    adapter: mysql2\n  primary_replica:\n    database: my_primary_database\n    username: root_readonly\n    password: <%= ENV['ROOT_READONLY_PASSWORD'] %>\n    adapter: mysql2\n    replica: true\n  animals:\n    database: my_animals_database\n    username: animals_root\n    password: <%= ENV['ANIMALS_ROOT_PASSWORD'] %>\n    adapter: mysql2\n    migrations_paths: db/animals_migrate\n  animals_replica:\n    database: my_animals_database\n    username: animals_readonly\n    password: <%= ENV['ANIMALS_READONLY_PASSWORD'] %>\n    adapter: mysql2\n    replica: true\n\nCopy\n","\nclass AnimalsRecord < ApplicationRecord\n  self.abstract_class = true\n\n  connects_to database: { writing: :animals, reading: :animals_replica }\nend\n\nclass AnimalsRecord < ApplicationRecord\n  self.abstract_class = true\n\n  connects_to database: { writing: :animals, reading: :animals_replica }\nend\n\nCopy\n","\nclass ApplicationRecord < ActiveRecord::Base\n  self.abstract_class = true\n\n  connects_to database: { writing: :primary, reading: :primary_replica }\nend\n\nclass ApplicationRecord < ActiveRecord::Base\n  self.abstract_class = true\n\n  connects_to database: { writing: :primary, reading: :primary_replica }\nend\n\nCopy\n","\nclass Person < ApplicationRecord\nend\n\nclass Person < ApplicationRecord\nend\n\nCopy\n","\nconfig.active_record.writing_role = :default\nconfig.active_record.reading_role = :readonly\n\nconfig.active_record.writing_role = :default\nconfig.active_record.reading_role = :readonly\n\nCopy\n","\n$ bin/rails -T\nrails db:create                          # Creates the database from DATABASE_URL or config/database.yml for the ...\nrails db:create:animals                  # Create animals database for current environment\nrails db:create:primary                  # Create primary database for current environment\nrails db:drop                            # Drops the database from DATABASE_URL or config/database.yml for the cu...\nrails db:drop:animals                    # Drop animals database for current environment\nrails db:drop:primary                    # Drop primary database for current environment\nrails db:migrate                         # Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)\nrails db:migrate:animals                 # Migrate animals database for current environment\nrails db:migrate:primary                 # Migrate primary database for current environment\nrails db:migrate:status                  # Display status of migrations\nrails db:migrate:status:animals          # Display status of migrations for animals database\nrails db:migrate:status:primary          # Display status of migrations for primary database\nrails db:rollback                        # Rolls the schema back to the previous version (specify steps w/ STEP=n)\nrails db:rollback:animals                # Rollback animals database for current environment (specify steps w/ STEP=n)\nrails db:rollback:primary                # Rollback primary database for current environment (specify steps w/ STEP=n)\nrails db:schema:dump                     # Creates a database schema file (either db/schema.rb or db/structure.sql  ...\nrails db:schema:dump:animals             # Creates a database schema file (either db/schema.rb or db/structure.sql  ...\nrails db:schema:dump:primary             # Creates a db/schema.rb file that is portable against any DB supported  ...\nrails db:schema:load                     # Loads a database schema file (either db/schema.rb or db/structure.sql  ...\nrails db:schema:load:animals             # Loads a database schema file (either db/schema.rb or db/structure.sql  ...\nrails db:schema:load:primary             # Loads a database schema file (either db/schema.rb or db/structure.sql  ...\n\nbin/rails -T\n\nCopy\n"],"body":"As an application grows in popularity and usage you'll need to scale the application\nto support your new users and their data. One way in which your application may need\nto scale is on the database level. Rails now has support for multiple databases\nso you don't have to store your data all in one place.At this time the following features are supported:The following features are not (yet) supported:While Rails tries to do most of the work for you there are still some steps you'll\nneed to do to get your application ready for multiple databases.Let's say we have an application with a single writer database and we need to add a\nnew database for some new tables we're adding. The name of the new database will be\n\"animals\".The database.yml looks like this:Let's add a replica for the first configuration, and a second database called animals and a\nreplica for that as well. To do this we need to change our database.yml from a 2-tier\nto a 3-tier config.If a primary configuration is provided this will be used as the \"default\" configuration. If\nthere is no configuration named \"primary\" Rails will use the first configuration for an\nenvironment. The default configurations will use the default Rails filenames. For example\nprimary configurations will use schema.rb for the schema file whereas all other entries\nwill use [CONFIGURATION_NAMESPACE]_schema.rb for the filename.When using multiple databases there are a few important settings.First, the database name for the primary and primary_replica should be the same because they contain\nthe same data. This is also the case for animals and animals_replica.Second, the username for the writers and replicas should be different, and the\nreplica user's permissions should be set to only read and not write.When using a replica database you need to add a replica: true entry to the replica in the\ndatabase.yml. This is because Rails otherwise has no way of knowing which one is a replica\nand which one is the writer.Lastly, for new writer databases you need to set the migrations_paths to the directory\nwhere you will store migrations for that database. We'll look more at migrations_paths\nlater on in this guide.Now that we have a new database, let's set up the connection model. In order to use the\nnew database we need to create a new abstract class and connect to the animals databases.Then we need to update ApplicationRecord to be aware of our new replica.Classes that connect to primary/primary_replica can inherit from ApplicationRecord like\nstandard Rails applications:By default Rails expects the database roles to be writing and reading for the primary\nand replica respectively. If you have a legacy system you may already have roles set up that\nyou don't want to change. In that case you can set a new role name in your application config.It's important to connect to your database in a single model and then inherit from that model\nfor the tables rather than connect multiple individual models to the same database. Database\nclients have a limit to the number of open connections there can be and if you do this it will\nmultiply the number of connections you have since Rails uses the model class name for the\nconnection specification name.Now that we have the database.yml and the new model set up it's time to create the databases.\nRails 6.0 ships with all the rails tasks you need to use multiple databases in Rails.You can run bin/rails -T to see all the commands you're able to run. You should see the following:Running a command like bin/rails db:create will create both the primary and animals databases.\nNote that there is no command for creating the users and you'll need to do that manually\nto support the readonly users for your replicas. If you want to create just the animals\ndatabase you can run bin/rails db:create:animals.","title":"1 Setting up your application","anchor":"#setting-up-your-application"},{"title":"2 Generators and Migrations","anchor":"#generators-and-migrations","code":["\n$ bin/rails generate migration CreateDogs name:string --database animals\n\nbin/rails generate migration CreateDogs name:string --database animals\n\nCopy\n","\n$ bin/rails generate scaffold Dog name:string --database animals\n\nbin/rails generate scaffold Dog name:string --database animals\n\nCopy\n","\nclass AnimalsRecord < ApplicationRecord\n  self.abstract_class = true\n\n  connects_to database: { writing: :animals }\nend\n\nclass AnimalsRecord < ApplicationRecord\n  self.abstract_class = true\n\n  connects_to database: { writing: :animals }\nend\n\nCopy\n","\nclass Dog < AnimalsRecord\nend\n\nclass Dog < AnimalsRecord\nend\n\nCopy\n","\n$ bin/rails generate scaffold Dog name:string --database animals --parent Animals::Record\n\nbin/rails generate scaffold Dog name:string --database animals --parent Animals::Record\n\nCopy\n"],"body":"Migrations for multiple databases should live in their own folders prefixed with the\nname of the database key in the configuration.You also need to set the migrations_paths in the database configurations to tell Rails\nwhere to find the migrations.For example the animals database would look for migrations in the db/animals_migrate directory and\nprimary would look in db/migrate. Rails generators now take a --database option\nso that the file is generated in the correct directory. The command can be run like so:If you are using Rails generators, the scaffold and model generators will create the abstract\nclass for you. Simply pass the database key to the command lineA class with the database name and Record will be created. In this example\nthe database is Animals so we end up with AnimalsRecord:The generated model will automatically inherit from AnimalsRecord.Note: Since Rails doesn't know which database is the replica for your writer you will need to\nadd this to the abstract class after you're done.Rails will only generate the new class once. It will not be overwritten by new scaffolds\nor deleted if the scaffold is deleted.If you already have an abstract class and its name differs from AnimalsRecord you can pass\nthe --parent option to indicate you want a different abstract class:This will skip generating AnimalsRecord since you've indicated to Rails that you want to\nuse a different parent class."},{"title":"3 Activating automatic connection switching","anchor":"#activating-automatic-connection-switching","code":["\nconfig.active_record.database_selector = { delay: 2.seconds }\nconfig.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver\nconfig.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session\n\nconfig.active_record.database_selector = { delay: 2.seconds }\nconfig.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver\nconfig.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session\n\nCopy\n","\nclass MyCookieResolver\n  # code for your cookie class\nend\n\nclass MyCookieResolver\n  # code for your cookie class\nend\n\nCopy\n","\nconfig.active_record.database_selector = { delay: 2.seconds }\nconfig.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver\nconfig.active_record.database_resolver_context = MyCookieResolver\n\nconfig.active_record.database_selector = { delay: 2.seconds }\nconfig.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver\nconfig.active_record.database_resolver_context = MyCookieResolver\n\nCopy\n"],"body":"Finally, in order to use the read-only replica in your application you'll need to activate\nthe middleware for automatic switching.Automatic switching allows the application to switch from the writer to replica or replica\nto writer based on the HTTP verb and whether there was a recent write.If the application is receiving a POST, PUT, DELETE, or PATCH request the application will\nautomatically write to the writer database. For the specified time after the write, the\napplication will read from the primary. For a GET or HEAD request the application will read\nfrom the replica unless there was a recent write.To activate the automatic connection switching middleware, add or uncomment the following\nlines in your application config.Rails guarantees \"read your own write\" and will send your GET or HEAD request to the\nwriter if it's within the delay window. By default the delay is set to 2 seconds. You\nshould change this based on your database infrastructure. Rails doesn't guarantee \"read\na recent write\" for other users within the delay window and will send GET and HEAD requests\nto the replicas unless they wrote recently.The automatic connection switching in Rails is relatively primitive and deliberately doesn't\ndo a whole lot. The goal is a system that demonstrates how to do automatic connection\nswitching that was flexible enough to be customizable by app developers.The setup in Rails allows you to easily change how the switching is done and what\nparameters it's based on. Let's say you want to use a cookie instead of a session to\ndecide when to swap connections. You can write your own class:And then pass it to the middleware:"},{"code":["\nActiveRecord::Base.connected_to(role: :reading) do\n  # all code in this block will be connected to the reading role\nend\n\nActiveRecord::Base.connected_to(role: :reading) do\n  # all code in this block will be connected to the reading role\nend\n\nCopy\n"],"body":"There are some cases where you may want your application to connect to a writer or a replica\nand the automatic connection switching isn't adequate. For example, you may know that for a\nparticular request you always want to send the request to a replica, even when you are in a\nPOST request path.To do this Rails provides a connected_to method that will switch to the connection you\nneed.The \"role\" in the connected_to call looks up the connections that are connected on that\nconnection handler (or role). The reading connection handler will hold all the connections\nthat were connected via connects_to with the role name of reading.Note that connected_to with a role will look up an existing connection and switch\nusing the connection specification name. This means that if you pass an unknown role\nlike connected_to(role: :nonexistent) you will get an error that says\nActiveRecord::ConnectionNotEstablished (No connection pool for 'ActiveRecord::Base' found for the 'nonexistent' role.)","title":"4 Using manual connection switching","anchor":"#using-manual-connection-switching"},{"title":"5 Horizontal sharding","anchor":"#horizontal-sharding","code":["\nproduction:\n  primary:\n    database: my_primary_database\n    adapter: mysql2\n  primary_replica:\n    database: my_primary_database\n    adapter: mysql2\n    replica: true\n  primary_shard_one:\n    database: my_primary_shard_one\n    adapter: mysql2\n  primary_shard_one_replica:\n    database: my_primary_shard_one\n    adapter: mysql2\n    replica: true\n\nproduction:\n  primary:\n    database: my_primary_database\n    adapter: mysql2\n  primary_replica:\n    database: my_primary_database\n    adapter: mysql2\n    replica: true\n  primary_shard_one:\n    database: my_primary_shard_one\n    adapter: mysql2\n  primary_shard_one_replica:\n    database: my_primary_shard_one\n    adapter: mysql2\n    replica: true\n\nCopy\n","\nclass ApplicationRecord < ActiveRecord::Base\n  self.abstract_class = true\n\n  connects_to shards: {\n    default: { writing: :primary, reading: :primary_replica },\n    shard_one: { writing: :primary_shard_one, reading: :primary_shard_one_replica }\n  }\nend\n\nclass ApplicationRecord < ActiveRecord::Base\n  self.abstract_class = true\n\n  connects_to shards: {\n    default: { writing: :primary, reading: :primary_replica },\n    shard_one: { writing: :primary_shard_one, reading: :primary_shard_one_replica }\n  }\nend\n\nCopy\n","\nActiveRecord::Base.connected_to(role: :writing, shard: :default) do\n  @id = Person.create! # Creates a record in shard default\nend\n\nActiveRecord::Base.connected_to(role: :writing, shard: :shard_one) do\n  Person.find(@id) # Can't find record, doesn't exist because it was created\n                   # in the default shard\nend\n\nActiveRecord::Base.connected_to(role: :writing, shard: :default) do\n  @id = Person.create! # Creates a record in shard default\nend\n\nActiveRecord::Base.connected_to(role: :writing, shard: :shard_one) do\n  Person.find(@id) # Can't find record, doesn't exist because it was created\n                   # in the default shard\nend\n\nCopy\n","\nActiveRecord::Base.connected_to(role: :reading, shard: :shard_one) do\n  Person.first # Lookup record from read replica of shard one\nend\n\nActiveRecord::Base.connected_to(role: :reading, shard: :shard_one) do\n  Person.first # Lookup record from read replica of shard one\nend\n\nCopy\n"],"body":"Horizontal sharding is when you split up your database to reduce the number of rows on each\ndatabase server, but maintain the same schema across \"shards\". This is commonly called \"multi-tenant\"\nsharding.The API for supporting horizontal sharding in Rails is similar to the multiple database / vertical\nsharding API that's existed since Rails 6.0.Shards are declared in the three-tier config like this:Models are then connected with the connects_to API via the shards key:Then models can swap connections manually via the connected_to API. If\nusing sharding both a role and shard must be passed:The horizontal sharding API also supports read replicas. You can swap the\nrole and the shard with the connected_to API."},{"code":["\nAnimalsRecord.connected_to(role: :reading) do\n  Dog.first # Reads from animals_replica\n  Person.first  # Reads from primary\nend\n\nAnimalsRecord.connected_to(role: :reading) do\n  Dog.first # Reads from animals_replica\n  Person.first  # Reads from primary\nend\n\nCopy\n","\nAnimalsRecord.connected_to(role: :reading, shard: :shard_one) do\n  Dog.first # Will read from shard_one_replica. If no connection exists for shard_one_replica,\n  # a ConnectionNotEstablished error will be raised\n  Person.first # Will read from primary writer\nend\n\nAnimalsRecord.connected_to(role: :reading, shard: :shard_one) do\n  Dog.first # Will read from shard_one_replica. If no connection exists for shard_one_replica,\n  # a ConnectionNotEstablished error will be raised\n  Person.first # Will read from primary writer\nend\n\nCopy\n","\nApplicationRecord.connected_to(role: :reading, shard: :shard_one) do\n  Person.first # Reads from primary_shard_one_replica\n  Dog.first # Reads from animals_primary\nend\n\nApplicationRecord.connected_to(role: :reading, shard: :shard_one) do\n  Person.first # Reads from primary_shard_one_replica\n  Dog.first # Reads from animals_primary\nend\n\nCopy\n"],"body":"In Rails 6.1 it's possible to switch connections for one database instead of\nall databases globally. To use this feature you must first set\nconfig.active_record.legacy_connection_handling to false in your application\nconfiguration. The majority of applications should not need to make any other\nchanges since the public APIs have the same behavior.With legacy_connection_handling set to false, any abstract connection class\nwill be able to switch connections without affecting other connections. This\nis useful for switching your AnimalsRecord queries to read from the replica\nwhile ensuring your ApplicationRecord queries go to the primary.It's also possible to swap connections granularly for shards.To switch only the primary database cluster use ApplicationRecord:ActiveRecord::Base.connected_to maintains the ability to switch\nconnections globally.","title":"6 Granular Database Connection Switching","anchor":"#granular-database-connection-switching"},{"title":"7 Caveats","anchor":"#caveats","code":[],"body":""},{"title":"7.1 Automatic swapping for horizontal sharding","anchor":"#automatic-swapping-for-horizontal-sharding","code":[],"body":"While Rails now supports an API for connecting to and swapping connections of shards, it does\nnot yet support an automatic swapping strategy. Any shard swapping will need to be done manually\nin your app via a middleware or around_action."},{"title":"7.2 Load Balancing Replicas","anchor":"#load-balancing-replicas","code":[],"body":"Rails also doesn't support automatic load balancing of replicas. This is very\ndependent on your infrastructure. We may implement basic, primitive load balancing\nin the future, but for an application at scale this should be something your application\nhandles outside of Rails."},{"title":"7.3 Joining Across Databases","anchor":"#joining-across-databases","code":[],"body":"Applications cannot join across databases. At the moment applications will need to\nmanually write two selects and split the joins themselves. In a future version Rails\nwill split the joins for you."},{"title":"7.4 Schema Cache","anchor":"#schema-cache","code":[],"body":"If you use a schema cache and multiple databases you'll need to write an initializer\nthat loads the schema cache from your app. This wasn't an issue we could resolve in\ntime for Rails 6.0 but hope to have it in a future version soon."}]