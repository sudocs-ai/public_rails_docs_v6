[{"code":[],"body":"Action Cable seamlessly integrates\nWebSockets with the rest of your\nRails application. It allows for real-time features to be written in Ruby in the\nsame style and form as the rest of your Rails application, while still being\nperformant and scalable. It's a full-stack offering that provides both a\nclient-side JavaScript framework and a server-side Ruby framework. You have\naccess to your full domain model written with Active Record or your ORM of\nchoice.","title":"1 What is Action Cable?","anchor":"#what-is-action-cable-questionmark"},{"title":"2 Terminology","anchor":"#terminology","code":[],"body":"Action Cable uses WebSockets instead of the HTTP request-response protocol.\nBoth Action Cable and WebSockets introduce some less familiar terminology:"},{"title":"2.1 Connections","anchor":"#terminology-connections","code":[],"body":"Connections form the foundation of the client-server relationship.\nA single Action Cable server can handle multiple connection instances. It has one\nconnection instance per WebSocket connection. A single user may have multiple\nWebSockets open to your application if they use multiple browser tabs or devices."},{"title":"2.2 Consumers","anchor":"#consumers","code":[],"body":"The client of a WebSocket connection is called the consumer. In Action Cable\nthe consumer is created by the client-side JavaScript framework."},{"title":"2.3 Channels","anchor":"#terminology-channels","code":[],"body":"Each consumer can in turn subscribe to multiple channels. Each channel\nencapsulates a logical unit of work, similar to what a controller does in\na regular MVC setup. For example, you could have a ChatChannel and\nan AppearancesChannel, and a consumer could be subscribed to either\nor to both of these channels. At the very least, a consumer should be subscribed\nto one channel."},{"title":"2.4 Subscribers","anchor":"#subscribers","code":[],"body":"When the consumer is subscribed to a channel, they act as a subscriber.\nThe connection between the subscriber and the channel is, surprise-surprise,\ncalled a subscription. A consumer can act as a subscriber to a given channel\nany number of times. For example, a consumer could subscribe to multiple chat rooms\nat the same time. (And remember that a physical user may have multiple consumers,\none per tab/device open to your connection)."},{"title":"2.5 Pub/Sub","anchor":"#pub-sub","code":[],"body":"Pub/Sub, or\nPublish-Subscribe, refers to a message queue paradigm whereby senders of\ninformation (publishers), send data to an abstract class of recipients\n(subscribers), without specifying individual recipients. Action Cable uses this\napproach to communicate between the server and many clients."},{"title":"2.6 Broadcastings","anchor":"#terminology-broadcastings","code":[],"body":"A broadcasting is a pub/sub link where anything transmitted by the broadcaster is\nsent directly to the channel subscribers who are streaming that named broadcasting.\nEach channel can be streaming zero or more broadcastings."},{"title":"3 Server-Side Components","anchor":"#server-side-components","code":[],"body":""},{"title":"3.1 Connections","anchor":"#server-side-components-connections","code":[],"body":"For every WebSocket accepted by the server, a connection object is instantiated. This\nobject becomes the parent of all the channel subscriptions that are created\nfrom there on. The connection itself does not deal with any specific application\nlogic beyond authentication and authorization. The client of a WebSocket\nconnection is called the connection consumer. An individual user will create\none consumer-connection pair per browser tab, window, or device they have open.Connections are instances of ApplicationCable::Connection, which extends\nActionCable::Connection::Base. In ApplicationCable::Connection, you\nauthorize the incoming connection, and proceed to establish it if the user can\nbe identified."},{"title":"3.1.1 Connection Setup","anchor":"#connection-setup","code":["\n# app/channels/application_cable/connection.rb\nmodule ApplicationCable\n  class Connection < ActionCable::Connection::Base\n    identified_by :current_user\n\n    def connect\n      self.current_user = find_verified_user\n    end\n\n    private\n      def find_verified_user\n        if verified_user = User.find_by(id: cookies.encrypted[:user_id])\n          verified_user\n        else\n          reject_unauthorized_connection\n        end\n      end\n  end\nend\n\n# app/channels/application_cable/connection.rb\nmodule ApplicationCable\n  class Connection < ActionCable::Connection::Base\n    identified_by :current_user\n\n    def connect\n      self.current_user = find_verified_user\n    end\n\n    private\n      def find_verified_user\n        if verified_user = User.find_by(id: cookies.encrypted[:user_id])\n          verified_user\n        else\n          reject_unauthorized_connection\n        end\n      end\n  end\nend\n\nCopy\n","\nverified_user = User.find_by(id: cookies.encrypted['_session']['user_id'])\n\nverified_user = User.find_by(id: cookies.encrypted['_session']['user_id'])\n\nCopy\n"],"body":"Here identified_by designates a connection identifier that can be used to find the\nspecific connection later. Note that anything marked as an identifier will automatically\ncreate a delegate by the same name on any channel instances created off the connection.This example relies on the fact that you will already have handled authentication of the user\nsomewhere else in your application, and that a successful authentication sets an encrypted\ncookie with the user ID.The cookie is then automatically sent to the connection instance when a new connection\nis attempted, and you use that to set the current_user. By identifying the connection\nby this same current user, you're also ensuring that you can later retrieve all open\nconnections by a given user (and potentially disconnect them all if the user is deleted\nor unauthorized).If your authentication approach includes using a session, you use cookie store for the\nsession, your session cookie is named _session and the user ID key is user_id you\ncan use this approach:"},{"code":["\n# app/channels/application_cable/connection.rb\nmodule ApplicationCable\n  class Connection < ActionCable::Connection::Base\n    rescue_from StandardError, with: :report_error\n\n    private\n\n    def report_error(e)\n      SomeExternalBugtrackingService.notify(e)\n    end\n  end\nend\n\n# app/channels/application_cable/connection.rb\nmodule ApplicationCable\n  class Connection < ActionCable::Connection::Base\n    rescue_from StandardError, with: :report_error\n\n    private\n\n    def report_error(e)\n      SomeExternalBugtrackingService.notify(e)\n    end\n  end\nend\n\nCopy\n"],"body":"By default, unhandled exceptions are caught and logged to Rails' logger. If you would like to\nglobally intercept these exceptions and report them to an external bug tracking service, for\nexample, you can do so with rescue_from:","title":"3.1.2 Exception Handling","anchor":"#server-side-components-connections-exception-handling"},{"code":[],"body":"A channel encapsulates a logical unit of work, similar to what a controller does in a\nregular MVC setup. By default, Rails creates a parent ApplicationCable::Channel class\n(which extends ActionCable::Channel::Base) for encapsulating shared logic between your channels.","title":"3.2 Channels","anchor":"#server-side-components-channels"},{"title":"3.2.1 Parent Channel Setup","anchor":"#parent-channel-setup","code":["\n# app/channels/application_cable/channel.rb\nmodule ApplicationCable\n  class Channel < ActionCable::Channel::Base\n  end\nend\n\n# app/channels/application_cable/channel.rb\nmodule ApplicationCable\n  class Channel < ActionCable::Channel::Base\n  end\nend\n\nCopy\n","\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\nend\n\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\nend\n\nCopy\n","\n# app/channels/appearance_channel.rb\nclass AppearanceChannel < ApplicationCable::Channel\nend\n\n# app/channels/appearance_channel.rb\nclass AppearanceChannel < ApplicationCable::Channel\nend\n\nCopy\n"],"body":"Then you would create your own channel classes. For example, you could have a\nChatChannel and an AppearanceChannel:A consumer could then be subscribed to either or both of these channels."},{"title":"3.2.2 Subscriptions","anchor":"#server-side-components-channels-subscriptions","code":["\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  # Called when the consumer has successfully\n  # become a subscriber to this channel.\n  def subscribed\n  end\nend\n\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  # Called when the consumer has successfully\n  # become a subscriber to this channel.\n  def subscribed\n  end\nend\n\nCopy\n"],"body":"Consumers subscribe to channels, acting as subscribers. Their connection is\ncalled a subscription. Produced messages are then routed to these channel\nsubscriptions based on an identifier sent by the channel consumer."},{"code":["\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  rescue_from 'MyError', with: :deliver_error_message\n\n  private\n\n  def deliver_error_message(e)\n    broadcast_to(...)\n  end\nend\n\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  rescue_from 'MyError', with: :deliver_error_message\n\n  private\n\n  def deliver_error_message(e)\n    broadcast_to(...)\n  end\nend\n\nCopy\n"],"body":"As with ApplicationCable::Connection, you can also use rescue_from on a\nspecific channel to handle raised exceptions:","title":"3.2.3 Exception Handling","anchor":"#server-side-components-channels-exception-handling"},{"code":[],"body":"","title":"4 Client-Side Components","anchor":"#client-side-components"},{"title":"4.1 Connections","anchor":"#connections","code":[],"body":"Consumers require an instance of the connection on their side. This can be\nestablished using the following JavaScript, which is generated by default by Rails:"},{"title":"4.1.1 Connect Consumer","anchor":"#connect-consumer","code":["\n// app/javascript/channels/consumer.js\n// Action Cable provides the framework to deal with WebSockets in Rails.\n// You can generate new channels where WebSocket features live using the `bin/rails generate channel` command.\n\nimport { createConsumer } from \"@rails/actioncable\"\n\nexport default createConsumer()\n\n// app/javascript/channels/consumer.js\n// Action Cable provides the framework to deal with WebSockets in Rails.\n// You can generate new channels where WebSocket features live using the `bin/rails generate channel` command.\n\nimport { createConsumer } from \"@rails/actioncable\"\n\nexport default createConsumer()\n\nCopy\n","\n// Specify a different URL to connect to\ncreateConsumer('https://ws.example.com/cable')\n\n// Use a function to dynamically generate the URL\ncreateConsumer(getWebSocketURL)\n\nfunction getWebSocketURL {\n  const token = localStorage.get('auth-token')\n  return `https://ws.example.com/cable?token=${token}`\n}\n\n// Specify a different URL to connect to\ncreateConsumer('https://ws.example.com/cable')\n\n// Use a function to dynamically generate the URL\ncreateConsumer(getWebSocketURL)\n\nfunction getWebSocketURL {\n  const token = localStorage.get('auth-token')\n  return `https://ws.example.com/cable?token=${token}`\n}\n\nCopy\n"],"body":"This will ready a consumer that'll connect against /cable on your server by default.\nThe connection won't be established until you've also specified at least one subscription\nyou're interested in having.The consumer can optionally take an argument that specifies the URL to connect to. This\ncan be a string, or a function that returns a string that will be called when the\nWebSocket is opened."},{"code":["\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" })\n\n// app/javascript/channels/appearance_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"AppearanceChannel\" })\n\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" })\n\n// app/javascript/channels/appearance_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"AppearanceChannel\" })\n\nCopy\n","\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"1st Room\" })\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"2nd Room\" })\n\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"1st Room\" })\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"2nd Room\" })\n\nCopy\n"],"body":"A consumer becomes a subscriber by creating a subscription to a given channel:While this creates the subscription, the functionality needed to respond to\nreceived data will be described later on.A consumer can act as a subscriber to a given channel any number of times. For\nexample, a consumer could subscribe to multiple chat rooms at the same time:","title":"4.1.2 Subscriber","anchor":"#subscriber"},{"code":[],"body":"","title":"5 Client-Server Interactions","anchor":"#client-server-interactions"},{"title":"5.1 Streams","anchor":"#streams","code":["\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  def subscribed\n    stream_from \"chat_#{params[:room]}\"\n  end\nend\n\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  def subscribed\n    stream_from \"chat_#{params[:room]}\"\n  end\nend\n\nCopy\n","\nActionCable.server.broadcast(\"chat_Best Room\", { body: \"This Room is Best Room.\" })\n\nActionCable.server.broadcast(\"chat_Best Room\", { body: \"This Room is Best Room.\" })\n\nCopy\n","\nclass CommentsChannel < ApplicationCable::Channel\n  def subscribed\n    post = Post.find(params[:id])\n    stream_for post\n  end\nend\n\nclass CommentsChannel < ApplicationCable::Channel\n  def subscribed\n    post = Post.find(params[:id])\n    stream_for post\n  end\nend\n\nCopy\n","\nCommentsChannel.broadcast_to(@post, @comment)\n\nCommentsChannel.broadcast_to(@post, @comment)\n\nCopy\n"],"body":"Streams provide the mechanism by which channels route published content\n(broadcasts) to their subscribers. For example, the following code uses\nstream_from to subscribe to the broadcasting named chat_Best Room when\nthe value of the :room parameter is \"Best Room\":Then, elsewhere in your Rails application, you can broadcast to such a room by\ncalling broadcast:If you have a stream that is related to a model, then the broadcasting name\ncan be generated from the channel and model. For example, the following code\nuses stream_for to subscribe to a broadcasting like\ncomments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE, where Z2lkOi8vVGVzdEFwcC9Qb3N0LzE is\nthe GlobalID of the Post model.You can then broadcast to this channel by calling broadcast_to:"},{"code":[],"body":"A broadcasting is a pub/sub link where anything transmitted by a publisher\nis routed directly to the channel subscribers who are streaming that named\nbroadcasting. Each channel can be streaming zero or more broadcastings.Broadcastings are purely an online queue and time-dependent. If a consumer is\nnot streaming (subscribed to a given channel), they'll not get the broadcast\nshould they connect later.","title":"5.2 Broadcastings","anchor":"#client-server-interactions-broadcastings"},{"title":"5.3 Subscriptions","anchor":"#client-server-interactions-subscriptions","code":["\n// app/javascript/channels/chat_channel.js\n// Assumes you've already requested the right to send web notifications\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" }, {\n  received(data) {\n    this.appendLine(data)\n  },\n\n  appendLine(data) {\n    const html = this.createLine(data)\n    const element = document.querySelector(\"[data-chat-room='Best Room']\")\n    element.insertAdjacentHTML(\"beforeend\", html)\n  },\n\n  createLine(data) {\n    return `\n      <article class=\"chat-line\">\n        <span class=\"speaker\">${data[\"sent_by\"]}</span>\n        <span class=\"body\">${data[\"body\"]}</span>\n      </article>\n    `\n  }\n})\n\n// app/javascript/channels/chat_channel.js\n// Assumes you've already requested the right to send web notifications\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" }, {\n  received(data) {\n    this.appendLine(data)\n  },\n\n  appendLine(data) {\n    const html = this.createLine(data)\n    const element = document.querySelector(\"[data-chat-room='Best Room']\")\n    element.insertAdjacentHTML(\"beforeend\", html)\n  },\n\n  createLine(data) {\n    return `\n      <article class=\"chat-line\">\n        <span class=\"speaker\">${data[\"sent_by\"]}</span>\n        <span class=\"body\">${data[\"body\"]}</span>\n      </article>\n    `\n  }\n})\n\nCopy\n"],"body":"When a consumer is subscribed to a channel, they act as a subscriber. This\nconnection is called a subscription. Incoming messages are then routed to\nthese channel subscriptions based on an identifier sent by the cable consumer."},{"code":["\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  def subscribed\n    stream_from \"chat_#{params[:room]}\"\n  end\nend\n\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  def subscribed\n    stream_from \"chat_#{params[:room]}\"\n  end\nend\n\nCopy\n","\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" }, {\n  received(data) {\n    this.appendLine(data)\n  },\n\n  appendLine(data) {\n    const html = this.createLine(data)\n    const element = document.querySelector(\"[data-chat-room='Best Room']\")\n    element.insertAdjacentHTML(\"beforeend\", html)\n  },\n\n  createLine(data) {\n    return `\n      <article class=\"chat-line\">\n        <span class=\"speaker\">${data[\"sent_by\"]}</span>\n        <span class=\"body\">${data[\"body\"]}</span>\n      </article>\n    `\n  }\n})\n\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" }, {\n  received(data) {\n    this.appendLine(data)\n  },\n\n  appendLine(data) {\n    const html = this.createLine(data)\n    const element = document.querySelector(\"[data-chat-room='Best Room']\")\n    element.insertAdjacentHTML(\"beforeend\", html)\n  },\n\n  createLine(data) {\n    return `\n      <article class=\"chat-line\">\n        <span class=\"speaker\">${data[\"sent_by\"]}</span>\n        <span class=\"body\">${data[\"body\"]}</span>\n      </article>\n    `\n  }\n})\n\nCopy\n","\n# Somewhere in your app this is called, perhaps\n# from a NewCommentJob.\nActionCable.server.broadcast(\n  \"chat_#{room}\",\n  {\n    sent_by: 'Paul',\n    body: 'This is a cool chat app.'\n  }\n)\n\n# Somewhere in your app this is called, perhaps\n# from a NewCommentJob.\nActionCable.server.broadcast(\n  \"chat_#{room}\",\n  {\n    sent_by: 'Paul',\n    body: 'This is a cool chat app.'\n  }\n)\n\nCopy\n"],"body":"You can pass parameters from the client side to the server side when creating a\nsubscription. For example:An object passed as the first argument to subscriptions.create becomes the\nparams hash in the cable channel. The keyword channel is required:","title":"5.4 Passing Parameters to Channels","anchor":"#passing-parameters-to-channels"},{"code":["\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  def subscribed\n    stream_from \"chat_#{params[:room]}\"\n  end\n\n  def receive(data)\n    ActionCable.server.broadcast(\"chat_#{params[:room]}\", data)\n  end\nend\n\n# app/channels/chat_channel.rb\nclass ChatChannel < ApplicationCable::Channel\n  def subscribed\n    stream_from \"chat_#{params[:room]}\"\n  end\n\n  def receive(data)\n    ActionCable.server.broadcast(\"chat_#{params[:room]}\", data)\n  end\nend\n\nCopy\n","\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconst chatChannel = consumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" }, {\n  received(data) {\n    // data => { sent_by: \"Paul\", body: \"This is a cool chat app.\" }\n  }\n}\n\nchatChannel.send({ sent_by: \"Paul\", body: \"This is a cool chat app.\" })\n\n// app/javascript/channels/chat_channel.js\nimport consumer from \"./consumer\"\n\nconst chatChannel = consumer.subscriptions.create({ channel: \"ChatChannel\", room: \"Best Room\" }, {\n  received(data) {\n    // data => { sent_by: \"Paul\", body: \"This is a cool chat app.\" }\n  }\n}\n\nchatChannel.send({ sent_by: \"Paul\", body: \"This is a cool chat app.\" })\n\nCopy\n"],"body":"A common use case is to rebroadcast a message sent by one client to any\nother connected clients.The rebroadcast will be received by all connected clients, including the\nclient that sent the message. Note that params are the same as they were when\nyou subscribed to the channel.","title":"5.5 Rebroadcasting a Message","anchor":"#rebroadcasting-a-message"},{"title":"6 Full-Stack Examples","anchor":"#full-stack-examples","code":[],"body":"The following setup steps are common to both examples:"},{"code":["\n# app/channels/appearance_channel.rb\nclass AppearanceChannel < ApplicationCable::Channel\n  def subscribed\n    current_user.appear\n  end\n\n  def unsubscribed\n    current_user.disappear\n  end\n\n  def appear(data)\n    current_user.appear(on: data['appearing_on'])\n  end\n\n  def away\n    current_user.away\n  end\nend\n\n# app/channels/appearance_channel.rb\nclass AppearanceChannel < ApplicationCable::Channel\n  def subscribed\n    current_user.appear\n  end\n\n  def unsubscribed\n    current_user.disappear\n  end\n\n  def appear(data)\n    current_user.appear(on: data['appearing_on'])\n  end\n\n  def away\n    current_user.away\n  end\nend\n\nCopy\n","\n// app/javascript/channels/appearance_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create(\"AppearanceChannel\", {\n  // Called once when the subscription is created.\n  initialized() {\n    this.update = this.update.bind(this)\n  },\n\n  // Called when the subscription is ready for use on the server.\n  connected() {\n    this.install()\n    this.update()\n  },\n\n  // Called when the WebSocket connection is closed.\n  disconnected() {\n    this.uninstall()\n  },\n\n  // Called when the subscription is rejected by the server.\n  rejected() {\n    this.uninstall()\n  },\n\n  update() {\n    this.documentIsActive ? this.appear() : this.away()\n  },\n\n  appear() {\n    // Calls `AppearanceChannel#appear(data)` on the server.\n    this.perform(\"appear\", { appearing_on: this.appearingOn })\n  },\n\n  away() {\n    // Calls `AppearanceChannel#away` on the server.\n    this.perform(\"away\")\n  },\n\n  install() {\n    window.addEventListener(\"focus\", this.update)\n    window.addEventListener(\"blur\", this.update)\n    document.addEventListener(\"turbolinks:load\", this.update)\n    document.addEventListener(\"visibilitychange\", this.update)\n  },\n\n  uninstall() {\n    window.removeEventListener(\"focus\", this.update)\n    window.removeEventListener(\"blur\", this.update)\n    document.removeEventListener(\"turbolinks:load\", this.update)\n    document.removeEventListener(\"visibilitychange\", this.update)\n  },\n\n  get documentIsActive() {\n    return document.visibilityState == \"visible\" && document.hasFocus()\n  },\n\n  get appearingOn() {\n    const element = document.querySelector(\"[data-appearing-on]\")\n    return element ? element.getAttribute(\"data-appearing-on\") : null\n  }\n})\n\n// app/javascript/channels/appearance_channel.js\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create(\"AppearanceChannel\", {\n  // Called once when the subscription is created.\n  initialized() {\n    this.update = this.update.bind(this)\n  },\n\n  // Called when the subscription is ready for use on the server.\n  connected() {\n    this.install()\n    this.update()\n  },\n\n  // Called when the WebSocket connection is closed.\n  disconnected() {\n    this.uninstall()\n  },\n\n  // Called when the subscription is rejected by the server.\n  rejected() {\n    this.uninstall()\n  },\n\n  update() {\n    this.documentIsActive ? this.appear() : this.away()\n  },\n\n  appear() {\n    // Calls `AppearanceChannel#appear(data)` on the server.\n    this.perform(\"appear\", { appearing_on: this.appearingOn })\n  },\n\n  away() {\n    // Calls `AppearanceChannel#away` on the server.\n    this.perform(\"away\")\n  },\n\n  install() {\n    window.addEventListener(\"focus\", this.update)\n    window.addEventListener(\"blur\", this.update)\n    document.addEventListener(\"turbolinks:load\", this.update)\n    document.addEventListener(\"visibilitychange\", this.update)\n  },\n\n  uninstall() {\n    window.removeEventListener(\"focus\", this.update)\n    window.removeEventListener(\"blur\", this.update)\n    document.removeEventListener(\"turbolinks:load\", this.update)\n    document.removeEventListener(\"visibilitychange\", this.update)\n  },\n\n  get documentIsActive() {\n    return document.visibilityState == \"visible\" && document.hasFocus()\n  },\n\n  get appearingOn() {\n    const element = document.querySelector(\"[data-appearing-on]\")\n    return element ? element.getAttribute(\"data-appearing-on\") : null\n  }\n})\n\nCopy\n"],"body":"Here's a simple example of a channel that tracks whether a user is online or not\nand what page they're on. (This is useful for creating presence features like showing\na green dot next to a user name if they're online).Create the server-side appearance channel:When a subscription is initiated the subscribed callback gets fired and we\ntake that opportunity to say \"the current user has indeed appeared\". That\nappear/disappear API could be backed by Redis, a database, or whatever else.Create the client-side appearance channel subscription:","title":"6.1 Example 1: User Appearances","anchor":"#example-1-user-appearances"},{"code":["\n# app/channels/web_notifications_channel.rb\nclass WebNotificationsChannel < ApplicationCable::Channel\n  def subscribed\n    stream_for current_user\n  end\nend\n\n# app/channels/web_notifications_channel.rb\nclass WebNotificationsChannel < ApplicationCable::Channel\n  def subscribed\n    stream_for current_user\n  end\nend\n\nCopy\n","\n// app/javascript/channels/web_notifications_channel.js\n// Client-side which assumes you've already requested\n// the right to send web notifications.\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create(\"WebNotificationsChannel\", {\n  received(data) {\n    new Notification(data[\"title\"], body: data[\"body\"])\n  }\n})\n\n// app/javascript/channels/web_notifications_channel.js\n// Client-side which assumes you've already requested\n// the right to send web notifications.\nimport consumer from \"./consumer\"\n\nconsumer.subscriptions.create(\"WebNotificationsChannel\", {\n  received(data) {\n    new Notification(data[\"title\"], body: data[\"body\"])\n  }\n})\n\nCopy\n","\n# Somewhere in your app this is called, perhaps from a NewCommentJob\nWebNotificationsChannel.broadcast_to(\n  current_user,\n  title: 'New things!',\n  body: 'All the news fit to print'\n)\n\n# Somewhere in your app this is called, perhaps from a NewCommentJob\nWebNotificationsChannel.broadcast_to(\n  current_user,\n  title: 'New things!',\n  body: 'All the news fit to print'\n)\n\nCopy\n"],"body":"The appearance example was all about exposing server functionality to\nclient-side invocation over the WebSocket connection. But the great thing\nabout WebSockets is that it's a two-way street. So now let's show an example\nwhere the server invokes an action on the client.This is a web notification channel that allows you to trigger client-side\nweb notifications when you broadcast to the right streams:Create the server-side web notifications channel:Create the client-side web notifications channel subscription:Broadcast content to a web notification channel instance from elsewhere in your\napplication:The WebNotificationsChannel.broadcast_to call places a message in the current\nsubscription adapter's pubsub queue under a separate broadcasting name for each\nuser. For a user with an ID of 1, the broadcasting name would be\nweb_notifications:1.The channel has been instructed to stream everything that arrives at\nweb_notifications:1 directly to the client by invoking the received\ncallback. The data passed as argument is the hash sent as the second parameter\nto the server-side broadcast call, JSON encoded for the trip across the wire\nand unpacked for the data argument arriving as received.","title":"6.2 Example 2: Receiving New Web Notifications","anchor":"#example-2-receiving-new-web-notifications"},{"title":"6.3 More Complete Examples","anchor":"#more-complete-examples","code":[],"body":"See the rails/actioncable-examples\nrepository for a full example of how to set up Action Cable in a Rails app and adding channels."},{"title":"7 Configuration","anchor":"#configuration","code":[],"body":"Action Cable has two required configurations: a subscription adapter and allowed request origins."},{"title":"7.1 Subscription Adapter","anchor":"#subscription-adapter","code":["\ndevelopment:\n  adapter: async\n\ntest:\n  adapter: async\n\nproduction:\n  adapter: redis\n  url: redis://10.10.3.153:6381\n  channel_prefix: appname_production\n\ndevelopment:\n  adapter: async\n\ntest:\n  adapter: async\n\nproduction:\n  adapter: redis\n  url: redis://10.10.3.153:6381\n  channel_prefix: appname_production\n\nCopy\n"],"body":"By default, Action Cable looks for a configuration file in config/cable.yml.\nThe file must specify an adapter for each Rails environment. See the\nDependencies section for additional information on adapters."},{"code":[],"body":"Below is a list of the subscription adapters available for end users.The async adapter is intended for development/testing and should not be used in production.The Redis adapter requires users to provide a URL pointing to the Redis server.\nAdditionally, a channel_prefix may be provided to avoid channel name collisions\nwhen using the same Redis server for multiple applications. See the Redis PubSub documentation for more details.The PostgreSQL adapter uses Active Record's connection pool, and thus the\napplication's config/database.yml database configuration, for its connection.\nThis may change in the future. #27214","title":"7.1.1 Adapter Configuration","anchor":"#adapter-configuration"},{"title":"7.2 Allowed Request Origins","anchor":"#allowed-request-origins","code":["\nconfig.action_cable.allowed_request_origins = ['https://rubyonrails.com', %r{http://ruby.*}]\n\nconfig.action_cable.allowed_request_origins = ['https://rubyonrails.com', %r{http://ruby.*}]\n\nCopy\n","\nconfig.action_cable.disable_request_forgery_protection = true\n\nconfig.action_cable.disable_request_forgery_protection = true\n\nCopy\n"],"body":"Action Cable will only accept requests from specified origins, which are\npassed to the server config as an array. The origins can be instances of\nstrings or regular expressions, against which a check for the match will be performed.To disable and allow requests from any origin:By default, Action Cable allows all requests from localhost:3000 when running\nin the development environment."},{"title":"7.3 Consumer Configuration","anchor":"#consumer-configuration","code":[],"body":"To configure the URL, add a call to action_cable_meta_tag in your HTML layout\nHEAD. This uses a URL or path typically set via config.action_cable.url in the\nenvironment configuration files."},{"title":"7.4 Worker Pool Configuration","anchor":"#worker-pool-configuration","code":["\nconfig.action_cable.worker_pool_size = 4\n\nconfig.action_cable.worker_pool_size = 4\n\nCopy\n"],"body":"The worker pool is used to run connection callbacks and channel actions in\nisolation from the server's main thread. Action Cable allows the application\nto configure the number of simultaneously processed threads in the worker pool.Also, note that your server must provide at least the same number of database\nconnections as you have workers. The default worker pool size is set to 4, so\nthat means you have to make at least 4 database connections available.\nYou can change that in config/database.yml through the pool attribute."},{"title":"7.5 Client side logging","anchor":"#client-side-logging","code":["\nimport * as ActionCable from '@rails/actioncable'\n\nActionCable.logger.enabled = true\n\nimport * as ActionCable from '@rails/actioncable'\n\nActionCable.logger.enabled = true\n\nCopy\n"],"body":"Client side logging is disabled by default. You can enable this by setting the ActionCable.logger.enabled to true."},{"code":["\nconfig.action_cable.log_tags = [\n  -> request { request.env['user_account_id'] || \"no-account\" },\n  :action_cable,\n  -> request { request.uuid }\n]\n\nconfig.action_cable.log_tags = [\n  -> request { request.env['user_account_id'] || \"no-account\" },\n  :action_cable,\n  -> request { request.uuid }\n]\n\nCopy\n"],"body":"The other common option to configure is the log tags applied to the\nper-connection logger. Here's an example that uses\nthe user account id if available, else \"no-account\" while tagging:For a full list of all configuration options, see the\nActionCable::Server::Configuration class.","title":"7.6 Other Configurations","anchor":"#other-configurations"},{"title":"8 Running Standalone Cable Servers","anchor":"#running-standalone-cable-servers","code":[],"body":""},{"title":"8.1 In App","anchor":"#in-app","code":["\n# config/application.rb\nclass Application < Rails::Application\n  config.action_cable.mount_path = '/websocket'\nend\n\n# config/application.rb\nclass Application < Rails::Application\n  config.action_cable.mount_path = '/websocket'\nend\n\nCopy\n"],"body":"Action Cable can run alongside your Rails application. For example, to\nlisten for WebSocket requests on /websocket, specify that path to\nconfig.action_cable.mount_path:You can use ActionCable.createConsumer() to connect to the cable\nserver if action_cable_meta_tag is invoked in the layout. Otherwise, A path is\nspecified as first argument to createConsumer (e.g. ActionCable.createConsumer(\"/websocket\")).For every instance of your server you create and for every worker your server\nspawns, you will also have a new instance of Action Cable, but the use of Redis\nkeeps messages synced across connections."},{"title":"8.2 Standalone","anchor":"#standalone","code":["\n# cable/config.ru\nrequire_relative \"../config/environment\"\nRails.application.eager_load!\n\nrun ActionCable.server\n\n# cable/config.ru\nrequire_relative \"../config/environment\"\nRails.application.eager_load!\n\nrun ActionCable.server\n\nCopy\n","\n#!/bin/bash\nbundle exec puma -p 28080 cable/config.ru\n\n#!/bin/bash\nbundle exec puma -p 28080 cable/config.ru\n\nCopy\n"],"body":"The cable servers can be separated from your normal application server. It's\nstill a Rack application, but it is its own Rack application. The recommended\nbasic setup is as follows:Then you start the server using a binstub in bin/cable ala:The above will start a cable server on port 28080."},{"title":"8.3 Notes","anchor":"#notes","code":[],"body":"The WebSocket server doesn't have access to the session, but it has\naccess to the cookies. This can be used when you need to handle\nauthentication. You can see one way of doing that with Devise in this article."},{"title":"9 Dependencies","anchor":"#dependencies","code":[],"body":"Action Cable provides a subscription adapter interface to process its\npubsub internals. By default, asynchronous, inline, PostgreSQL, and Redis\nadapters are included. The default adapter\nin new Rails applications is the asynchronous (async) adapter.The Ruby side of things is built on top of websocket-driver,\nnio4r, and concurrent-ruby."},{"title":"10 Deployment","anchor":"#deployment","code":[],"body":"Action Cable is powered by a combination of WebSockets and threads. Both the\nframework plumbing and user-specified channel work are handled internally by\nutilizing Ruby's native thread support. This means you can use all your regular\nRails models with no problem, as long as you haven't committed any thread-safety sins.The Action Cable server implements the Rack socket hijacking API,\nthereby allowing the use of a multithreaded pattern for managing connections\ninternally, irrespective of whether the application server is multi-threaded or not.Accordingly, Action Cable works with popular servers like Unicorn, Puma, and\nPassenger."},{"title":"11 Testing","anchor":"#testing","code":[],"body":"You can find detailed instructions on how to test your Action Cable functionality in the\ntesting guide."}]