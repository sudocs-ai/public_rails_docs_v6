[{"code":[],"body":"This guide is designed for beginners who want to get started with a Rails\napplication from scratch. It does not assume that you have any prior experience\nwith Rails.Rails is a web application framework running on the Ruby programming language.\nIf you have no prior experience with Ruby, you will find a very steep learning\ncurve diving straight into Rails. There are several curated lists of online resources\nfor learning Ruby:Be aware that some resources, while still excellent, cover older versions of\nRuby, and may not include some syntax that you will see in day-to-day\ndevelopment with Rails.","title":"1 Guide Assumptions","anchor":"#guide-assumptions"},{"title":"2 What is Rails?","anchor":"#what-is-rails-questionmark","code":[],"body":"Rails is a web application development framework written in the Ruby programming language.\nIt is designed to make programming web applications easier by making assumptions\nabout what every developer needs to get started. It allows you to write less\ncode while accomplishing more than many other languages and frameworks.\nExperienced Rails developers also report that it makes web application\ndevelopment more fun.Rails is opinionated software. It makes the assumption that there is a \"best\"\nway to do things, and it's designed to encourage that way - and in some cases to\ndiscourage alternatives. If you learn \"The Rails Way\" you'll probably discover a\ntremendous increase in productivity. If you persist in bringing old habits from\nother languages to your Rails development, and trying to use patterns you\nlearned elsewhere, you may have a less happy experience.The Rails philosophy includes two major guiding principles:"},{"code":[],"body":"The best way to read this guide is to follow it step by step. All steps are\nessential to run this example application and no additional code or steps are\nneeded.By following along with this guide, you'll create a Rails project called\nblog, a (very) simple weblog. Before you can start building the application,\nyou need to make sure that you have Rails itself installed.","title":"3 Creating a New Rails Project","anchor":"#creating-a-new-rails-project"},{"title":"3.1 Installing Rails","anchor":"#creating-a-new-rails-project-installing-rails","code":[],"body":"Before you install Rails, you should check to make sure that your system has the\nproper prerequisites installed. These include:"},{"code":["\n$ ruby --version\nruby 2.5.0\n\nruby --version\n\nCopy\n"],"body":"Open up a command line prompt. On macOS open Terminal.app; on Windows choose\n\"Run\" from your Start menu and type cmd.exe. Any commands prefaced with a\ndollar sign $ should be run in the command line. Verify that you have a\ncurrent version of Ruby installed:Rails requires Ruby version 2.5.0 or later. If the version number returned is\nless than that number (such as 2.3.7, or 1.8.7), you'll need to install a fresh copy of Ruby.To install Rails on Windows, you'll first need to install Ruby Installer.For more installation methods for most Operating Systems take a look at\nruby-lang.org.","title":"3.1.1 Installing Ruby","anchor":"#installing-ruby"},{"title":"3.1.2 Installing SQLite3","anchor":"#installing-sqlite3","code":["\n$ sqlite3 --version\n\nsqlite3 --version\n\nCopy\n"],"body":"You will also need an installation of the SQLite3 database.\nMany popular UNIX-like OSes ship with an acceptable version of SQLite3.\nOthers can find installation instructions at the SQLite3 website.Verify that it is correctly installed and in your load PATH:The program should report its version."},{"title":"3.1.3 Installing Node.js and Yarn","anchor":"#installing-node-js-and-yarn","code":["\n$ node --version\n\nnode --version\n\nCopy\n","\n$ yarn --version\n\nyarn --version\n\nCopy\n"],"body":"Finally, you'll need Node.js and Yarn installed to manage your application's JavaScript.Find the installation instructions at the Node.js website and\nverify it's installed correctly with the following command:The version of your Node.js runtime should be printed out. Make sure it's greater\nthan 8.16.0.To install Yarn, follow the installation\ninstructions at the Yarn website.Running this command should print out Yarn version:If it says something like \"1.22.0\", Yarn has been installed correctly."},{"title":"3.1.4 Installing Rails","anchor":"#creating-a-new-rails-project-installing-rails-installing-rails","code":["\n$ gem install rails\n\ngem install rails\n\nCopy\n","\n$ rails --version\n\nrails --version\n\nCopy\n"],"body":"To install Rails, use the gem install command provided by RubyGems:To verify that you have everything installed correctly, you should be able to\nrun the following:If it says something like \"Rails 6.0.0\", you are ready to continue."},{"title":"3.2 Creating the Blog Application","anchor":"#creating-the-blog-application","code":["\n$ rails new blog\n\nrails new blog\n\nCopy\n","\n$ cd blog\n\ncd blog\n\nCopy\n"],"body":"Rails comes with a number of scripts called generators that are designed to make\nyour development life easier by creating everything that's necessary to start\nworking on a particular task. One of these is the new application generator,\nwhich will provide you with the foundation of a fresh Rails application so that\nyou don't have to write it yourself.To use this generator, open a terminal, navigate to a directory where you have\nrights to create files, and run:This will create a Rails application called Blog in a blog directory and\ninstall the gem dependencies that are already mentioned in Gemfile using\nbundle install.After you create the blog application, switch to its folder:The blog directory will have a number of generated files and folders that make\nup the structure of a Rails application. Most of the work in this tutorial will\nhappen in the app folder, but here's a basic rundown on the function of each\nof the files and folders that Rails creates by default:"},{"code":[],"body":"To begin with, let's get some text up on screen quickly. To do this, you need to\nget your Rails application server running.","title":"4 Hello, Rails!","anchor":"#hello-rails-bang"},{"title":"4.1 Starting up the Web Server","anchor":"#starting-up-the-web-server","code":["\n$ bin/rails server\n\nbin/rails server\n\nCopy\n"],"body":"You actually have a functional Rails application already. To see it, you need to\nstart a web server on your development machine. You can do this by running the\nfollowing command in the blog directory:This will start up Puma, a web server distributed with Rails by default. To see\nyour application in action, open a browser window and navigate to\nhttp://localhost:3000. You should see the Rails default information page:When you want to stop the web server, hit Ctrl+C in the terminal window where\nit's running. In the development environment, Rails does not generally\nrequire you to restart the server; changes you make in files will be\nautomatically picked up by the server.The \"Yay! You're on Rails!\" page is the smoke test for a new Rails\napplication: it makes sure that you have your software configured correctly\nenough to serve a page."},{"title":"4.2 Say \"Hello\", Rails","anchor":"#say-hello-rails","code":["\nRails.application.routes.draw do\n  get \"/articles\", to: \"articles#index\"\n\n  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html\nend\n\nRails.application.routes.draw do\n  get \"/articles\", to: \"articles#index\"\n\n  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html\nend\n\nCopy\n","\n$ bin/rails generate controller Articles index --skip-routes\n\nbin/rails generate controller Articles index --skip-routes\n\nCopy\n","\ncreate  app/controllers/articles_controller.rb\ninvoke  erb\ncreate    app/views/articles\ncreate    app/views/articles/index.html.erb\ninvoke  test_unit\ncreate    test/controllers/articles_controller_test.rb\ninvoke  helper\ncreate    app/helpers/articles_helper.rb\ninvoke    test_unit\ninvoke  assets\ninvoke    scss\ncreate      app/assets/stylesheets/articles.scss\n\ncreate  app/controllers/articles_controller.rb\ninvoke  erb\ncreate    app/views/articles\ncreate    app/views/articles/index.html.erb\ninvoke  test_unit\ncreate    test/controllers/articles_controller_test.rb\ninvoke  helper\ncreate    app/helpers/articles_helper.rb\ninvoke    test_unit\ninvoke  assets\ninvoke    scss\ncreate      app/assets/stylesheets/articles.scss\n\nCopy\n","\nclass ArticlesController < ApplicationController\n  def index\n  end\nend\n\nclass ArticlesController < ApplicationController\n  def index\n  end\nend\n\nCopy\n","\n<h1>Hello, Rails!</h1>\n\n<h1>Hello, Rails!</h1>\n\nCopy\n"],"body":"To get Rails saying \"Hello\", you need to create at minimum a route, a\ncontroller with an action, and a view. A route maps a request to a\ncontroller action. A controller action performs the necessary work to handle the\nrequest, and prepares any data for the view. A view displays data in a desired\nformat.In terms of implementation: Routes are rules written in a Ruby DSL\n(Domain-Specific Language).\nControllers are Ruby classes, and their public methods are actions. And views\nare templates, usually written in a mixture of HTML and Ruby.Let's start by adding a route to our routes file, config/routes.rb, at the\ntop of the Rails.application.routes.draw block:The route above declares that GET /articles requests are mapped to the index\naction of ArticlesController.To create ArticlesController and its index action, we'll run the controller\ngenerator (with the --skip-routes option because we already have an\nappropriate route):Rails will create several files for you:The most important of these is the controller file,\napp/controllers/articles_controller.rb. Let's take a look at it:The index action is empty. When an action does not explicitly render a view\n(or otherwise trigger an HTTP response), Rails will automatically render a view\nthat matches the name of the controller and action. Convention Over\nConfiguration! Views are located in the app/views directory. So the index\naction will render app/views/articles/index.html.erb by default.Let's open app/views/articles/index.html.erb, and replace its contents with:If you previously stopped the web server to run the controller generator,\nrestart it with bin/rails server. Now visit http://localhost:3000/articles,\nand see our text displayed!"},{"title":"4.3 Setting the Application Home Page","anchor":"#setting-the-application-home-page","code":["\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  get \"/articles\", to: \"articles#index\"\nend\n\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  get \"/articles\", to: \"articles#index\"\nend\n\nCopy\n"],"body":"At the moment, http://localhost:3000 still displays \"Yay! You're on Rails!\".\nLet's display our \"Hello, Rails!\" text at http://localhost:3000 as well. To do\nso, we will add a route that maps the root path of our application to the\nappropriate controller and action.Let's open config/routes.rb, and add the following root route to the top of\nthe Rails.application.routes.draw block:Now we can see our \"Hello, Rails!\" text when we visit http://localhost:3000,\nconfirming that the root route is also mapped to the index action of\nArticlesController."},{"title":"5 MVC and You","anchor":"#mvc-and-you","code":[],"body":"So far, we've discussed routes, controllers, actions, and views. All of these\nare typical pieces of a web application that follows the MVC (Model-View-Controller) pattern.\nMVC is a design pattern that divides the responsibilities of an application to\nmake it easier to reason about. Rails follows this design pattern by convention.Since we have a controller and a view to work with, let's generate the next\npiece: a model."},{"title":"5.1 Generating a Model","anchor":"#mvc-and-you-generating-a-model","code":["\n$ bin/rails generate model Article title:string body:text\n\nbin/rails generate model Article title:string body:text\n\nCopy\n","\ninvoke  active_record\ncreate    db/migrate/<timestamp>_create_articles.rb\ncreate    app/models/article.rb\ninvoke    test_unit\ncreate      test/models/article_test.rb\ncreate      test/fixtures/articles.yml\n\ninvoke  active_record\ncreate    db/migrate/<timestamp>_create_articles.rb\ncreate    app/models/article.rb\ninvoke    test_unit\ncreate      test/models/article_test.rb\ncreate      test/fixtures/articles.yml\n\nCopy\n"],"body":"A model is a Ruby class that is used to represent data. Additionally, models\ncan interact with the application's database through a feature of Rails called\nActive Record.To define a model, we will use the model generator:This will create several files:The two files we'll focus on are the migration file\n(db/migrate/<timestamp>_create_articles.rb) and the model file\n(app/models/article.rb)."},{"title":"5.2 Database Migrations","anchor":"#database-migrations","code":["\nclass CreateArticles < ActiveRecord::Migration[6.0]\n  def change\n    create_table :articles do |t|\n      t.string :title\n      t.text :body\n\n      t.timestamps\n    end\n  end\nend\n\nclass CreateArticles < ActiveRecord::Migration[6.0]\n  def change\n    create_table :articles do |t|\n      t.string :title\n      t.text :body\n\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\n$ bin/rails db:migrate\n\nbin/rails db:migrate\n\nCopy\n","\n==  CreateArticles: migrating ===================================\n-- create_table(:articles)\n   -> 0.0018s\n==  CreateArticles: migrated (0.0018s) ==========================\n\n==  CreateArticles: migrating ===================================\n-- create_table(:articles)\n   -> 0.0018s\n==  CreateArticles: migrated (0.0018s) ==========================\n\nCopy\n"],"body":"Migrations are used to alter the structure of an application's database. In\nRails applications, migrations are written in Ruby so that they can be\ndatabase-agnostic.Let's take a look at the contents of our new migration file:The call to create_table specifies how the articles table should be\nconstructed. By default, the create_table method adds an id column as an\nauto-incrementing primary key. So the first record in the table will have an\nid of 1, the next record will have an id of 2, and so on.Inside the block for create_table, two columns are defined: title and\nbody. These were added by the generator because we included them in our\ngenerate command (bin/rails generate model Article title:string body:text).On the last line of the block is a call to t.timestamps. This method defines\ntwo additional columns named created_at and updated_at. As we will see,\nRails will manage these for us, setting the values when we create or update a\nmodel object.Let's run our migration with the following command:The command will display output indicating that the table was created:Now we can interact with the table using our model."},{"title":"5.3 Using a Model to Interact with the Database","anchor":"#using-a-model-to-interact-with-the-database","code":["\n$ bin/rails console\n\nbin/rails console\n\nCopy\n","\nLoading development environment (Rails 6.0.2.1)\nirb(main):001:0>\n\n\nCopy\n","\nirb> article = Article.new(title: \"Hello Rails\", body: \"I am on Rails!\")\n\narticle = Article.new(title: \"Hello Rails\", body: \"I am on Rails!\")\n\nCopy\n","\nirb> article.save\n(0.1ms)  begin transaction\nArticle Create (0.4ms)  INSERT INTO \"articles\" (\"title\", \"body\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?)  [[\"title\", \"Hello Rails\"], [\"body\", \"I am on Rails!\"], [\"created_at\", \"2020-01-18 23:47:30.734416\"], [\"updated_at\", \"2020-01-18 23:47:30.734416\"]]\n(0.9ms)  commit transaction\n=> true\n\narticle.save\n\nCopy\n","\nirb> article\n=> #<Article id: 1, title: \"Hello Rails\", body: \"I am on Rails!\", created_at: \"2020-01-18 23:47:30\", updated_at: \"2020-01-18 23:47:30\">\n\narticle\n\nCopy\n","\nirb> Article.find(1)\n=> #<Article id: 1, title: \"Hello Rails\", body: \"I am on Rails!\", created_at: \"2020-01-18 23:47:30\", updated_at: \"2020-01-18 23:47:30\">\n\nArticle.find(1)\n\nCopy\n","\nirb> Article.all\n=> #<ActiveRecord::Relation [#<Article id: 1, title: \"Hello Rails\", body: \"I am on Rails!\", created_at: \"2020-01-18 23:47:30\", updated_at: \"2020-01-18 23:47:30\">]>\n\nArticle.all\n\nCopy\n"],"body":"To play with our model a bit, we're going to use a feature of Rails called the\nconsole. The console is an interactive coding environment just like irb, but\nit also automatically loads Rails and our application code.Let's launch the console with this command:You should see an irb prompt like:At this prompt, we can initialize a new Article object:It's important to note that we have only initialized this object. This object\nis not saved to the database at all. It's only available in the console at the\nmoment. To save the object to the database, we must call save:The above output shows an INSERT INTO \"articles\" ... database query. This\nindicates that the article has been inserted into our table. And if we take a\nlook at the article object again, we see something interesting has happened:The id, created_at, and updated_at attributes of the object are now set.\nRails did this for us when we saved the object.When we want to fetch this article from the database, we can call find\non the model and pass the id as an argument:And when we want to fetch all articles from the database, we can call all\non the model:This method returns an ActiveRecord::Relation object, which\nyou can think of as a super-powered array.Models are the final piece of the MVC puzzle. Next, we will connect all of the\npieces together."},{"title":"5.4 Showing a List of Articles","anchor":"#showing-a-list-of-articles","code":["\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\nend\n\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\nend\n\nCopy\n","\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= article.title %>\n    </li>\n  <% end %>\n</ul>\n\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= article.title %>\n    </li>\n  <% end %>\n</ul>\n\nCopy\n"],"body":"Let's go back to our controller in app/controllers/articles_controller.rb, and\nchange the index action to fetch all articles from the database:Controller instance variables can be accessed by the view. That means we can\nreference @articles in app/views/articles/index.html.erb. Let's open that\nfile, and replace its contents with:The above code is a mixture of HTML and ERB. ERB is a templating system that\nevaluates Ruby code embedded in a document. Here, we can see two types of ERB\ntags: <% %> and <%= %>. The <% %> tag means \"evaluate the enclosed Ruby\ncode.\" The <%= %> tag means \"evaluate the enclosed Ruby code, and output the\nvalue it returns.\" Anything you could write in a regular Ruby program can go\ninside these ERB tags, though it's usually best to keep the contents of ERB tags\nshort, for readability.Since we don't want to output the value returned by @articles.each, we've\nenclosed that code in <% %>. But, since we do want to output the value\nreturned by article.title (for each article), we've enclosed that code in\n<%= %>.We can see the final result by visiting http://localhost:3000. (Remember that\nbin/rails server must be running!) Here's what happens when we do that:We've connected all the MVC pieces together, and we have our first controller\naction! Next, we'll move on to the second action."},{"title":"6 CRUDit Where CRUDit Is Due","anchor":"#crudit-where-crudit-is-due","code":[],"body":"Almost all web applications involve CRUD (Create, Read, Update, and Delete) operations. You\nmay even find that the majority of the work your application does is CRUD. Rails\nacknowledges this, and provides many features to help simplify code doing CRUD.Let's begin exploring these features by adding more functionality to our\napplication."},{"title":"6.1 Showing a Single Article","anchor":"#showing-a-single-article","code":["\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  get \"/articles\", to: \"articles#index\"\n  get \"/articles/:id\", to: \"articles#show\"\nend\n\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  get \"/articles\", to: \"articles#index\"\n  get \"/articles/:id\", to: \"articles#show\"\nend\n\nCopy\n","\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\nend\n\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\nend\n\nCopy\n","\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\nCopy\n","\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <a href=\"/articles/<%= article.id %>\">\n        <%= article.title %>\n      </a>\n    </li>\n  <% end %>\n</ul>\n\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <a href=\"/articles/<%= article.id %>\">\n        <%= article.title %>\n      </a>\n    </li>\n  <% end %>\n</ul>\n\nCopy\n"],"body":"We currently have a view that lists all articles in our database. Let's add a\nnew view that shows the title and body of a single article.We start by adding a new route that maps to a new controller action (which we\nwill add next). Open config/routes.rb, and insert the last route shown here:The new route is another get route, but it has something extra in its path:\n:id. This designates a route parameter. A route parameter captures a segment\nof the request's path, and puts that value into the params Hash, which is\naccessible by the controller action. For example, when handling a request like\nGET http://localhost:3000/articles/1, 1 would be captured as the value for\n:id, which would then be accessible as params[:id] in the show action of\nArticlesController.Let's add that show action now, below the index action in\napp/controllers/articles_controller.rb:The show action calls Article.find (mentioned\npreviously) with the ID captured\nby the route parameter. The returned article is stored in the @article\ninstance variable, so it is accessible by the view. By default, the show\naction will render app/views/articles/show.html.erb.Let's create app/views/articles/show.html.erb, with the following contents:Now we can see the article when we visit http://localhost:3000/articles/1!To finish up, let's add a convenient way to get to an article's page. We'll link\neach article's title in app/views/articles/index.html.erb to its page:"},{"code":["\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  resources :articles\nend\n\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  resources :articles\nend\n\nCopy\n","\n$ bin/rails routes\n      Prefix Verb   URI Pattern                  Controller#Action\n        root GET    /                            articles#index\n    articles GET    /articles(.:format)          articles#index\n new_article GET    /articles/new(.:format)      articles#new\n     article GET    /articles/:id(.:format)      articles#show\n             POST   /articles(.:format)          articles#create\nedit_article GET    /articles/:id/edit(.:format) articles#edit\n             PATCH  /articles/:id(.:format)      articles#update\n             DELETE /articles/:id(.:format)      articles#destroy\n\nbin/rails routes\n\nCopy\n","\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <a href=\"<%= article_path(article) %>\">\n        <%= article.title %>\n      </a>\n    </li>\n  <% end %>\n</ul>\n\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <a href=\"<%= article_path(article) %>\">\n        <%= article.title %>\n      </a>\n    </li>\n  <% end %>\n</ul>\n\nCopy\n","\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= link_to article.title, article %>\n    </li>\n  <% end %>\n</ul>\n\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= link_to article.title, article %>\n    </li>\n  <% end %>\n</ul>\n\nCopy\n"],"body":"So far, we've covered the \"R\" (Read) of CRUD. We will eventually cover the \"C\"\n(Create), \"U\" (Update), and \"D\" (Delete). As you might have guessed, we will do\nso by adding new routes, controller actions, and views. Whenever we have such a\ncombination of routes, controller actions, and views that work together to\nperform CRUD operations on an entity, we call that entity a resource. For\nexample, in our application, we would say an article is a resource.Rails provides a routes method named resources\nthat maps all of the conventional routes for a collection of resources, such as\narticles. So before we proceed to the \"C\", \"U\", and \"D\" sections, let's replace\nthe two get routes in config/routes.rb with resources:We can inspect what routes are mapped by running the bin/rails routes command:The resources method also sets up URL and path helper methods that we can use\nto keep our code from depending on a specific route configuration. The values\nin the \"Prefix\" column above plus a suffix of _url or _path form the names\nof these helpers. For example, the article_path helper returns\n\"/articles/#{article.id}\" when given an article. We can use it to tidy up our\nlinks in app/views/articles/index.html.erb:However, we will take this one step further by using the link_to\nhelper. The link_to helper renders a link with its first argument as the\nlink's text and its second argument as the link's destination. If we pass a\nmodel object as the second argument, link_to will call the appropriate path\nhelper to convert the object to a path. For example, if we pass an article,\nlink_to will call article_path. So app/views/articles/index.html.erb\nbecomes:Nice!","title":"6.2 Resourceful Routing","anchor":"#resourceful-routing"},{"title":"6.3 Creating a New Article","anchor":"#creating-a-new-article","code":["\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(title: \"...\", body: \"...\")\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\nend\n\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(title: \"...\", body: \"...\")\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\nend\n\nCopy\n"],"body":"Now we move on to the \"C\" (Create) of CRUD. Typically, in web applications,\ncreating a new resource is a multi-step process. First, the user requests a form\nto fill out. Then, the user submits the form. If there are no errors, then the\nresource is created and some kind of confirmation is displayed. Else, the form\nis redisplayed with error messages, and the process is repeated.In a Rails application, these steps are conventionally handled by a controller's\nnew and create actions. Let's add a typical implementation of these actions\nto app/controllers/articles_controller.rb, below the show action:The new action instantiates a new article, but does not save it. This article\nwill be used in the view when building the form. By default, the new action\nwill render app/views/articles/new.html.erb, which we will create next.The create action instantiates a new article with values for the title and\nbody, and attempts to save it. If the article is saved successfully, the action\nredirects the browser to the article's page at \"http://localhost:3000/articles/#{@article.id}\".\nElse, the action redisplays the form by rendering app/views/articles/new.html.erb.\nThe title and body here are dummy values. After we create the form, we will come\nback and change these."},{"title":"6.3.1 Using a Form Builder","anchor":"#using-a-form-builder","code":["\n<h1>New Article</h1>\n\n<%= form_with model: @article do |form| %>\n  <div>\n    <%= form.label :title %><br>\n    <%= form.text_field :title %>\n  </div>\n\n  <div>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </div>\n\n  <div>\n    <%= form.submit %>\n  </div>\n<% end %>\n\n<h1>New Article</h1>\n\n<%= form_with model: @article do |form| %>\n  <div>\n    <%= form.label :title %><br>\n    <%= form.text_field :title %>\n  </div>\n\n  <div>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </div>\n\n  <div>\n    <%= form.submit %>\n  </div>\n<% end %>\n\nCopy\n","\n<form action=\"/articles\" accept-charset=\"UTF-8\" method=\"post\">\n  <input type=\"hidden\" name=\"authenticity_token\" value=\"...\">\n\n  <div>\n    <label for=\"article_title\">Title</label><br>\n    <input type=\"text\" name=\"article[title]\" id=\"article_title\">\n  </div>\n\n  <div>\n    <label for=\"article_body\">Body</label><br>\n    <textarea name=\"article[body]\" id=\"article_body\"></textarea>\n  </div>\n\n  <div>\n    <input type=\"submit\" name=\"commit\" value=\"Create Article\" data-disable-with=\"Create Article\">\n  </div>\n</form>\n\n<form action=\"/articles\" accept-charset=\"UTF-8\" method=\"post\">\n  <input type=\"hidden\" name=\"authenticity_token\" value=\"...\">\n\n  <div>\n    <label for=\"article_title\">Title</label><br>\n    <input type=\"text\" name=\"article[title]\" id=\"article_title\">\n  </div>\n\n  <div>\n    <label for=\"article_body\">Body</label><br>\n    <textarea name=\"article[body]\" id=\"article_body\"></textarea>\n  </div>\n\n  <div>\n    <input type=\"submit\" name=\"commit\" value=\"Create Article\" data-disable-with=\"Create Article\">\n  </div>\n</form>\n\nCopy\n"],"body":"We will use a feature of Rails called a form builder to create our form. Using\na form builder, we can write a minimal amount of code to output a form that is\nfully configured and follows Rails conventions.Let's create app/views/articles/new.html.erb with the following contents:The form_with\nhelper method instantiates a form builder. In the form_with block we call\nmethods like label\nand text_field\non the form builder to output the appropriate form elements.The resulting output from our form_with call will look like:"},{"title":"6.3.2 Using Strong Parameters","anchor":"#using-strong-parameters","code":["\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body)\n    end\nend\n\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body)\n    end\nend\n\nCopy\n"],"body":"Submitted form data is put into the params Hash, alongside captured route\nparameters. Thus, the create action can access the submitted title via\nparams[:article][:title] and the submitted body via params[:article][:body].\nWe could pass these values individually to Article.new, but that would be\nverbose and possibly error-prone. And it would become worse as we add more\nfields.Instead, we will pass a single Hash that contains the values. However, we must\nstill specify what values are allowed in that Hash. Otherwise, a malicious user\ncould potentially submit extra form fields and overwrite private data. In fact,\nif we pass the unfiltered params[:article] Hash directly to Article.new,\nRails will raise a ForbiddenAttributesError to alert us about the problem.\nSo we will use a feature of Rails called Strong Parameters to filter params.\nThink of it as strong typing\nfor params.Let's add a private method to the bottom of app/controllers/articles_controller.rb\nnamed article_params that filters params. And let's change create to use\nit:"},{"title":"6.3.3 Validations and Displaying Error Messages","anchor":"#validations-and-displaying-error-messages","code":["\nclass Article < ApplicationRecord\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nclass Article < ApplicationRecord\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nCopy\n","\n<h1>New Article</h1>\n\n<%= form_with model: @article do |form| %>\n  <div>\n    <%= form.label :title %><br>\n    <%= form.text_field :title %>\n    <% @article.errors.full_messages_for(:title).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %><br>\n    <% @article.errors.full_messages_for(:body).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.submit %>\n  </div>\n<% end %>\n\n<h1>New Article</h1>\n\n<%= form_with model: @article do |form| %>\n  <div>\n    <%= form.label :title %><br>\n    <%= form.text_field :title %>\n    <% @article.errors.full_messages_for(:title).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %><br>\n    <% @article.errors.full_messages_for(:body).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.submit %>\n  </div>\n<% end %>\n\nCopy\n","\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\nCopy\n"],"body":"As we have seen, creating a resource is a multi-step process. Handling invalid\nuser input is another step of that process. Rails provides a feature called\nvalidations to help us deal with invalid user input. Validations are rules\nthat are checked before a model object is saved. If any of the checks fail, the\nsave will be aborted, and appropriate error messages will be added to the\nerrors attribute of the model object.Let's add some validations to our model in app/models/article.rb:The first validation declares that a title value must be present. Because\ntitle is a string, this means that the title value must contain at least one\nnon-whitespace character.The second validation declares that a body value must also be present.\nAdditionally, it declares that the body value must be at least 10 characters\nlong.With our validations in place, let's modify app/views/articles/new.html.erb to\ndisplay any error messages for title and body:The full_messages_for\nmethod returns an array of user-friendly error messages for a specified\nattribute. If there are no errors for that attribute, the array will be empty.To understand how all of this works together, let's take another look at the\nnew and create controller actions:When we visit http://localhost:3000/articles/new, the GET /articles/new\nrequest is mapped to the new action. The new action does not attempt to save\n@article. Therefore, validations are not checked, and there will be no error\nmessages.When we submit the form, the POST /articles request is mapped to the create\naction. The create action does attempt to save @article. Therefore,\nvalidations are checked. If any validation fails, @article will not be\nsaved, and app/views/articles/new.html.erb will be rendered with error\nmessages."},{"title":"6.3.4 Finishing Up","anchor":"#creating-a-new-article-finishing-up","code":["\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= link_to article.title, article %>\n    </li>\n  <% end %>\n</ul>\n\n<%= link_to \"New Article\", new_article_path %>\n\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= link_to article.title, article %>\n    </li>\n  <% end %>\n</ul>\n\n<%= link_to \"New Article\", new_article_path %>\n\nCopy\n"],"body":"We can now create an article by visiting http://localhost:3000/articles/new.\nTo finish up, let's link to that page from the bottom of\napp/views/articles/index.html.erb:"},{"code":["\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\n  def edit\n    @article = Article.find(params[:id])\n  end\n\n  def update\n    @article = Article.find(params[:id])\n\n    if @article.update(article_params)\n      redirect_to @article\n    else\n      render :edit\n    end\n  end\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body)\n    end\nend\n\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\n  def edit\n    @article = Article.find(params[:id])\n  end\n\n  def update\n    @article = Article.find(params[:id])\n\n    if @article.update(article_params)\n      redirect_to @article\n    else\n      render :edit\n    end\n  end\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body)\n    end\nend\n\nCopy\n"],"body":"We've covered the \"CR\" of CRUD. Now let's move on to the \"U\" (Update). Updating\na resource is very similar to creating a resource. They are both multi-step\nprocesses. First, the user requests a form to edit the data. Then, the user\nsubmits the form. If there are no errors, then the resource is updated. Else,\nthe form is redisplayed with error messages, and the process is repeated.These steps are conventionally handled by a controller's edit and update\nactions. Let's add a typical implementation of these actions to\napp/controllers/articles_controller.rb, below the create action:Notice how the edit and update actions resemble the new and create\nactions.The edit action fetches the article from the database, and stores it in\n@article so that it can be used when building the form. By default, the edit\naction will render app/views/articles/edit.html.erb.The update action (re-)fetches the article from the database, and attempts\nto update it with the submitted form data filtered by article_params. If no\nvalidations fail and the update is successful, the action redirects the browser\nto the article's page. Else, the action redisplays the form, with error\nmessages, by rendering app/views/articles/edit.html.erb.","title":"6.4 Updating an Article","anchor":"#updating-an-article"},{"title":"6.4.1 Using Partials to Share View Code","anchor":"#using-partials-to-share-view-code","code":["\n<%= form_with model: article do |form| %>\n  <div>\n    <%= form.label :title %><br>\n    <%= form.text_field :title %>\n    <% article.errors.full_messages_for(:title).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %><br>\n    <% article.errors.full_messages_for(:body).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.submit %>\n  </div>\n<% end %>\n\n<%= form_with model: article do |form| %>\n  <div>\n    <%= form.label :title %><br>\n    <%= form.text_field :title %>\n    <% article.errors.full_messages_for(:title).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %><br>\n    <% article.errors.full_messages_for(:body).each do |message| %>\n      <div><%= message %></div>\n    <% end %>\n  </div>\n\n  <div>\n    <%= form.submit %>\n  </div>\n<% end %>\n\nCopy\n","\n<h1>New Article</h1>\n\n<%= render \"form\", article: @article %>\n\n<h1>New Article</h1>\n\n<%= render \"form\", article: @article %>\n\nCopy\n","\n<h1>Edit Article</h1>\n\n<%= render \"form\", article: @article %>\n\n<h1>Edit Article</h1>\n\n<%= render \"form\", article: @article %>\n\nCopy\n"],"body":"Our edit form will look the same as our new form. Even the code will be the\nsame, thanks to the Rails form builder and resourceful routing. The form builder\nautomatically configures the form to make the appropriate kind of request, based\non whether the model object has been previously saved.Because the code will be the same, we're going to factor it out into a shared\nview called a partial. Let's create app/views/articles/_form.html.erb with\nthe following contents:The above code is the same as our form in app/views/articles/new.html.erb,\nexcept that all occurrences of @article have been replaced with article.\nBecause partials are shared code, it is best practice that they do not depend on\nspecific instance variables set by a controller action. Instead, we will pass\nthe article to the partial as a local variable.Let's update app/views/articles/new.html.erb to use the partial via render:And now, let's create a very similar app/views/articles/edit.html.erb:"},{"title":"6.4.2 Finishing Up","anchor":"#updating-an-article-finishing-up","code":["\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n</ul>\n\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n</ul>\n\nCopy\n"],"body":"We can now update an article by visiting its edit page, e.g.\nhttp://localhost:3000/articles/1/edit. To finish up, let's link to the edit\npage from the bottom of app/views/articles/show.html.erb:"},{"code":["\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\n  def edit\n    @article = Article.find(params[:id])\n  end\n\n  def update\n    @article = Article.find(params[:id])\n\n    if @article.update(article_params)\n      redirect_to @article\n    else\n      render :edit\n    end\n  end\n\n  def destroy\n    @article = Article.find(params[:id])\n    @article.destroy\n\n    redirect_to root_path\n  end\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body)\n    end\nend\n\nclass ArticlesController < ApplicationController\n  def index\n    @articles = Article.all\n  end\n\n  def show\n    @article = Article.find(params[:id])\n  end\n\n  def new\n    @article = Article.new\n  end\n\n  def create\n    @article = Article.new(article_params)\n\n    if @article.save\n      redirect_to @article\n    else\n      render :new\n    end\n  end\n\n  def edit\n    @article = Article.find(params[:id])\n  end\n\n  def update\n    @article = Article.find(params[:id])\n\n    if @article.update(article_params)\n      redirect_to @article\n    else\n      render :edit\n    end\n  end\n\n  def destroy\n    @article = Article.find(params[:id])\n    @article.destroy\n\n    redirect_to root_path\n  end\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body)\n    end\nend\n\nCopy\n","\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\nCopy\n"],"body":"Finally, we arrive at the \"D\" (Delete) of CRUD. Deleting a resource is a simpler\nprocess than creating or updating. It only requires a route and a controller\naction. And our resourceful routing (resources :articles) already provides the\nroute, which maps DELETE /articles/:id requests to the destroy action of\nArticlesController.So, let's add a typical destroy action to app/controllers/articles_controller.rb,\nbelow the update action:The destroy action fetches the article from the database, and calls destroy\non it. Then, it redirects the browser to the root path.We have chosen to redirect to the root path because that is our main access\npoint for articles. But, in other circumstances, you might choose to redirect to\ne.g. articles_path.Now let's add a link at the bottom of app/views/articles/show.html.erb so that\nwe can delete an article from its own page:In the above code, we're passing a few additional options to link_to. The\nmethod: :delete option causes the link to make a DELETE request instead of a\nGET request. The data: { confirm: \"Are you sure?\" } option causes a\nconfirmation dialog to appear when the link is clicked. If the user cancels the\ndialog, the request is aborted. Both of these options are powered by a feature\nof Rails called Unobtrusive JavaScript (UJS). The JavaScript file that\nimplements these behaviors is included by default in fresh Rails applications.And that's it! We can now list, show, create, update, and delete articles!\nInCRUDable!","title":"6.5 Deleting an Article","anchor":"#deleting-an-article"},{"title":"7 Adding a Second Model","anchor":"#adding-a-second-model","code":[],"body":"It's time to add a second model to the application. The second model will handle\ncomments on articles."},{"title":"7.1 Generating a Model","anchor":"#adding-a-second-model-generating-a-model","code":["\n$ bin/rails generate model Comment commenter:string body:text article:references\n\nbin/rails generate model Comment commenter:string body:text article:references\n\nCopy\n","\nclass Comment < ApplicationRecord\n  belongs_to :article\nend\n\nclass Comment < ApplicationRecord\n  belongs_to :article\nend\n\nCopy\n","\nclass CreateComments < ActiveRecord::Migration[6.0]\n  def change\n    create_table :comments do |t|\n      t.string :commenter\n      t.text :body\n      t.references :article, null: false, foreign_key: true\n\n      t.timestamps\n    end\n  end\nend\n\nclass CreateComments < ActiveRecord::Migration[6.0]\n  def change\n    create_table :comments do |t|\n      t.string :commenter\n      t.text :body\n      t.references :article, null: false, foreign_key: true\n\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\n$ bin/rails db:migrate\n\nbin/rails db:migrate\n\nCopy\n","\n==  CreateComments: migrating =================================================\n-- create_table(:comments)\n   -> 0.0115s\n==  CreateComments: migrated (0.0119s) ========================================\n\n==  CreateComments: migrating =================================================\n-- create_table(:comments)\n   -> 0.0115s\n==  CreateComments: migrated (0.0119s) ========================================\n\nCopy\n"],"body":"We're going to see the same generator that we used before when creating\nthe Article model. This time we'll create a Comment model to hold a\nreference to an article. Run this command in your terminal:This command will generate four files:First, take a look at app/models/comment.rb:This is very similar to the Article model that you saw earlier. The difference\nis the line belongs_to :article, which sets up an Active Record association.\nYou'll learn a little about associations in the next section of this guide.The (:references) keyword used in the bash command is a special data type for models.\nIt creates a new column on your database table with the provided model name appended with an _id\nthat can hold integer values. To get a better understanding, analyze the\ndb/schema.rb file after running the migration.In addition to the model, Rails has also made a migration to create the\ncorresponding database table:The t.references line creates an integer column called article_id, an index\nfor it, and a foreign key constraint that points to the id column of the articles\ntable. Go ahead and run the migration:Rails is smart enough to only execute the migrations that have not already been\nrun against the current database, so in this case you will just see:"},{"code":["\nclass Comment < ApplicationRecord\n  belongs_to :article\nend\n\nclass Comment < ApplicationRecord\n  belongs_to :article\nend\n\nCopy\n","\nclass Article < ApplicationRecord\n  has_many :comments\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nclass Article < ApplicationRecord\n  has_many :comments\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nCopy\n"],"body":"Active Record associations let you easily declare the relationship between two\nmodels. In the case of comments and articles, you could write out the\nrelationships this way:In fact, this is very close to the syntax that Rails uses to declare this\nassociation. You've already seen the line of code inside the Comment model\n(app/models/comment.rb) that makes each comment belong to an Article:You'll need to edit app/models/article.rb to add the other side of the\nassociation:These two declarations enable a good bit of automatic behavior. For example, if\nyou have an instance variable @article containing an article, you can retrieve\nall the comments belonging to that article as an array using\n@article.comments.","title":"7.2 Associating Models","anchor":"#associating-models"},{"title":"7.3 Adding a Route for Comments","anchor":"#adding-a-route-for-comments","code":["\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  resources :articles do\n    resources :comments\n  end\nend\n\nRails.application.routes.draw do\n  root \"articles#index\"\n\n  resources :articles do\n    resources :comments\n  end\nend\n\nCopy\n"],"body":"As with the welcome controller, we will need to add a route so that Rails\nknows where we would like to navigate to see comments. Open up the\nconfig/routes.rb file again, and edit it as follows:This creates comments as a nested resource within articles. This is\nanother part of capturing the hierarchical relationship that exists between\narticles and comments."},{"title":"7.4 Generating a Controller","anchor":"#generating-a-controller","code":["\n$ bin/rails generate controller Comments\n\nbin/rails generate controller Comments\n\nCopy\n","\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Add a comment:</h2>\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Add a comment:</h2>\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\nCopy\n","\nclass CommentsController < ApplicationController\n  def create\n    @article = Article.find(params[:article_id])\n    @comment = @article.comments.create(comment_params)\n    redirect_to article_path(@article)\n  end\n\n  private\n    def comment_params\n      params.require(:comment).permit(:commenter, :body)\n    end\nend\n\nclass CommentsController < ApplicationController\n  def create\n    @article = Article.find(params[:article_id])\n    @comment = @article.comments.create(comment_params)\n    redirect_to article_path(@article)\n  end\n\n  private\n    def comment_params\n      params.require(:comment).permit(:commenter, :body)\n    end\nend\n\nCopy\n","\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Comments</h2>\n<% @article.comments.each do |comment| %>\n  <p>\n    <strong>Commenter:</strong>\n    <%= comment.commenter %>\n  </p>\n\n  <p>\n    <strong>Comment:</strong>\n    <%= comment.body %>\n  </p>\n<% end %>\n\n<h2>Add a comment:</h2>\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Comments</h2>\n<% @article.comments.each do |comment| %>\n  <p>\n    <strong>Commenter:</strong>\n    <%= comment.commenter %>\n  </p>\n\n  <p>\n    <strong>Comment:</strong>\n    <%= comment.body %>\n  </p>\n<% end %>\n\n<h2>Add a comment:</h2>\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\nCopy\n"],"body":"With the model in hand, you can turn your attention to creating a matching\ncontroller. Again, we'll use the same generator we used before:This creates four files and one empty directory:Like with any blog, our readers will create their comments directly after\nreading the article, and once they have added their comment, will be sent back\nto the article show page to see their comment now listed. Due to this, our\nCommentsController is there to provide a method to create comments and delete\nspam comments when they arrive.So first, we'll wire up the Article show template\n(app/views/articles/show.html.erb) to let us make a new comment:This adds a form on the Article show page that creates a new comment by\ncalling the CommentsController create action. The form_with call here uses\nan array, which will build a nested route, such as /articles/1/comments.Let's wire up the create in app/controllers/comments_controller.rb:You'll see a bit more complexity here than you did in the controller for\narticles. That's a side-effect of the nesting that you've set up. Each request\nfor a comment has to keep track of the article to which the comment is attached,\nthus the initial call to the find method of the Article model to get the\narticle in question.In addition, the code takes advantage of some of the methods available for an\nassociation. We use the create method on @article.comments to create and\nsave the comment. This will automatically link the comment so that it belongs to\nthat particular article.Once we have made the new comment, we send the user back to the original article\nusing the article_path(@article) helper. As we have already seen, this calls\nthe show action of the ArticlesController which in turn renders the\nshow.html.erb template. This is where we want the comment to show, so let's\nadd that to the app/views/articles/show.html.erb.Now you can add articles and comments to your blog and have them show up in the\nright places."},{"title":"8 Refactoring","anchor":"#refactoring","code":[],"body":"Now that we have articles and comments working, take a look at the\napp/views/articles/show.html.erb template. It is getting long and awkward. We\ncan use partials to clean it up."},{"title":"8.1 Rendering Partial Collections","anchor":"#rendering-partial-collections","code":["\n<p>\n  <strong>Commenter:</strong>\n  <%= comment.commenter %>\n</p>\n\n<p>\n  <strong>Comment:</strong>\n  <%= comment.body %>\n</p>\n\n<p>\n  <strong>Commenter:</strong>\n  <%= comment.commenter %>\n</p>\n\n<p>\n  <strong>Comment:</strong>\n  <%= comment.body %>\n</p>\n\nCopy\n","\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Comments</h2>\n<%= render @article.comments %>\n\n<h2>Add a comment:</h2>\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Comments</h2>\n<%= render @article.comments %>\n\n<h2>Add a comment:</h2>\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\nCopy\n"],"body":"First, we will make a comment partial to extract showing all the comments for\nthe article. Create the file app/views/comments/_comment.html.erb and put the\nfollowing into it:Then you can change app/views/articles/show.html.erb to look like the\nfollowing:This will now render the partial in app/views/comments/_comment.html.erb once\nfor each comment that is in the @article.comments collection. As the render\nmethod iterates over the @article.comments collection, it assigns each\ncomment to a local variable named the same as the partial, in this case\ncomment, which is then available in the partial for us to show."},{"title":"8.2 Rendering a Partial Form","anchor":"#rendering-a-partial-form","code":["\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\n<%= form_with model: [ @article, @article.comments.build ] do |form| %>\n  <p>\n    <%= form.label :commenter %><br>\n    <%= form.text_field :commenter %>\n  </p>\n  <p>\n    <%= form.label :body %><br>\n    <%= form.text_area :body %>\n  </p>\n  <p>\n    <%= form.submit %>\n  </p>\n<% end %>\n\nCopy\n","\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Comments</h2>\n<%= render @article.comments %>\n\n<h2>Add a comment:</h2>\n<%= render 'comments/form' %>\n\n<h1><%= @article.title %></h1>\n\n<p><%= @article.body %></p>\n\n<ul>\n  <li><%= link_to \"Edit\", edit_article_path(@article) %></li>\n  <li><%= link_to \"Destroy\", article_path(@article),\n                  method: :delete,\n                  data: { confirm: \"Are you sure?\" } %></li>\n</ul>\n\n<h2>Comments</h2>\n<%= render @article.comments %>\n\n<h2>Add a comment:</h2>\n<%= render 'comments/form' %>\n\nCopy\n"],"body":"Let us also move that new comment section out to its own partial. Again, you\ncreate a file app/views/comments/_form.html.erb containing:Then you make the app/views/articles/show.html.erb look like the following:The second render just defines the partial template we want to render,\ncomments/form. Rails is smart enough to spot the forward slash in that\nstring and realize that you want to render the _form.html.erb file in\nthe app/views/comments directory.The @article object is available to any partials rendered in the view because\nwe defined it as an instance variable."},{"title":"8.3 Using Concerns","anchor":"#using-concerns","code":["\napp/controllers/concerns\napp/models/concerns\n\napp/controllers/concerns\napp/models/concerns\n\nCopy\n","\nclass Article < ApplicationRecord\n  has_many :comments\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  validates :status, inclusion: { in: VALID_STATUSES }\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nclass Article < ApplicationRecord\n  has_many :comments\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  validates :status, inclusion: { in: VALID_STATUSES }\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nCopy\n","\nclass Comment < ApplicationRecord\n  belongs_to :article\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  validates :status, inclusion: { in: VALID_STATUSES }\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nclass Comment < ApplicationRecord\n  belongs_to :article\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  validates :status, inclusion: { in: VALID_STATUSES }\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nCopy\n","\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <% unless article.archived? %>\n      <li>\n        <%= link_to article.title, article %>\n      </li>\n    <% end %>\n  <% end %>\n</ul>\n\n<%= link_to \"New Article\", new_article_path %>\n\n<h1>Articles</h1>\n\n<ul>\n  <% @articles.each do |article| %>\n    <% unless article.archived? %>\n      <li>\n        <%= link_to article.title, article %>\n      </li>\n    <% end %>\n  <% end %>\n</ul>\n\n<%= link_to \"New Article\", new_article_path %>\n\nCopy\n","\nmodule Visible\n  def archived?\n    status == 'archived'\n  end\nend\n\nmodule Visible\n  def archived?\n    status == 'archived'\n  end\nend\n\nCopy\n","\nmodule Visible\n  extend ActiveSupport::Concern\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  included do\n    validates :status, inclusion: { in: VALID_STATUSES }\n  end\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nmodule Visible\n  extend ActiveSupport::Concern\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  included do\n    validates :status, inclusion: { in: VALID_STATUSES }\n  end\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nCopy\n","\nclass Article < ApplicationRecord\n  include Visible\n  has_many :comments\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nclass Article < ApplicationRecord\n  include Visible\n  has_many :comments\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nCopy\n","\nclass Comment < ApplicationRecord\n  include Visible\n  belongs_to :article\nend\n\nclass Comment < ApplicationRecord\n  include Visible\n  belongs_to :article\nend\n\nCopy\n","\nmodule Visible\n  extend ActiveSupport::Concern\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  included do\n    validates :status, inclusion: { in: VALID_STATUSES }\n  end\n\n  class_methods do\n    def public_count\n      where(status: 'public').count\n    end\n  end\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nmodule Visible\n  extend ActiveSupport::Concern\n\n  VALID_STATUSES = ['public', 'private', 'archived']\n\n  included do\n    validates :status, inclusion: { in: VALID_STATUSES }\n  end\n\n  class_methods do\n    def public_count\n      where(status: 'public').count\n    end\n  end\n\n  def archived?\n    status == 'archived'\n  end\nend\n\nCopy\n","\n<h1>Articles</h1>\n\nOur blog has <%= Article.public_count %> articles and counting!\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= link_to article.title, article %>\n    </li>\n  <% end %>\n</ul>\n\n<%= link_to \"New Article\", new_article_path %>\n\n<h1>Articles</h1>\n\nOur blog has <%= Article.public_count %> articles and counting!\n\n<ul>\n  <% @articles.each do |article| %>\n    <li>\n      <%= link_to article.title, article %>\n    </li>\n  <% end %>\n</ul>\n\n<%= link_to \"New Article\", new_article_path %>\n\nCopy\n","\n$ bin/rails generate migration AddStatusToArticles status:string\n$ bin/rails generate migration AddStatusToComments status:string\n\nbin/rails generate migration AddStatusToArticles status:string\nbin/rails generate migration AddStatusToComments status:string\n\nCopy\n","\nprivate\n    def article_params\n      params.require(:article).permit(:title, :body, :status)\n    end\n\nprivate\n    def article_params\n      params.require(:article).permit(:title, :body, :status)\n    end\n\nCopy\n","\nprivate\n    def comment_params\n      params.require(:comment).permit(:commenter, :body, :status)\n    end\n\nprivate\n    def comment_params\n      params.require(:comment).permit(:commenter, :body, :status)\n    end\n\nCopy\n","\n<div>\n  <%= form.label :status %><br>\n  <%= form.select :status, ['public', 'private', 'archived'], selected: 'public' %>\n</div>\n\n<div>\n  <%= form.label :status %><br>\n  <%= form.select :status, ['public', 'private', 'archived'], selected: 'public' %>\n</div>\n\nCopy\n","\n<p>\n  <%= form.label :status %><br>\n  <%= form.select :status, ['public', 'private', 'archived'], selected: 'public' %>\n</p>\n\n<p>\n  <%= form.label :status %><br>\n  <%= form.select :status, ['public', 'private', 'archived'], selected: 'public' %>\n</p>\n\nCopy\n"],"body":"Concerns are a way to make large controllers or models easier to understand and manage. This also has the advantage of reusability when multiple models (or controllers) share the same concerns. Concerns are implemented using modules that contain methods representing a well-defined slice of the functionality that a model or controller is responsible for. In other languages, modules are often known as mixins.You can use concerns in your controller or model the same way you would use any module. When you first created your app with rails new blog, two folders were created within app/ along with the rest:A given blog article might have various statuses - for instance, it might be visible to everyone (i.e. public), or only visible to the author (i.e. private). It may also be hidden to all but still retrievable (i.e. archived). Comments may similarly be hidden or visible. This could be represented using a status column in each model.Within the article model, after running a migration to add a status column, you might add:and in the Comment model:Then, in our index action template (app/views/articles/index.html.erb) we would use the archived? method to avoid displaying any article that is archived:However, if you look again at our models now, you can see that the logic is duplicated. If in the future we increase the functionality of our blog - to include private messages, for instance -  we might find ourselves duplicating the logic yet again. This is where concerns come in handy.A concern is only responsible for a focused subset of the model's responsibility; the methods in our concern will all be related to the visibility of a model. Let's call our new concern (module) Visible. We can create a new file inside app/models/concerns called visible.rb , and store all of the status methods that were duplicated in the models.app/models/concerns/visible.rbWe can add our status validation to the concern, but this is slightly more complex as validations are methods called at the class level. The ActiveSupport::Concern (API Guide) gives us a simpler way to include them:Now, we can remove the duplicated logic from each model and instead include our new Visible module:In app/models/article.rb:and in app/models/comment.rb:Class methods can also be added to concerns. If we want a count of public articles or comments to display on our main page, we might add a class method to Visible as follows:Then in the view, you can call it like any class method:There are a few more steps to be carried out before our application works with the addition of status column. First, let's run the following migrations to add status to Articles and Comments:We also have to permit the :status key as part of the strong parameter, in app/controllers/articles_controller.rb:and in app/controllers/comments_controller.rb:To finish up, we will add a select box to the forms, and let the user select the status when they create a new article or post a new comment. We can also specify the default status as public. In app/views/articles/_form.html.erb, we can add:and in app/views/comments/_form.html.erb:"},{"code":["\n<p>\n  <strong>Commenter:</strong>\n  <%= comment.commenter %>\n</p>\n\n<p>\n  <strong>Comment:</strong>\n  <%= comment.body %>\n</p>\n\n<p>\n  <%= link_to 'Destroy Comment', [comment.article, comment],\n              method: :delete,\n              data: { confirm: \"Are you sure?\" } %>\n</p>\n\n<p>\n  <strong>Commenter:</strong>\n  <%= comment.commenter %>\n</p>\n\n<p>\n  <strong>Comment:</strong>\n  <%= comment.body %>\n</p>\n\n<p>\n  <%= link_to 'Destroy Comment', [comment.article, comment],\n              method: :delete,\n              data: { confirm: \"Are you sure?\" } %>\n</p>\n\nCopy\n","\nclass CommentsController < ApplicationController\n  def create\n    @article = Article.find(params[:article_id])\n    @comment = @article.comments.create(comment_params)\n    redirect_to article_path(@article)\n  end\n\n  def destroy\n    @article = Article.find(params[:article_id])\n    @comment = @article.comments.find(params[:id])\n    @comment.destroy\n    redirect_to article_path(@article)\n  end\n\n  private\n    def comment_params\n      params.require(:comment).permit(:commenter, :body)\n    end\nend\n\nclass CommentsController < ApplicationController\n  def create\n    @article = Article.find(params[:article_id])\n    @comment = @article.comments.create(comment_params)\n    redirect_to article_path(@article)\n  end\n\n  def destroy\n    @article = Article.find(params[:article_id])\n    @comment = @article.comments.find(params[:id])\n    @comment.destroy\n    redirect_to article_path(@article)\n  end\n\n  private\n    def comment_params\n      params.require(:comment).permit(:commenter, :body)\n    end\nend\n\nCopy\n"],"body":"Another important feature of a blog is being able to delete spam comments. To do\nthis, we need to implement a link of some sort in the view and a destroy\naction in the CommentsController.So first, let's add the delete link in the\napp/views/comments/_comment.html.erb partial:Clicking this new \"Destroy Comment\" link will fire off a DELETE\n/articles/:article_id/comments/:id to our CommentsController, which can then\nuse this to find the comment we want to delete, so let's add a destroy action\nto our controller (app/controllers/comments_controller.rb):The destroy action will find the article we are looking at, locate the comment\nwithin the @article.comments collection, and then remove it from the\ndatabase and send us back to the show action for the article.","title":"9 Deleting Comments","anchor":"#deleting-comments"},{"title":"9.1 Deleting Associated Objects","anchor":"#deleting-associated-objects","code":["\nclass Article < ApplicationRecord\n  include Visible\n\n  has_many :comments, dependent: :destroy\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nclass Article < ApplicationRecord\n  include Visible\n\n  has_many :comments, dependent: :destroy\n\n  validates :title, presence: true\n  validates :body, presence: true, length: { minimum: 10 }\nend\n\nCopy\n"],"body":"If you delete an article, its associated comments will also need to be\ndeleted, otherwise they would simply occupy space in the database. Rails allows\nyou to use the dependent option of an association to achieve this. Modify the\nArticle model, app/models/article.rb, as follows:"},{"code":[],"body":"","title":"10 Security","anchor":"#security"},{"title":"10.1 Basic Authentication","anchor":"#basic-authentication","code":["\nclass ArticlesController < ApplicationController\n\n  http_basic_authenticate_with name: \"dhh\", password: \"secret\", except: [:index, :show]\n\n  def index\n    @articles = Article.all\n  end\n\n  # snippet for brevity\n\nclass ArticlesController < ApplicationController\n\n  http_basic_authenticate_with name: \"dhh\", password: \"secret\", except: [:index, :show]\n\n  def index\n    @articles = Article.all\n  end\n\n  # snippet for brevity\n\nCopy\n","\nclass CommentsController < ApplicationController\n\n  http_basic_authenticate_with name: \"dhh\", password: \"secret\", only: :destroy\n\n  def create\n    @article = Article.find(params[:article_id])\n    # ...\n  end\n\n  # snippet for brevity\n\nclass CommentsController < ApplicationController\n\n  http_basic_authenticate_with name: \"dhh\", password: \"secret\", only: :destroy\n\n  def create\n    @article = Article.find(params[:article_id])\n    # ...\n  end\n\n  # snippet for brevity\n\nCopy\n"],"body":"If you were to publish your blog online, anyone would be able to add, edit and\ndelete articles or delete comments.Rails provides an HTTP authentication system that will work nicely in\nthis situation.In the ArticlesController we need to have a way to block access to the\nvarious actions if the person is not authenticated. Here we can use the Rails\nhttp_basic_authenticate_with method, which allows access to the requested\naction if that method allows it.To use the authentication system, we specify it at the top of our\nArticlesController in app/controllers/articles_controller.rb. In our case,\nwe want the user to be authenticated on every action except index and show,\nso we write that:We also want to allow only authenticated users to delete comments, so in the\nCommentsController (app/controllers/comments_controller.rb) we write:Now if you try to create a new article, you will be greeted with a basic HTTP\nAuthentication challenge:Other authentication methods are available for Rails applications. Two popular\nauthentication add-ons for Rails are the\nDevise rails engine and\nthe Authlogic gem,\nalong with a number of others."},{"title":"10.2 Other Security Considerations","anchor":"#other-security-considerations","code":[],"body":"Security, especially in web applications, is a broad and detailed area. Security\nin your Rails application is covered in more depth in\nthe Ruby on Rails Security Guide."},{"title":"11 What's Next?","anchor":"#what-s-next-questionmark","code":[],"body":"Now that you've seen your first Rails application, you should feel free to\nupdate it and experiment on your own.Remember, you don't have to do everything without help. As you need assistance\ngetting up and running with Rails, feel free to consult these support\nresources:"},{"code":[],"body":"The easiest way to work with Rails is to store all external data as UTF-8. If\nyou don't, Ruby libraries and Rails will often be able to convert your native\ndata into UTF-8, but this doesn't always work reliably, so you're better off\nensuring that all external data is UTF-8.If you have made a mistake in this area, the most common symptom is a black\ndiamond with a question mark inside appearing in the browser. Another common\nsymptom is characters like \"\" appearing instead of \"\". Rails takes a number\nof internal steps to mitigate common causes of these problems that can be\nautomatically detected and corrected. However, if you have external data that is\nnot stored as UTF-8, it can occasionally result in these kinds of issues that\ncannot be automatically detected by Rails and corrected.Two very common sources of data that are not UTF-8:","title":"12 Configuration Gotchas","anchor":"#configuration-gotchas"}]