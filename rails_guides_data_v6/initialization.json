[{"code":[],"body":"This guide goes through every method call that is\nrequired to boot up the Ruby on Rails stack for a default Rails\napplication, explaining each part in detail along the way. For this\nguide, we will be focusing on what happens when you execute bin/rails server\nto boot your app.Let's start to boot and initialize the app. A Rails application is usually\nstarted by running bin/rails console or bin/rails server.","title":"1 Launch!","anchor":"#launch-bang"},{"title":"1.1 bin/rails","anchor":"#bin-rails","code":["\n#!/usr/bin/env ruby\nAPP_PATH = File.expand_path('../config/application', __dir__)\nrequire_relative \"../config/boot\"\nrequire \"rails/commands\"\n\n#!/usr/bin/env ruby\nAPP_PATH = File.expand_path('../config/application', __dir__)\nrequire_relative \"../config/boot\"\nrequire \"rails/commands\"\n\nCopy\n"],"body":"This file is as follows:The APP_PATH constant will be used later in rails/commands. The config/boot file referenced here is the config/boot.rb file in our application which is responsible for loading Bundler and setting it up."},{"title":"1.2 config/boot.rb","anchor":"#config-boot-rb","code":["\nENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)\n\nrequire \"bundler/setup\" # Set up gems listed in the Gemfile.\n\nENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)\n\nrequire \"bundler/setup\" # Set up gems listed in the Gemfile.\n\nCopy\n"],"body":"config/boot.rb contains:In a standard Rails application, there's a Gemfile which declares all\ndependencies of the application. config/boot.rb sets\nENV['BUNDLE_GEMFILE'] to the location of this file. If the Gemfile\nexists, then bundler/setup is required. The require is used by Bundler to\nconfigure the load path for your Gemfile's dependencies.A standard Rails application depends on several gems, specifically:"},{"code":["\nrequire \"rails/command\"\n\naliases = {\n  \"g\"  => \"generate\",\n  \"d\"  => \"destroy\",\n  \"c\"  => \"console\",\n  \"s\"  => \"server\",\n  \"db\" => \"dbconsole\",\n  \"r\"  => \"runner\",\n  \"t\"  => \"test\"\n}\n\ncommand = ARGV.shift\ncommand = aliases[command] || command\n\nRails::Command.invoke command, ARGV\n\nrequire \"rails/command\"\n\naliases = {\n  \"g\"  => \"generate\",\n  \"d\"  => \"destroy\",\n  \"c\"  => \"console\",\n  \"s\"  => \"server\",\n  \"db\" => \"dbconsole\",\n  \"r\"  => \"runner\",\n  \"t\"  => \"test\"\n}\n\ncommand = ARGV.shift\ncommand = aliases[command] || command\n\nRails::Command.invoke command, ARGV\n\nCopy\n"],"body":"Once config/boot.rb has finished, the next file that is required is\nrails/commands, which helps in expanding aliases. In the current case, the\nARGV array simply contains server which will be passed over:If we had used s rather than server, Rails would have used the aliases\ndefined here to find the matching command.","title":"1.3 rails/commands.rb","anchor":"#rails-commands-rb"},{"title":"1.4 rails/command.rb","anchor":"#rails-command-rb","code":["\nmodule Rails\n  module Command\n    class << self\n      def invoke(full_namespace, args = [], **config)\n        namespace = full_namespace = full_namespace.to_s\n\n        if char = namespace =~ /:(\\w+)$/\n          command_name, namespace = $1, namespace.slice(0, char)\n        else\n          command_name = namespace\n        end\n\n        command_name, namespace = \"help\", \"help\" if command_name.blank? || HELP_MAPPINGS.include?(command_name)\n        command_name, namespace = \"version\", \"version\" if %w( -v --version ).include?(command_name)\n\n        command = find_by_namespace(namespace, command_name)\n        if command && command.all_commands[command_name]\n          command.perform(command_name, args, config)\n        else\n          find_by_namespace(\"rake\").perform(full_namespace, args, config)\n        end\n      end\n    end\n  end\nend\n\nmodule Rails\n  module Command\n    class << self\n      def invoke(full_namespace, args = [], **config)\n        namespace = full_namespace = full_namespace.to_s\n\n        if char = namespace =~ /:(\\w+)$/\n          command_name, namespace = $1, namespace.slice(0, char)\n        else\n          command_name = namespace\n        end\n\n        command_name, namespace = \"help\", \"help\" if command_name.blank? || HELP_MAPPINGS.include?(command_name)\n        command_name, namespace = \"version\", \"version\" if %w( -v --version ).include?(command_name)\n\n        command = find_by_namespace(namespace, command_name)\n        if command && command.all_commands[command_name]\n          command.perform(command_name, args, config)\n        else\n          find_by_namespace(\"rake\").perform(full_namespace, args, config)\n        end\n      end\n    end\n  end\nend\n\nCopy\n","\nmodule Rails\n  module Command\n    class ServerCommand < Base # :nodoc:\n      def perform\n        extract_environment_option_from_argument\n        set_application_directory!\n        prepare_restart\n\n        Rails::Server.new(server_options).tap do |server|\n          # Require application after server sets environment to propagate\n          # the --environment option.\n          require APP_PATH\n          Dir.chdir(Rails.application.root)\n\n          if server.serveable?\n            print_boot_information(server.server, server.served_url)\n            after_stop_callback = -> { say \"Exiting\" unless options[:daemon] }\n            server.start(after_stop_callback)\n          else\n            say rack_server_suggestion(using)\n          end\n        end\n      end\n    end\n  end\nend\n\nmodule Rails\n  module Command\n    class ServerCommand < Base # :nodoc:\n      def perform\n        extract_environment_option_from_argument\n        set_application_directory!\n        prepare_restart\n\n        Rails::Server.new(server_options).tap do |server|\n          # Require application after server sets environment to propagate\n          # the --environment option.\n          require APP_PATH\n          Dir.chdir(Rails.application.root)\n\n          if server.serveable?\n            print_boot_information(server.server, server.served_url)\n            after_stop_callback = -> { say \"Exiting\" unless options[:daemon] }\n            server.start(after_stop_callback)\n          else\n            say rack_server_suggestion(using)\n          end\n        end\n      end\n    end\n  end\nend\n\nCopy\n"],"body":"When one types a Rails command, invoke tries to lookup a command for the given\nnamespace and executes the command if found.If Rails doesn't recognize the command, it hands the reins over to Rake\nto run a task of the same name.As shown, Rails::Command displays the help output automatically if the namespace\nis empty.With the server command, Rails will further run the following code:This file will change into the Rails root directory (a path two directories up\nfrom APP_PATH which points at config/application.rb), but only if the\nconfig.ru file isn't found. This then starts up the Rails::Server class."},{"title":"1.5 actionpack/lib/action_dispatch.rb","anchor":"#actionpack-lib-action-dispatch-rb","code":[],"body":"Action Dispatch is the routing component of the Rails framework.\nIt adds functionality like routing, session, and common middlewares."},{"title":"1.6 rails/commands/server/server_command.rb","anchor":"#rails-commands-server-server-command-rb","code":["\nmodule Rails\n  class Server < ::Rack::Server\n    def initialize(options = nil)\n      @default_options = options || {}\n      super(@default_options)\n      set_environment\n    end\n  end\nend\n\nmodule Rails\n  class Server < ::Rack::Server\n    def initialize(options = nil)\n      @default_options = options || {}\n      super(@default_options)\n      set_environment\n    end\n  end\nend\n\nCopy\n"],"body":"The Rails::Server class is defined in this file by inheriting from\nRack::Server. When Rails::Server.new is called, this calls the initialize\nmethod in rails/commands/server/server_command.rb:Firstly, super is called which calls the initialize method on Rack::Server."},{"title":"1.7 Rack: lib/rack/server.rb","anchor":"#launch-bang-rack-lib-rack-server-rb","code":["\nmodule Rack\n  class Server\n    def initialize(options = nil)\n      @ignore_options = []\n\n      if options\n        @use_default_options = false\n        @options = options\n        @app = options[:app] if options[:app]\n      else\n        argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV\n        @use_default_options = true\n        @options = parse_options(argv)\n      end\n    end\n  end\nend\n\nmodule Rack\n  class Server\n    def initialize(options = nil)\n      @ignore_options = []\n\n      if options\n        @use_default_options = false\n        @options = options\n        @app = options[:app] if options[:app]\n      else\n        argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV\n        @use_default_options = true\n        @options = parse_options(argv)\n      end\n    end\n  end\nend\n\nCopy\n","\nmodule Rails\n  module Command\n    class ServerCommand\n      no_commands do\n        def server_options\n          {\n            user_supplied_options: user_supplied_options,\n            server:                using,\n            log_stdout:            log_to_stdout?,\n            Port:                  port,\n            Host:                  host,\n            DoNotReverseLookup:    true,\n            config:                options[:config],\n            environment:           environment,\n            daemonize:             options[:daemon],\n            pid:                   pid,\n            caching:               options[:dev_caching],\n            restart_cmd:           restart_command,\n            early_hints:           early_hints\n          }\n        end\n      end\n    end\n  end\nend\n\nmodule Rails\n  module Command\n    class ServerCommand\n      no_commands do\n        def server_options\n          {\n            user_supplied_options: user_supplied_options,\n            server:                using,\n            log_stdout:            log_to_stdout?,\n            Port:                  port,\n            Host:                  host,\n            DoNotReverseLookup:    true,\n            config:                options[:config],\n            environment:           environment,\n            daemonize:             options[:daemon],\n            pid:                   pid,\n            caching:               options[:dev_caching],\n            restart_cmd:           restart_command,\n            early_hints:           early_hints\n          }\n        end\n      end\n    end\n  end\nend\n\nCopy\n","\nmodule Rails\n  module Server\n    def set_environment\n      ENV[\"RAILS_ENV\"] ||= options[:environment]\n    end\n  end\nend\n\nmodule Rails\n  module Server\n    def set_environment\n      ENV[\"RAILS_ENV\"] ||= options[:environment]\n    end\n  end\nend\n\nCopy\n"],"body":"Rack::Server is responsible for providing a common server interface for all Rack-based applications, which Rails is now a part of.The initialize method in Rack::Server simply sets several variables:In this case, return value of Rails::Command::ServerCommand#server_options will be assigned to options.\nWhen lines inside if statement is evaluated, a couple of instance variables will be set.server_options method in Rails::Command::ServerCommand is defined as follows:The value will be assigned to instance variable @options.After super has finished in Rack::Server, we jump back to\nrails/commands/server/server_command.rb. At this point, set_environment\nis called within the context of the Rails::Server object.After initialize has finished, we jump back into the server command\nwhere APP_PATH (which was set earlier) is required."},{"title":"1.8 config/application","anchor":"#config-application","code":[],"body":"When require APP_PATH is executed, config/application.rb is loaded (recall\nthat APP_PATH is defined in bin/rails). This file exists in your application\nand it's free for you to change based on your needs."},{"title":"1.9 Rails::Server#start","anchor":"#rails-server-start","code":["\nmodule Rails\n  class Server < ::Rack::Server\n    def start(after_stop_callback = nil)\n      trap(:INT) { exit }\n      create_tmp_directories\n      setup_dev_caching\n      log_to_stdout if options[:log_stdout]\n\n      super()\n      # ...\n    end\n\n    private\n      def setup_dev_caching\n        if options[:environment] == \"development\"\n          Rails::DevCaching.enable_by_argument(options[:caching])\n        end\n      end\n\n      def create_tmp_directories\n        %w(cache pids sockets).each do |dir_to_make|\n          FileUtils.mkdir_p(File.join(Rails.root, \"tmp\", dir_to_make))\n        end\n      end\n\n      def log_to_stdout\n        wrapped_app # touch the app so the logger is set up\n\n        console = ActiveSupport::Logger.new(STDOUT)\n        console.formatter = Rails.logger.formatter\n        console.level = Rails.logger.level\n\n        unless ActiveSupport::Logger.logger_outputs_to?(Rails.logger, STDOUT)\n          Rails.logger.extend(ActiveSupport::Logger.broadcast(console))\n        end\n      end\n  end\nend\n\nmodule Rails\n  class Server < ::Rack::Server\n    def start(after_stop_callback = nil)\n      trap(:INT) { exit }\n      create_tmp_directories\n      setup_dev_caching\n      log_to_stdout if options[:log_stdout]\n\n      super()\n      # ...\n    end\n\n    private\n      def setup_dev_caching\n        if options[:environment] == \"development\"\n          Rails::DevCaching.enable_by_argument(options[:caching])\n        end\n      end\n\n      def create_tmp_directories\n        %w(cache pids sockets).each do |dir_to_make|\n          FileUtils.mkdir_p(File.join(Rails.root, \"tmp\", dir_to_make))\n        end\n      end\n\n      def log_to_stdout\n        wrapped_app # touch the app so the logger is set up\n\n        console = ActiveSupport::Logger.new(STDOUT)\n        console.formatter = Rails.logger.formatter\n        console.level = Rails.logger.level\n\n        unless ActiveSupport::Logger.logger_outputs_to?(Rails.logger, STDOUT)\n          Rails.logger.extend(ActiveSupport::Logger.broadcast(console))\n        end\n      end\n  end\nend\n\nCopy\n","\nmodule Rack\n  class Server\n    def start &blk\n      if options[:warn]\n        $-w = true\n      end\n\n      if includes = options[:include]\n        $LOAD_PATH.unshift(*includes)\n      end\n\n      if library = options[:require]\n        require library\n      end\n\n      if options[:debug]\n        $DEBUG = true\n        require \"pp\"\n        p options[:server]\n        pp wrapped_app\n        pp app\n      end\n\n      check_pid! if options[:pid]\n\n      # Touch the wrapped app, so that the config.ru is loaded before\n      # daemonization (i.e. before chdir, etc).\n      handle_profiling(options[:heapfile], options[:profile_mode], options[:profile_file]) do\n        wrapped_app\n      end\n\n      daemonize_app if options[:daemonize]\n\n      write_pid if options[:pid]\n\n      trap(:INT) do\n        if server.respond_to?(:shutdown)\n          server.shutdown\n        else\n          exit\n        end\n      end\n\n      server.run wrapped_app, options, &blk\n    end\n  end\nend\n\nmodule Rack\n  class Server\n    def start &blk\n      if options[:warn]\n        $-w = true\n      end\n\n      if includes = options[:include]\n        $LOAD_PATH.unshift(*includes)\n      end\n\n      if library = options[:require]\n        require library\n      end\n\n      if options[:debug]\n        $DEBUG = true\n        require \"pp\"\n        p options[:server]\n        pp wrapped_app\n        pp app\n      end\n\n      check_pid! if options[:pid]\n\n      # Touch the wrapped app, so that the config.ru is loaded before\n      # daemonization (i.e. before chdir, etc).\n      handle_profiling(options[:heapfile], options[:profile_mode], options[:profile_file]) do\n        wrapped_app\n      end\n\n      daemonize_app if options[:daemonize]\n\n      write_pid if options[:pid]\n\n      trap(:INT) do\n        if server.respond_to?(:shutdown)\n          server.shutdown\n        else\n          exit\n        end\n      end\n\n      server.run wrapped_app, options, &blk\n    end\n  end\nend\n\nCopy\n","\nmodule Rack\n  class Server\n    def wrapped_app\n      @wrapped_app ||= build_app app\n    end\n  end\nend\n\nmodule Rack\n  class Server\n    def wrapped_app\n      @wrapped_app ||= build_app app\n    end\n  end\nend\n\nCopy\n","\nmodule Rack\n  class Server\n    def app\n      @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config\n    end\n\n    # ...\n\n    private\n      def build_app_and_options_from_config\n        if !::File.exist? options[:config]\n          abort \"configuration #{options[:config]} not found\"\n        end\n\n        app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)\n        @options.merge!(options) { |key, old, new| old }\n        app\n      end\n\n      def build_app_from_string\n        Rack::Builder.new_from_string(self.options[:builder])\n      end\n\n  end\nend\n\nmodule Rack\n  class Server\n    def app\n      @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config\n    end\n\n    # ...\n\n    private\n      def build_app_and_options_from_config\n        if !::File.exist? options[:config]\n          abort \"configuration #{options[:config]} not found\"\n        end\n\n        app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)\n        @options.merge!(options) { |key, old, new| old }\n        app\n      end\n\n      def build_app_from_string\n        Rack::Builder.new_from_string(self.options[:builder])\n      end\n\n  end\nend\n\nCopy\n","\n# This file is used by Rack-based servers to start the application.\n\nrequire_relative \"config/environment\"\n\nrun Rails.application\n\n# This file is used by Rack-based servers to start the application.\n\nrequire_relative \"config/environment\"\n\nrun Rails.application\n\nCopy\n","\nmodule Rack\n  class Builder\n    def self.load_file(path, opts = Server::Options.new)\n      # ...\n      app = new_from_string cfgfile, config\n      # ...\n    end\n\n    # ...\n\n    def self.new_from_string(builder_script, file=\"(rackup)\")\n      eval \"Rack::Builder.new {\\n\" + builder_script + \"\\n}.to_app\",\n        TOPLEVEL_BINDING, file, 0\n    end\n  end\nend\n\nmodule Rack\n  class Builder\n    def self.load_file(path, opts = Server::Options.new)\n      # ...\n      app = new_from_string cfgfile, config\n      # ...\n    end\n\n    # ...\n\n    def self.new_from_string(builder_script, file=\"(rackup)\")\n      eval \"Rack::Builder.new {\\n\" + builder_script + \"\\n}.to_app\",\n        TOPLEVEL_BINDING, file, 0\n    end\n  end\nend\n\nCopy\n","\nrequire_relative \"config/environment\"\n\nrequire_relative \"config/environment\"\n\nCopy\n"],"body":"After config/application is loaded, server.start is called. This method is\ndefined like this:This method creates a trap for INT signals, so if you CTRL-C the server, it will exit the process.\nAs we can see from the code here, it will create the tmp/cache,\ntmp/pids, and tmp/sockets directories. It then enables caching in development\nif bin/rails server is called with --dev-caching. Finally, it calls wrapped_app which is\nresponsible for creating the Rack app, before creating and assigning an instance\nof ActiveSupport::Logger.The super method will call Rack::Server.start which begins its definition as follows:The interesting part for a Rails app is the last line, server.run. Here we encounter the wrapped_app method again, which this time\nwe're going to explore more (even though it was executed before, and\nthus memoized by now).The app method here is defined like so:The options[:config] value defaults to config.ru which contains this:The Rack::Builder.parse_file method here takes the content from this config.ru file and parses it using this code:The initialize method of Rack::Builder will take the block here and execute it within an instance of Rack::Builder.\nThis is where the majority of the initialization process of Rails happens.\nThe require line for config/environment.rb in config.ru is the first to run:"},{"code":["\nrequire_relative \"application\"\n\nrequire_relative \"application\"\n\nCopy\n"],"body":"This file is the common file required by config.ru (bin/rails server) and Passenger. This is where these two ways to run the server meet; everything before this point has been Rack and Rails setup.This file begins with requiring config/application.rb:","title":"1.10 config/environment.rb","anchor":"#config-environment-rb"},{"code":["\nrequire_relative \"boot\"\n\nrequire_relative \"boot\"\n\nCopy\n"],"body":"This file requires config/boot.rb:But only if it hasn't been required before, which would be the case in bin/rails server\nbut wouldn't be the case with Passenger.Then the fun begins!","title":"1.11 config/application.rb","anchor":"#config-application-rb"},{"title":"2 Loading Rails","anchor":"#loading-rails","code":["\nrequire \"rails/all\"\n\nrequire \"rails/all\"\n\nCopy\n"],"body":"The next line in config/application.rb is:"},{"code":["\nrequire \"rails\"\n\n%w(\n  active_record/railtie\n  active_storage/engine\n  action_controller/railtie\n  action_view/railtie\n  action_mailer/railtie\n  active_job/railtie\n  action_cable/engine\n  action_mailbox/engine\n  action_text/engine\n  rails/test_unit/railtie\n  sprockets/railtie\n).each do |railtie|\n  begin\n    require railtie\n  rescue LoadError\n  end\nend\n\nrequire \"rails\"\n\n%w(\n  active_record/railtie\n  active_storage/engine\n  action_controller/railtie\n  action_view/railtie\n  action_mailer/railtie\n  active_job/railtie\n  action_cable/engine\n  action_mailbox/engine\n  action_text/engine\n  rails/test_unit/railtie\n  sprockets/railtie\n).each do |railtie|\n  begin\n    require railtie\n  rescue LoadError\n  end\nend\n\nCopy\n"],"body":"This file is responsible for requiring all the individual frameworks of Rails:This is where all the Rails frameworks are loaded and thus made\navailable to the application. We won't go into detail of what happens\ninside each of those frameworks, but you're encouraged to try and\nexplore them on your own.For now, just keep in mind that common functionality like Rails engines,\nI18n and Rails configuration are all being defined here.","title":"2.1 railties/lib/rails/all.rb","anchor":"#railties-lib-rails-all-rb"},{"title":"2.2 Back to config/environment.rb","anchor":"#back-to-config-environment-rb","code":[],"body":"The rest of config/application.rb defines the configuration for the\nRails::Application which will be used once the application is fully\ninitialized. When config/application.rb has finished loading Rails and defined\nthe application namespace, we go back to config/environment.rb. Here, the\napplication is initialized with Rails.application.initialize!, which is\ndefined in rails/application.rb."},{"title":"2.3 railties/lib/rails/application.rb","anchor":"#railties-lib-rails-application-rb","code":["\ndef initialize!(group = :default) #:nodoc:\n  raise \"Application has been already initialized.\" if @initialized\n  run_initializers(group, self)\n  @initialized = true\n  self\nend\n\ndef initialize!(group = :default) #:nodoc:\n  raise \"Application has been already initialized.\" if @initialized\n  run_initializers(group, self)\n  @initialized = true\n  self\nend\n\nCopy\n","\ndef run_initializers(group = :default, *args)\n  return if instance_variable_defined?(:@ran)\n  initializers.tsort_each do |initializer|\n    initializer.run(*args) if initializer.belongs_to?(group)\n  end\n  @ran = true\nend\n\ndef run_initializers(group = :default, *args)\n  return if instance_variable_defined?(:@ran)\n  initializers.tsort_each do |initializer|\n    initializer.run(*args) if initializer.belongs_to?(group)\n  end\n  @ran = true\nend\n\nCopy\n"],"body":"The initialize! method looks like this:You can only initialize an app once. The Railtie initializers\nare run through the run_initializers method which is defined in\nrailties/lib/rails/initializable.rb:The run_initializers code itself is tricky. What Rails is doing here is\ntraversing all the class ancestors looking for those that respond to an\ninitializers method. It then sorts the ancestors by name, and runs them.\nFor example, the Engine class will make all the engines available by\nproviding an initializers method on them.The Rails::Application class, as defined in railties/lib/rails/application.rb\ndefines bootstrap, railtie, and finisher initializers. The bootstrap initializers\nprepare the application (like initializing the logger) while the finisher\ninitializers (like building the middleware stack) are run last. The railtie\ninitializers are the initializers which have been defined on the Rails::Application\nitself and are run between the bootstrap and finishers.Note: Do not confuse Railtie initializers overall with the load_config_initializers\ninitializer instance or its associated config initializers in config/initializers.After this is done we go back to Rack::Server."},{"title":"2.4 Rack: lib/rack/server.rb","anchor":"#loading-rails-rack-lib-rack-server-rb","code":["\nmodule Rack\n  class Server\n    def app\n      @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config\n    end\n\n    # ...\n\n    private\n      def build_app_and_options_from_config\n        if !::File.exist? options[:config]\n          abort \"configuration #{options[:config]} not found\"\n        end\n\n        app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)\n        @options.merge!(options) { |key, old, new| old }\n        app\n      end\n\n      def build_app_from_string\n        Rack::Builder.new_from_string(self.options[:builder])\n      end\n\n  end\nend\n\nmodule Rack\n  class Server\n    def app\n      @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config\n    end\n\n    # ...\n\n    private\n      def build_app_and_options_from_config\n        if !::File.exist? options[:config]\n          abort \"configuration #{options[:config]} not found\"\n        end\n\n        app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)\n        @options.merge!(options) { |key, old, new| old }\n        app\n      end\n\n      def build_app_from_string\n        Rack::Builder.new_from_string(self.options[:builder])\n      end\n\n  end\nend\n\nCopy\n","\nmodule Rack\n  class Server\n    private\n      def build_app(app)\n        middleware[options[:environment]].reverse_each do |middleware|\n          middleware = middleware.call(self) if middleware.respond_to?(:call)\n          next unless middleware\n          klass, *args = middleware\n          app = klass.new(app, *args)\n        end\n        app\n      end\n  end\nend\n\nmodule Rack\n  class Server\n    private\n      def build_app(app)\n        middleware[options[:environment]].reverse_each do |middleware|\n          middleware = middleware.call(self) if middleware.respond_to?(:call)\n          next unless middleware\n          klass, *args = middleware\n          app = klass.new(app, *args)\n        end\n        app\n      end\n  end\nend\n\nCopy\n","\nserver.run wrapped_app, options, &blk\n\nserver.run wrapped_app, options, &blk\n\nCopy\n","\nmodule Rack\n  module Handler\n    module Puma\n      # ...\n      def self.run(app, options = {})\n        conf   = self.config(app, options)\n\n        events = options.delete(:Silent) ? ::Puma::Events.strings : ::Puma::Events.stdio\n\n        launcher = ::Puma::Launcher.new(conf, :events => events)\n\n        yield launcher if block_given?\n        begin\n          launcher.run\n        rescue Interrupt\n          puts \"* Gracefully stopping, waiting for requests to finish\"\n          launcher.stop\n          puts \"* Goodbye!\"\n        end\n      end\n      # ...\n    end\n  end\nend\n\nmodule Rack\n  module Handler\n    module Puma\n      # ...\n      def self.run(app, options = {})\n        conf   = self.config(app, options)\n\n        events = options.delete(:Silent) ? ::Puma::Events.strings : ::Puma::Events.stdio\n\n        launcher = ::Puma::Launcher.new(conf, :events => events)\n\n        yield launcher if block_given?\n        begin\n          launcher.run\n        rescue Interrupt\n          puts \"* Gracefully stopping, waiting for requests to finish\"\n          launcher.stop\n          puts \"* Goodbye!\"\n        end\n      end\n      # ...\n    end\n  end\nend\n\nCopy\n"],"body":"Last time we left when the app method was being defined:At this point app is the Rails app itself (a middleware), and what\nhappens next is Rack will call all the provided middlewares:Remember, build_app was called (by wrapped_app) in the last line of Rack::Server#start.\nHere's how it looked like when we left:At this point, the implementation of server.run will depend on the\nserver you're using. For example, if you were using Puma, here's what\nthe run method would look like:We won't dig into the server configuration itself, but this is\nthe last piece of our journey in the Rails initialization process.This high level overview will help you understand when your code is\nexecuted and how, and overall become a better Rails developer. If you\nstill want to know more, the Rails source code itself is probably the\nbest place to go next."}]