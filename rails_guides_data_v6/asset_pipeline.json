[{"code":["\n$ rails new appname --skip-sprockets\n\nrails new appname --skip-sprockets\n\nCopy\n","\ngem 'sass-rails'\n\ngem 'sass-rails'\n\nCopy\n","\n# require \"sprockets/railtie\"\n\n# require \"sprockets/railtie\"\n\nCopy\n","\nconfig.assets.css_compressor = :yui\nconfig.assets.js_compressor = :uglifier\n\nconfig.assets.css_compressor = :yui\nconfig.assets.js_compressor = :uglifier\n\nCopy\n"],"body":"The asset pipeline provides a framework to concatenate and minify or compress\nJavaScript and CSS assets. It also adds the ability to write these assets in\nother languages and pre-processors such as CoffeeScript, Sass, and ERB.\nIt allows assets in your application to be automatically combined with assets\nfrom other gems.The asset pipeline is implemented by the\nsprockets-rails gem,\nand is enabled by default. You can disable it while creating a new application by\npassing the --skip-sprockets option.Rails automatically adds the sass-rails\ngem to your Gemfile, which is used by Sprockets for\nSass compilation:Using the --skip-sprockets option will prevent Rails from adding\nthis gem, so if you later want to enable the asset pipeline\nyou will have to add it to your Gemfile manually. Also,\ncreating an application with the --skip-sprockets option will generate\na slightly different config/application.rb file, with a require statement\nfor the sprockets railtie that is commented-out. You will have to remove\nthe comment operator on that line to later enable the asset pipeline:To set asset compression methods, set the appropriate configuration options\nin production.rb - config.assets.css_compressor for your CSS and\nconfig.assets.js_compressor for your JavaScript:","title":"1 What is the Asset Pipeline?","anchor":"#what-is-the-asset-pipeline-questionmark"},{"title":"1.1 Main Features","anchor":"#main-features","code":[],"body":"The first feature of the pipeline is to concatenate assets, which can reduce the\nnumber of requests that a browser makes to render a web page. Web browsers are\nlimited in the number of requests that they can make in parallel, so fewer\nrequests can mean faster loading for your application.Sprockets concatenates all JavaScript files into one master .js file and all\nCSS files into one master .css file. As you'll learn later in this guide, you\ncan customize this strategy to group files any way you like. In production,\nRails inserts an SHA256 fingerprint into each filename so that the file is\ncached by the web browser. You can invalidate the cache by altering this\nfingerprint, which happens automatically whenever you change the file contents.The second feature of the asset pipeline is asset minification or compression.\nFor CSS files, this is done by removing whitespace and comments. For JavaScript,\nmore complex processes can be applied. You can choose from a set of built in\noptions or specify your own.The third feature of the asset pipeline is it allows coding assets via a\nhigher-level language, with precompilation down to the actual assets. Supported\nlanguages include Sass for CSS, CoffeeScript for JavaScript, and ERB for both by\ndefault."},{"title":"1.2 What is Fingerprinting and Why Should I Care?","anchor":"#what-is-fingerprinting-and-why-should-i-care-questionmark","code":["\nglobal-908e25f4bf641868d8683022a5b62f54.css\n\nglobal-908e25f4bf641868d8683022a5b62f54.css\n\nCopy\n","\n/stylesheets/global.css?1309495796\n\n/stylesheets/global.css?1309495796\n\nCopy\n"],"body":"Fingerprinting is a technique that makes the name of a file dependent on the\ncontents of the file. When the file contents change, the filename is also\nchanged. For content that is static or infrequently changed, this provides an\neasy way to tell whether two versions of a file are identical, even across\ndifferent servers or deployment dates.When a filename is unique and based on its content, HTTP headers can be set to\nencourage caches everywhere (whether at CDNs, at ISPs, in networking equipment,\nor in web browsers) to keep their own copy of the content. When the content is\nupdated, the fingerprint will change. This will cause the remote clients to\nrequest a new copy of the content. This is generally known as cache busting.The technique Sprockets uses for fingerprinting is to insert a hash of the\ncontent into the name, usually at the end. For example a CSS file global.cssThis is the strategy adopted by the Rails asset pipeline.Rails' old strategy was to append a date-based query string to every asset linked\nwith a built-in helper. In the source the generated code looked like this:The query string strategy has several disadvantages:Fingerprinting fixes these problems by avoiding query strings, and by ensuring\nthat filenames are consistent based on their content.Fingerprinting is enabled by default for both the development and production\nenvironments. You can enable or disable it in your configuration through the\nconfig.assets.digest option.More reading:"},{"code":[],"body":"In previous versions of Rails, all assets were located in subdirectories of\npublic such as images, javascripts and stylesheets. With the asset\npipeline, the preferred location for these assets is now the app/assets\ndirectory. Files in this directory are served by the Sprockets middleware.Assets can still be placed in the public hierarchy. Any assets under public\nwill be served as static files by the application or web server when\nconfig.public_file_server.enabled is set to true. You should use app/assets for\nfiles that must undergo some pre-processing before they are served.In production, Rails precompiles these files to public/assets by default. The\nprecompiled copies are then served as static assets by the web server. The files\nin app/assets are never served directly in production.","title":"2 How to Use the Asset Pipeline","anchor":"#how-to-use-the-asset-pipeline"},{"title":"2.1 Controller Specific Assets","anchor":"#controller-specific-assets","code":["\n  config.generators do |g|\n    g.assets false\n  end\n\n  config.generators do |g|\n    g.assets false\n  end\n\nCopy\n"],"body":"When you generate a scaffold or a controller, Rails also generates a\nCascading Style Sheet file (or SCSS file if sass-rails is in the Gemfile)\nfor that controller. Additionally, when generating a scaffold, Rails generates\nthe file scaffolds.css (or scaffolds.scss if sass-rails is in the\nGemfile.)For example, if you generate a ProjectsController, Rails will also add a new\nfile at app/assets/stylesheets/projects.scss. By default these files will be\nready to use by your application immediately using the require_tree directive. See\nManifest Files and Directives for more details\non require_tree.You can also opt to include controller specific stylesheets and JavaScript files\nonly in their respective controllers using the following:<%= javascript_include_tag params[:controller] %> or <%= stylesheet_link_tag\nparams[:controller] %>When doing this, ensure you are not using the require_tree directive, as that\nwill result in your assets being included more than once.You can also disable generation of controller specific asset files by adding the\nfollowing to your config/application.rb configuration:"},{"code":[],"body":"Pipeline assets can be placed inside an application in one of three locations:\napp/assets, lib/assets or vendor/assets.","title":"2.2 Asset Organization","anchor":"#asset-organization"},{"code":["\napp/assets/javascripts/home.js\nlib/assets/javascripts/moovinator.js\nvendor/assets/javascripts/slider.js\nvendor/assets/somepackage/phonebox.js\n\napp/assets/javascripts/home.js\nlib/assets/javascripts/moovinator.js\nvendor/assets/javascripts/slider.js\nvendor/assets/somepackage/phonebox.js\n\nCopy\n","\n//= require home\n//= require moovinator\n//= require slider\n//= require phonebox\n\n//= require home\n//= require moovinator\n//= require slider\n//= require phonebox\n\nCopy\n","\napp/assets/javascripts/sub/something.js\n\napp/assets/javascripts/sub/something.js\n\nCopy\n","\n//= require sub/something\n\n//= require sub/something\n\nCopy\n","\nRails.application.config.assets.paths << Rails.root.join(\"lib\", \"videoplayer\", \"flash\")\n\nRails.application.config.assets.paths << Rails.root.join(\"lib\", \"videoplayer\", \"flash\")\n\nCopy\n"],"body":"When a file is referenced from a manifest or a helper, Sprockets searches the\nthree default asset locations for it.The default locations are: the images, javascripts and stylesheets\ndirectories under the app/assets folder, but these subdirectories\nare not special - any path under assets/* will be searched.For example, these files:would be referenced in a manifest like this:Assets inside subdirectories can also be accessed.is referenced as:You can view the search path by inspecting\nRails.application.config.assets.paths in the Rails console.Besides the standard assets/* paths, additional (fully qualified) paths can be\nadded to the pipeline in config/initializers/assets.rb. For example:Paths are traversed in the order they occur in the search path. By default,\nthis means the files in app/assets take precedence, and will mask\ncorresponding paths in lib and vendor.It is important to note that files you want to reference outside a manifest must\nbe added to the precompile array or they will not be available in the production\nenvironment.","title":"2.2.1 Search Paths","anchor":"#search-paths"},{"title":"2.2.2 Using Index Files","anchor":"#using-index-files","code":["\n//= require library_name\n\n//= require library_name\n\nCopy\n"],"body":"Sprockets uses files named index (with the relevant extensions) for a special\npurpose.For example, if you have a jQuery library with many modules, which is stored in\nlib/assets/javascripts/library_name, the file lib/assets/javascripts/library_name/index.js serves as\nthe manifest for all files in this library. This file could include a list of\nall the required files in order, or a simple require_tree directive.The library as a whole can be accessed in the application manifest like so:This simplifies maintenance and keeps things clean by allowing related code to\nbe grouped before inclusion elsewhere."},{"title":"2.3 Coding Links to Assets","anchor":"#coding-links-to-assets","code":["\n<%= stylesheet_link_tag \"application\", media: \"all\" %>\n<%= javascript_include_tag \"application\" %>\n\n<%= stylesheet_link_tag \"application\", media: \"all\" %>\n<%= javascript_include_tag \"application\" %>\n\nCopy\n","\n<%= stylesheet_link_tag \"application\", media: \"all\", \"data-turbolinks-track\" => \"reload\" %>\n<%= javascript_include_tag \"application\", \"data-turbolinks-track\" => \"reload\" %>\n\n<%= stylesheet_link_tag \"application\", media: \"all\", \"data-turbolinks-track\" => \"reload\" %>\n<%= javascript_include_tag \"application\", \"data-turbolinks-track\" => \"reload\" %>\n\nCopy\n","\n<%= image_tag \"rails.png\" %>\n\n<%= image_tag \"rails.png\" %>\n\nCopy\n","\n<%= image_tag \"icons/rails.png\" %>\n\n<%= image_tag \"icons/rails.png\" %>\n\nCopy\n"],"body":"Sprockets does not add any new methods to access your assets - you still use the\nfamiliar javascript_include_tag and stylesheet_link_tag:If using the turbolinks gem, which is included by default in Rails, then\ninclude the 'data-turbolinks-track' option which causes turbolinks to check if\nan asset has been updated and if so loads it into the page:In regular views you can access images in the app/assets/images directory\nlike this:Provided that the pipeline is enabled within your application (and not disabled\nin the current environment context), this file is served by Sprockets. If a file\nexists at public/assets/rails.png it is served by the web server.Alternatively, a request for a file with an SHA256 hash such as\npublic/assets/rails-f90d8a84c707a8dc923fca1ca1895ae8ed0a09237f6992015fef1e11be77c023.png\nis treated the same way. How these hashes are generated is covered in the In\nProduction section later on in this guide.Sprockets will also look through the paths specified in config.assets.paths,\nwhich includes the standard application paths and any paths added by Rails\nengines.Images can also be organized into subdirectories if required, and then can be\naccessed by specifying the directory's name in the tag:"},{"title":"2.3.1 CSS and ERB","anchor":"#css-and-erb","code":["\n.class { background-image: url(<%= asset_path 'image.png' %>) }\n\n.class { background-image: url(<%= asset_path 'image.png' %>) }\n\nCopy\n","\n#logo { background: url(<%= asset_data_uri 'logo.png' %>) }\n\n#logo { background: url(<%= asset_data_uri 'logo.png' %>) }\n\nCopy\n"],"body":"The asset pipeline automatically evaluates ERB. This means if you add an\nerb extension to a CSS asset (for example, application.css.erb), then\nhelpers like asset_path are available in your CSS rules:This writes the path to the particular asset being referenced. In this example,\nit would make sense to have an image in one of the asset load paths, such as\napp/assets/images/image.png, which would be referenced here. If this image is\nalready available in public/assets as a fingerprinted file, then that path is\nreferenced.If you want to use a data URI -\na method of embedding the image data directly into the CSS file - you can use\nthe asset_data_uri helper.This inserts a correctly-formatted data URI into the CSS source.Note that the closing tag cannot be of the style -%>."},{"title":"2.3.2 CSS and Sass","anchor":"#css-and-sass","code":[],"body":"When using the asset pipeline, paths to assets must be re-written and\nsass-rails provides -url and -path helpers (hyphenated in Sass,\nunderscored in Ruby) for the following asset classes: image, font, video, audio,\nJavaScript and stylesheet.The more generic form can also be used:"},{"code":["\n$('#logo').attr({ src: \"<%= asset_path('logo.png') %>\" });\n\n$('#logo').attr({ src: \"<%= asset_path('logo.png') %>\" });\n\nCopy\n","\n$('#logo').attr src: \"<%= asset_path('logo.png') %>\"\n\n$('#logo').attr src: \"<%= asset_path('logo.png') %>\"\n\nCopy\n"],"body":"If you add an erb extension to a JavaScript asset, making it something such as\napplication.js.erb, you can then use the asset_path helper in your\nJavaScript code:This writes the path to the particular asset being referenced.Similarly, you can use the asset_path helper in CoffeeScript files with erb\nextension (e.g., application.coffee.erb):","title":"2.3.3 JavaScript/CoffeeScript and ERB","anchor":"#javascript-coffeescript-and-erb"},{"code":["\n// ...\n//= require rails-ujs\n//= require turbolinks\n//= require_tree .\n\n// ...\n//= require rails-ujs\n//= require turbolinks\n//= require_tree .\n\nCopy\n","\n/* ...\n *= require_self\n *= require_tree .\n */\n\n/* ...\n *= require_self\n *= require_tree .\n */\n\nCopy\n","\n/* ...\n *= require reset\n *= require layout\n *= require chrome\n */\n\n/* ...\n *= require reset\n *= require layout\n *= require chrome\n */\n\nCopy\n"],"body":"Sprockets uses manifest files to determine which assets to include and serve.\nThese manifest files contain directives - instructions that tell Sprockets\nwhich files to require in order to build a single CSS or JavaScript file. With\nthese directives, Sprockets loads the files specified, processes them if\nnecessary, concatenates them into one single file, and then compresses them\n(based on value of Rails.application.config.assets.js_compressor). By serving\none file rather than many, the load time of pages can be greatly reduced because\nthe browser makes fewer requests. Compression also reduces file size, enabling\nthe browser to download them faster.For example, with a app/assets/javascripts/application.js file containing the\nfollowing lines:In JavaScript files, Sprockets directives begin with //=. In the above case,\nthe file is using the require and the require_tree directives. The require\ndirective is used to tell Sprockets the files you wish to require. Here, you are\nrequiring the files rails-ujs.js and turbolinks.js that are available somewhere\nin the search path for Sprockets. You need not supply the extensions explicitly.\nSprockets assumes you are requiring a .js file when done from within a .js\nfile.The require_tree directive tells Sprockets to recursively include all\nJavaScript files in the specified directory into the output. These paths must be\nspecified relative to the manifest file. You can also use the\nrequire_directory directive which includes all JavaScript files only in the\ndirectory specified, without recursion.Directives are processed top to bottom, but the order in which files are\nincluded by require_tree is unspecified. You should not rely on any particular\norder among those. If you need to ensure some particular JavaScript ends up\nabove some other in the concatenated file, require the prerequisite file first\nin the manifest. Note that the family of require directives prevents files\nfrom being included twice in the output.Rails also creates a default app/assets/stylesheets/application.css file\nwhich contains these lines:Rails creates app/assets/stylesheets/application.css regardless of whether the\n--skip-sprockets option is used when creating a new Rails application. This is\nso you can easily add asset pipelining later if you like.The directives that work in JavaScript files also work in stylesheets\n(though obviously including stylesheets rather than JavaScript files). The\nrequire_tree directive in a CSS manifest works the same way as the JavaScript\none, requiring all stylesheets from the current directory.In this example, require_self is used. This puts the CSS contained within the\nfile (if any) at the precise location of the require_self call.You can do file globbing as well using @import \"*\", and @import \"**/*\" to add the whole tree which is equivalent to how require_tree works. Check the sass-rails documentation for more info and important caveats.You can have as many manifest files as you need. For example, the admin.css\nand admin.js manifest could contain the JS and CSS files that are used for the\nadmin section of an application.The same remarks about ordering made above apply. In particular, you can specify\nindividual files and they are compiled in the order specified. For example, you\nmight concatenate three CSS files together this way:","title":"2.4 Manifest Files and Directives","anchor":"#manifest-files-and-directives"},{"code":[],"body":"The file extensions used on an asset determine what preprocessing is applied.\nWhen a controller or a scaffold is generated with the default Rails gemset, an\nSCSS file is generated in place of a regular CSS file. The example used before\nwas a controller called \"projects\", which generated an\napp/assets/stylesheets/projects.scss file.In development mode, or if the asset pipeline is disabled, when this file is\nrequested it is processed by the processor provided by the sass-rails gem and\nthen sent back to the browser as CSS. When asset pipelining is enabled, this\nfile is preprocessed and placed in the public/assets directory for serving by\neither the Rails app or web server.Additional layers of preprocessing can be requested by adding other extensions,\nwhere each extension is processed in a right-to-left manner. These should be\nused in the order the processing should be applied. For example, a stylesheet\ncalled app/assets/stylesheets/projects.scss.erb is first processed as ERB,\nthen SCSS, and finally served as CSS. The same applies to a JavaScript file -\napp/assets/javascripts/projects.coffee.erb is processed as ERB, then\nCoffeeScript, and served as JavaScript.Keep in mind the order of these preprocessors is important. For example, if\nyou called your JavaScript file app/assets/javascripts/projects.erb.coffee\nthen it would be processed with the CoffeeScript interpreter first, which\nwouldn't understand ERB and therefore you would run into problems.","title":"2.5 Preprocessing","anchor":"#preprocessing"},{"title":"3 In Development","anchor":"#in-development","code":["\n//= require core\n//= require projects\n//= require tickets\n\n//= require core\n//= require projects\n//= require tickets\n\nCopy\n","\n<script src=\"/assets/core.js?body=1\"></script>\n<script src=\"/assets/projects.js?body=1\"></script>\n<script src=\"/assets/tickets.js?body=1\"></script>\n\n<script src=\"/assets/core.js?body=1\"></script>\n<script src=\"/assets/projects.js?body=1\"></script>\n<script src=\"/assets/tickets.js?body=1\"></script>\n\nCopy\n"],"body":"In development mode, assets are served as separate files in the order they are\nspecified in the manifest file.This manifest app/assets/javascripts/application.js:would generate this HTML:The body param is required by Sprockets."},{"title":"3.1 Raise an Error When an Asset is Not Found","anchor":"#raise-an-error-when-an-asset-is-not-found","code":["\nconfig.assets.unknown_asset_fallback = false\n\nconfig.assets.unknown_asset_fallback = false\n\nCopy\n"],"body":"If you are using sprockets-rails >= 3.2.0 you can configure what happens\nwhen an asset lookup is performed and nothing is found. If you turn off \"asset fallback\"\nthen an error will be raised when an asset cannot be found.If \"asset fallback\" is enabled then when an asset cannot be found the path will be\noutput instead and no error raised. The asset fallback behavior is disabled by default."},{"title":"3.2 Turning Digests Off","anchor":"#turning-digests-off","code":["\nconfig.assets.digest = false\n\nconfig.assets.digest = false\n\nCopy\n"],"body":"You can turn off digests by updating config/environments/development.rb to\ninclude:When this option is true, digests will be generated for asset URLs."},{"title":"3.3 Turning Debugging Off","anchor":"#turning-debugging-off","code":["\nconfig.assets.debug = false\n\nconfig.assets.debug = false\n\nCopy\n","\n<script src=\"/assets/application.js\"></script>\n\n<script src=\"/assets/application.js\"></script>\n\nCopy\n","\n<%= stylesheet_link_tag \"application\", debug: true %>\n<%= javascript_include_tag \"application\", debug: true %>\n\n<%= stylesheet_link_tag \"application\", debug: true %>\n<%= javascript_include_tag \"application\", debug: true %>\n\nCopy\n"],"body":"You can turn off debug mode by updating config/environments/development.rb to\ninclude:When debug mode is off, Sprockets concatenates and runs the necessary\npreprocessors on all files. With debug mode turned off the manifest above would\ngenerate instead:Assets are compiled and cached on the first request after the server is started.\nSprockets sets a must-revalidate Cache-Control HTTP header to reduce request\noverhead on subsequent requests - on these the browser gets a 304 (Not Modified)\nresponse.If any of the files in the manifest have changed between requests, the server\nresponds with a new compiled file.Debug mode can also be enabled in Rails helper methods:The :debug option is redundant if debug mode is already on.You can also enable compression in development mode as a sanity check, and\ndisable it on-demand as required for debugging."},{"title":"4 In Production","anchor":"#in-production","code":["\n<%= javascript_include_tag \"application\" %>\n<%= stylesheet_link_tag \"application\" %>\n\n<%= javascript_include_tag \"application\" %>\n<%= stylesheet_link_tag \"application\" %>\n\nCopy\n","\n<script src=\"/assets/application-908e25f4bf641868d8683022a5b62f54.js\"></script>\n<link href=\"/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css\" media=\"screen\"\nrel=\"stylesheet\" />\n\n<script src=\"/assets/application-908e25f4bf641868d8683022a5b62f54.js\"></script>\n<link href=\"/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css\" media=\"screen\"\nrel=\"stylesheet\" />\n\nCopy\n"],"body":"In the production environment Sprockets uses the fingerprinting scheme outlined\nabove. By default Rails assumes assets have been precompiled and will be\nserved as static assets by your web server.During the precompilation phase an SHA256 is generated from the contents of the\ncompiled files, and inserted into the filenames as they are written to disk.\nThese fingerprinted names are used by the Rails helpers in place of the manifest\nname.For example this:generates something like this:The fingerprinting behavior is controlled by the config.assets.digest\ninitialization option (which defaults to true)."},{"title":"4.1 Precompiling Assets","anchor":"#precompiling-assets","code":["\n$ RAILS_ENV=production rails assets:precompile\n\nRAILS_ENV=production rails assets:precompile\n\nCopy\n","\n[ Proc.new { |filename, path| path =~ /app\\/assets/ && !%w(.js .css).include?(File.extname(filename)) },\n/application.(css|js)$/ ]\n\n[ Proc.new { |filename, path| path =~ /app\\/assets/ && !%w(.js .css).include?(File.extname(filename)) },\n/application.(css|js)$/ ]\n\nCopy\n","\nRails.application.config.assets.precompile += %w( admin.js admin.css )\n\nRails.application.config.assets.precompile += %w( admin.js admin.css )\n\nCopy\n","\n{\"files\":{\"application-aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b.js\":{\"logical_path\":\"application.js\",\"mtime\":\"2016-12-23T20:12:03-05:00\",\"size\":412383,\n\"digest\":\"aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b\",\"integrity\":\"sha256-ruS+cfEogDeueLmX3ziDMu39JGRxtTPc7aqPn+FWRCs=\"},\n\"application-86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18.css\":{\"logical_path\":\"application.css\",\"mtime\":\"2016-12-23T19:12:20-05:00\",\"size\":2994,\n\"digest\":\"86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18\",\"integrity\":\"sha256-hqKStQcHk8N+LA5fOfc7s4dkTq6tp/lub8BAoCixbBg=\"},\n\"favicon-8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda.ico\":{\"logical_path\":\"favicon.ico\",\"mtime\":\"2016-12-23T20:11:00-05:00\",\"size\":8629,\n\"digest\":\"8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda\",\"integrity\":\"sha256-jSOHuNTTLOzZP6OQDfDp/4nQGqzYT1DngMF8n2s9Dto=\"},\n\"my_image-f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493.png\":{\"logical_path\":\"my_image.png\",\"mtime\":\"2016-12-23T20:10:54-05:00\",\"size\":23414,\n\"digest\":\"f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493\",\"integrity\":\"sha256-9AKBVv1+ygNYTV8vwEcN8eDbxzaequY4sv8DP5iOxJM=\"}},\n\"assets\":{\"application.js\":\"application-aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b.js\",\n\"application.css\":\"application-86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18.css\",\n\"favicon.ico\":\"favicon-8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda.ico\",\n\"my_image.png\":\"my_image-f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493.png\"}}\n\n{\"files\":{\"application-aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b.js\":{\"logical_path\":\"application.js\",\"mtime\":\"2016-12-23T20:12:03-05:00\",\"size\":412383,\n\"digest\":\"aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b\",\"integrity\":\"sha256-ruS+cfEogDeueLmX3ziDMu39JGRxtTPc7aqPn+FWRCs=\"},\n\"application-86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18.css\":{\"logical_path\":\"application.css\",\"mtime\":\"2016-12-23T19:12:20-05:00\",\"size\":2994,\n\"digest\":\"86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18\",\"integrity\":\"sha256-hqKStQcHk8N+LA5fOfc7s4dkTq6tp/lub8BAoCixbBg=\"},\n\"favicon-8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda.ico\":{\"logical_path\":\"favicon.ico\",\"mtime\":\"2016-12-23T20:11:00-05:00\",\"size\":8629,\n\"digest\":\"8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda\",\"integrity\":\"sha256-jSOHuNTTLOzZP6OQDfDp/4nQGqzYT1DngMF8n2s9Dto=\"},\n\"my_image-f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493.png\":{\"logical_path\":\"my_image.png\",\"mtime\":\"2016-12-23T20:10:54-05:00\",\"size\":23414,\n\"digest\":\"f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493\",\"integrity\":\"sha256-9AKBVv1+ygNYTV8vwEcN8eDbxzaequY4sv8DP5iOxJM=\"}},\n\"assets\":{\"application.js\":\"application-aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b.js\",\n\"application.css\":\"application-86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18.css\",\n\"favicon.ico\":\"favicon-8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda.ico\",\n\"my_image.png\":\"my_image-f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493.png\"}}\n\nCopy\n"],"body":"Rails comes bundled with a command to compile the asset manifests and other\nfiles in the pipeline.Compiled assets are written to the location specified in config.assets.prefix.\nBy default, this is the /assets directory.You can call this command on the server during deployment to create compiled\nversions of your assets directly on the server. See the next section for\ninformation on compiling locally.The command is:This links the folder specified in config.assets.prefix to shared/assets.\nIf you already use this shared folder you'll need to write your own deployment\ncommand.It is important that this folder is shared between deployments so that remotely\ncached pages referencing the old compiled assets still work for the life of\nthe cached page.The default matcher for compiling files includes application.js,\napplication.css and all non-JS/CSS files (this will include all image assets\nautomatically) from app/assets folders including your gems:If you have other manifests or individual stylesheets and JavaScript files to\ninclude, you can add them to the precompile array in config/initializers/assets.rb:The command also generates a .sprockets-manifest-randomhex.json (where randomhex is\na 16-byte random hex string) that contains a list with all your assets and their respective\nfingerprints. This is used by the Rails helper methods to avoid handing the\nmapping requests back to Sprockets. A typical manifest file looks like:The default location for the manifest is the root of the location specified in\nconfig.assets.prefix ('/assets' by default)."},{"title":"4.1.1 Far-future Expires Header","anchor":"#far-future-expires-header","code":["\n# The Expires* directives requires the Apache module\n# `mod_expires` to be enabled.\n<Location /assets/>\n  # Use of ETag is discouraged when Last-Modified is present\n  Header unset ETag\n  FileETag None\n  # RFC says only cache for 1 year\n  ExpiresActive On\n  ExpiresDefault \"access plus 1 year\"\n</Location>\n\n# The Expires* directives requires the Apache module\n# `mod_expires` to be enabled.\n<Location /assets/>\n  # Use of ETag is discouraged when Last-Modified is present\n  Header unset ETag\n  FileETag None\n  # RFC says only cache for 1 year\n  ExpiresActive On\n  ExpiresDefault \"access plus 1 year\"\n</Location>\n\nCopy\n","\nlocation ~ ^/assets/ {\n  expires 1y;\n  add_header Cache-Control public;\n\n  add_header ETag \"\";\n}\n\nlocation ~ ^/assets/ {\n  expires 1y;\n  add_header Cache-Control public;\n\n  add_header ETag \"\";\n}\n\nCopy\n"],"body":"Precompiled assets exist on the file system and are served directly by your web\nserver. They do not have far-future headers by default, so to get the benefit of\nfingerprinting you'll have to update your server configuration to add those\nheaders.For Apache:For NGINX:"},{"code":["\n$ RAILS_ENV=production rails assets:precompile\n\nRAILS_ENV=production rails assets:precompile\n\nCopy\n"],"body":"Sometimes, you may not want or be able to compile assets on the production\nserver. For instance, you may have limited write access to your production\nfilesystem, or you may plan to deploy frequently without making any changes to\nyour assets.In such cases, you can precompile assets locally â€” that is, add a finalized\nset of compiled, production-ready assets to your source code repository before\npushing to production. This way, they do not need to be precompiled separately\non the production server upon each deployment.As above, you can perform this step usingNote the following caveats:","title":"4.2 Local Precompilation","anchor":"#local-precompilation"},{"code":["\nconfig.assets.compile = true\n\nconfig.assets.compile = true\n\nCopy\n","\ngroup :production do\n  gem 'mini_racer'\nend\n\ngroup :production do\n  gem 'mini_racer'\nend\n\nCopy\n"],"body":"In some circumstances you may wish to use live compilation. In this mode all\nrequests for assets in the pipeline are handled by Sprockets directly.To enable this option set:On the first request the assets are compiled and cached as outlined in Assets\nCache Store, and the manifest names used in the helpers\nare altered to include the SHA256 hash.Sprockets also sets the Cache-Control HTTP header to max-age=31536000. This\nsignals all caches between your server and the client browser that this content\n(the file served) can be cached for 1 year. The effect of this is to reduce the\nnumber of requests for this asset from your server; the asset has a good chance\nof being in the local browser cache or some intermediate cache.This mode uses more memory, performs more poorly than the default, and is not\nrecommended.If you are deploying a production application to a system without any\npre-existing JavaScript runtimes, you may want to add one to your Gemfile:","title":"4.3 Live Compilation","anchor":"#live-compilation"},{"code":[],"body":"CDN stands for Content Delivery\nNetwork, they are\nprimarily designed to cache assets all over the world so that when a browser\nrequests the asset, a cached copy will be geographically close to that browser.\nIf you are serving assets directly from your Rails server in production, the\nbest practice is to use a CDN in front of your application.A common pattern for using a CDN is to set your production application as the\n\"origin\" server. This means when a browser requests an asset from the CDN and\nthere is a cache miss, it will grab the file from your server on the fly and\nthen cache it. For example if you are running a Rails application on\nexample.com and have a CDN configured at mycdnsubdomain.fictional-cdn.com,\nthen when a request is made to mycdnsubdomain.fictional-\ncdn.com/assets/smile.png, the CDN will query your server once at\nexample.com/assets/smile.png and cache the request. The next request to the\nCDN that comes in to the same URL will hit the cached copy. When the CDN can\nserve an asset directly the request never touches your Rails server. Since the\nassets from a CDN are geographically closer to the browser, the request is\nfaster, and since your server doesn't need to spend time serving assets, it can\nfocus on serving application code as fast as possible.","title":"4.4 CDNs","anchor":"#cdns"},{"title":"4.4.1 Set up a CDN to Serve Static Assets","anchor":"#set-up-a-cdn-to-serve-static-assets","code":["\nconfig.asset_host = 'mycdnsubdomain.fictional-cdn.com'\n\nconfig.asset_host = 'mycdnsubdomain.fictional-cdn.com'\n\nCopy\n","\nconfig.asset_host = ENV['CDN_HOST']\n\nconfig.asset_host = ENV['CDN_HOST']\n\nCopy\n","\n<%= asset_path('smile.png') %>\n\n<%= asset_path('smile.png') %>\n\nCopy\n","\nhttp://mycdnsubdomain.fictional-cdn.com/assets/smile.png\n\nhttp://mycdnsubdomain.fictional-cdn.com/assets/smile.png\n\nCopy\n","\n<%= asset_path 'image.png', host: 'mycdnsubdomain.fictional-cdn.com' %>\n\n<%= asset_path 'image.png', host: 'mycdnsubdomain.fictional-cdn.com' %>\n\nCopy\n"],"body":"To set up your CDN you have to have your application running in production on\nthe internet at a publicly available URL, for example example.com. Next\nyou'll need to sign up for a CDN service from a cloud hosting provider. When you\ndo this you need to configure the \"origin\" of the CDN to point back at your\nwebsite example.com, check your provider for documentation on configuring the\norigin server.The CDN you provisioned should give you a custom subdomain for your application\nsuch as mycdnsubdomain.fictional-cdn.com (note fictional-cdn.com is not a\nvalid CDN provider at the time of this writing). Now that you have configured\nyour CDN server, you need to tell browsers to use your CDN to grab assets\ninstead of your Rails server directly. You can do this by configuring Rails to\nset your CDN as the asset host instead of using a relative path. To set your\nasset host in Rails, you need to set config.asset_host in\nconfig/environments/production.rb:You can also set this value through an environment\nvariable to make running a\nstaging copy of your site easier:Once you have configured your server and your CDN when you serve a webpage that\nhas an asset:Instead of returning a path such as /assets/smile.png (digests are left out\nfor readability). The URL generated will have the full path to your CDN.If the CDN has a copy of smile.png it will serve it to the browser and your\nserver doesn't even know it was requested. If the CDN does not have a copy it\nwill try to find it at the \"origin\" example.com/assets/smile.png and then store\nit for future use.If you want to serve only some assets from your CDN, you can use custom :host\noption your asset helper, which overwrites value set in\nconfig.action_controller.asset_host."},{"code":["\n$ curl -I http://www.example/assets/application-\nd0e099e021c95eb0de3615fd1d8c4d83.css\nHTTP/1.1 200 OK\nServer: Cowboy\nDate: Sun, 24 Aug 2014 20:27:50 GMT\nConnection: keep-alive\nLast-Modified: Thu, 08 May 2014 01:24:14 GMT\nContent-Type: text/css\nCache-Control: public, max-age=2592000\nContent-Length: 126560\nVia: 1.1 vegur\n\ncurl -I http://www.example/assets/application-\n\nCopy\n","\n$ curl -I http://mycdnsubdomain.fictional-cdn.com/application-\nd0e099e021c95eb0de3615fd1d8c4d83.css\nHTTP/1.1 200 OK Server: Cowboy Last-\nModified: Thu, 08 May 2014 01:24:14 GMT Content-Type: text/css\nCache-Control:\npublic, max-age=2592000\nVia: 1.1 vegur\nContent-Length: 126560\nAccept-Ranges:\nbytes\nDate: Sun, 24 Aug 2014 20:28:45 GMT\nVia: 1.1 varnish\nAge: 885814\nConnection: keep-alive\nX-Served-By: cache-dfw1828-DFW\nX-Cache: HIT\nX-Cache-Hits:\n68\nX-Timer: S1408912125.211638212,VS0,VE0\n\ncurl -I http://mycdnsubdomain.fictional-cdn.com/application-\n\nCopy\n","\nconfig.public_file_server.headers = {\n  'Cache-Control' => 'public, max-age=31536000'\n}\n\nconfig.public_file_server.headers = {\n  'Cache-Control' => 'public, max-age=31536000'\n}\n\nCopy\n","\nhttp://mycdnsubdomain.fictional-cdn.com/assets/smile-123.png\n\nhttp://mycdnsubdomain.fictional-cdn.com/assets/smile-123.png\n\nCopy\n","\nhttp://mycdnsubdomain.fictional-cdn.com/assets/smile.png\n\nhttp://mycdnsubdomain.fictional-cdn.com/assets/smile.png\n\nCopy\n"],"body":"A CDN works by caching content. If the CDN has stale or bad content, then it is\nhurting rather than helping your application. The purpose of this section is to\ndescribe general caching behavior of most CDNs, your specific provider may\nbehave slightly differently.While a CDN is described as being good for caching assets, in reality caches the\nentire request. This includes the body of the asset as well as any headers. The\nmost important one being Cache-Control which tells the CDN (and web browsers)\nhow to cache contents. This means that if someone requests an asset that does\nnot exist /assets/i-dont-exist.png and your Rails application returns a 404,\nthen your CDN will likely cache the 404 page if a valid Cache-Control header\nis present.One way to check the headers are cached properly in your CDN is by using curl. You\ncan request the headers from both your server and your CDN to verify they are\nthe same:Versus the CDN copy.Check your CDN documentation for any additional information they may provide\nsuch as X-Cache or for any additional headers they may add.The cache control\nheader is a W3C\nspecification that describes how a request can be cached. When no CDN is used, a\nbrowser will use this information to cache contents. This is very helpful for\nassets that are not modified so that a browser does not need to re-download a\nwebsite's CSS or JavaScript on every request. Generally we want our Rails server\nto tell our CDN (and browser) that the asset is \"public\", that means any cache\ncan store the request. Also we commonly want to set max-age which is how long\nthe cache will store the object before invalidating the cache. The max-age\nvalue is set to seconds with a maximum possible value of 31536000 which is one\nyear. You can do this in your Rails application by settingNow when your application serves an asset in production, the CDN will store the\nasset for up to a year. Since most CDNs also cache headers of the request, this\nCache-Control will be passed along to all future browsers seeking this asset,\nthe browser then knows that it can store this asset for a very long time before\nneeding to re-request it.Most CDNs will cache contents of an asset based on the complete URL. This means\nthat a request toWill be a completely different cache fromIf you want to set far future max-age in your Cache-Control (and you do),\nthen make sure when you change your assets that your cache is invalidated. For\nexample when changing the smiley face in an image from yellow to blue, you want\nall visitors of your site to get the new blue face. When using a CDN with the\nRails asset pipeline config.assets.digest is set to true by default so that\neach asset will have a different file name when it is changed. This way you\ndon't have to ever manually invalidate any items in your cache. By using a\ndifferent unique asset name instead, your users get the latest asset.","title":"4.4.2 Customize CDN Caching Behavior","anchor":"#customize-cdn-caching-behavior"},{"title":"5 Customizing the Pipeline","anchor":"#customizing-the-pipeline","code":[],"body":""},{"title":"5.1 CSS Compression","anchor":"#css-compression","code":["\nconfig.assets.css_compressor = :yui\n\nconfig.assets.css_compressor = :yui\n\nCopy\n","\nconfig.assets.css_compressor = :sass\n\nconfig.assets.css_compressor = :sass\n\nCopy\n"],"body":"One of the options for compressing CSS is YUI. The YUI CSS\ncompressor provides\nminification.The following line enables YUI compression, and requires the yui-compressor\ngem.The other option for compressing CSS if you have the sass-rails gem installed is"},{"code":["\nconfig.assets.js_compressor = :uglifier\n\nconfig.assets.js_compressor = :uglifier\n\nCopy\n"],"body":"Possible options for JavaScript compression are :closure, :uglifier and\n:yui. These require the use of the closure-compiler, uglifier or\nyui-compressor gems, respectively.Take the uglifier gem, for example.\nThis gem wraps UglifyJS (written for\nNodeJS) in Ruby. It compresses your code by removing white space and comments,\nshortening local variable names, and performing other micro-optimizations such\nas changing if and else statements to ternary operators where possible.The following line invokes uglifier for JavaScript compression.","title":"5.2 JavaScript Compression","anchor":"#javascript-compression"},{"title":"5.3 GZipping your assets","anchor":"#gzipping-your-assets","code":["\nconfig.assets.gzip = false # disable gzipped assets generation\n\nconfig.assets.gzip = false # disable gzipped assets generation\n\nCopy\n"],"body":"By default, gzipped version of compiled assets will be generated, along with\nthe non-gzipped version of assets. Gzipped assets help reduce the transmission\nof data over the wire. You can configure this by setting the gzip flag.Refer to your web server's documentation for instructions on how to serve gzipped assets."},{"title":"5.4 Using Your Own Compressor","anchor":"#using-your-own-compressor","code":["\nclass Transformer\n  def compress(string)\n    do_something_returning_a_string(string)\n  end\nend\n\nclass Transformer\n  def compress(string)\n    do_something_returning_a_string(string)\n  end\nend\n\nCopy\n","\nconfig.assets.css_compressor = Transformer.new\n\nconfig.assets.css_compressor = Transformer.new\n\nCopy\n"],"body":"The compressor config settings for CSS and JavaScript also take any object.\nThis object must have a compress method that takes a string as the sole\nargument and it must return a string.To enable this, pass a new object to the config option in application.rb:"},{"code":["\nconfig.assets.prefix = \"/some_other_path\"\n\nconfig.assets.prefix = \"/some_other_path\"\n\nCopy\n"],"body":"The public path that Sprockets uses by default is /assets.This can be changed to something else:This is a handy option if you are updating an older project that didn't use the\nasset pipeline and already uses this path or you wish to use this path for\na new resource.","title":"5.5 Changing the assets Path","anchor":"#changing-the-assets-path"},{"title":"5.6 X-Sendfile Headers","anchor":"#x-sendfile-headers","code":["\n# config.action_dispatch.x_sendfile_header = \"X-Sendfile\" # for Apache\n# config.action_dispatch.x_sendfile_header = 'X-Accel-Redirect' # for NGINX\n\n# config.action_dispatch.x_sendfile_header = \"X-Sendfile\" # for Apache\n# config.action_dispatch.x_sendfile_header = 'X-Accel-Redirect' # for NGINX\n\nCopy\n"],"body":"The X-Sendfile header is a directive to the web server to ignore the response\nfrom the application, and instead serve a specified file from disk. This option\nis off by default, but can be enabled if your server supports it. When enabled,\nthis passes responsibility for serving the file to the web server, which is\nfaster. Have a look at send_file\non how to use this feature.Apache and NGINX support this option, which can be enabled in\nconfig/environments/production.rb:"},{"title":"6 Assets Cache Store","anchor":"#assets-cache-store","code":["\nconfig.assets.configure do |env|\n  env.cache = ActiveSupport::Cache.lookup_store(:memory_store,\n                                                { size: 32.megabytes })\nend\n\nconfig.assets.configure do |env|\n  env.cache = ActiveSupport::Cache.lookup_store(:memory_store,\n                                                { size: 32.megabytes })\nend\n\nCopy\n","\nconfig.assets.configure do |env|\n  env.cache = ActiveSupport::Cache.lookup_store(:null_store)\nend\n\nconfig.assets.configure do |env|\n  env.cache = ActiveSupport::Cache.lookup_store(:null_store)\nend\n\nCopy\n"],"body":"By default, Sprockets caches assets in tmp/cache/assets in development\nand production environments. This can be changed as follows:To disable the assets cache store:"},{"code":[],"body":"Assets can also come from external sources in the form of gems.A good example of this is the jquery-rails gem.\nThis gem contains an engine class which inherits from Rails::Engine.\nBy doing this, Rails is informed that the directory for this\ngem may contain assets and the app/assets, lib/assets and\nvendor/assets directories of this engine are added to the search path of\nSprockets.","title":"7 Adding Assets to Your Gems","anchor":"#adding-assets-to-your-gems"},{"title":"8 Making Your Library or Gem a Pre-Processor","anchor":"#making-your-library-or-gem-a-pre-processor","code":["\nmodule AddComment\n  def self.call(input)\n    { data: input[:data] + \"/* Hello From my sprockets extension */\" }\n  end\nend\n\nmodule AddComment\n  def self.call(input)\n    { data: input[:data] + \"/* Hello From my sprockets extension */\" }\n  end\nend\n\nCopy\n","\nSprockets.register_preprocessor 'text/css', AddComment\n\nSprockets.register_preprocessor 'text/css', AddComment\n\nCopy\n"],"body":"Sprockets uses Processors, Transformers, Compressors, and Exporters to extend\nSprockets functionality. Have a look at\nExtending Sprockets\nto learn more. Here we registered a preprocessor to add a comment to the end\nof text/css (.css) files.Now that you have a module that modifies the input data, it's time to register\nit as a preprocessor for your mime type."}]