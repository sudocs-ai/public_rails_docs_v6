[{"code":[],"body":"One common task is to inspect the contents of a variable. Rails provides three different ways to do this:","title":"1 View Helpers for Debugging","anchor":"#view-helpers-for-debugging"},{"code":["\n<%= debug @article %>\n<p>\n  <b>Title:</b>\n  <%= @article.title %>\n</p>\n\n<%= debug @article %>\n<p>\n  <b>Title:</b>\n  <%= @article.title %>\n</p>\n\nCopy\n","\n--- !ruby/object Article\nattributes:\n  updated_at: 2008-09-05 22:55:47\n  body: It's a very helpful guide for debugging your Rails app.\n  title: Rails debugging guide\n  published: t\n  id: \"1\"\n  created_at: 2008-09-05 22:55:47\nattributes_cache: {}\n\n\nTitle: Rails debugging guide\n\n--- !ruby/object Article\nattributes:\n  updated_at: 2008-09-05 22:55:47\n  body: It's a very helpful guide for debugging your Rails app.\n  title: Rails debugging guide\n  published: t\n  id: \"1\"\n  created_at: 2008-09-05 22:55:47\nattributes_cache: {}\n\n\nTitle: Rails debugging guide\n\nCopy\n"],"body":"The debug helper will return a <pre> tag that renders the object using the YAML format. This will generate human-readable data from any object. For example, if you have this code in a view:You'll see something like this:","title":"1.1 debug","anchor":"#debug"},{"code":["\n<%= simple_format @article.to_yaml %>\n<p>\n  <b>Title:</b>\n  <%= @article.title %>\n</p>\n\n<%= simple_format @article.to_yaml %>\n<p>\n  <b>Title:</b>\n  <%= @article.title %>\n</p>\n\nCopy\n","\n--- !ruby/object Article\nattributes:\nupdated_at: 2008-09-05 22:55:47\nbody: It's a very helpful guide for debugging your Rails app.\ntitle: Rails debugging guide\npublished: t\nid: \"1\"\ncreated_at: 2008-09-05 22:55:47\nattributes_cache: {}\n\nTitle: Rails debugging guide\n\n--- !ruby/object Article\nattributes:\nupdated_at: 2008-09-05 22:55:47\nbody: It's a very helpful guide for debugging your Rails app.\ntitle: Rails debugging guide\npublished: t\nid: \"1\"\ncreated_at: 2008-09-05 22:55:47\nattributes_cache: {}\n\nTitle: Rails debugging guide\n\nCopy\n"],"body":"Alternatively, calling to_yaml on any object converts it to YAML. You can pass this converted object into the simple_format helper method to format the output. This is how debug does its magic.The above code will render something like this:","title":"1.2 to_yaml","anchor":"#to-yaml"},{"code":["\n<%= [1, 2, 3, 4, 5].inspect %>\n<p>\n  <b>Title:</b>\n  <%= @article.title %>\n</p>\n\n<%= [1, 2, 3, 4, 5].inspect %>\n<p>\n  <b>Title:</b>\n  <%= @article.title %>\n</p>\n\nCopy\n","\n[1, 2, 3, 4, 5]\n\nTitle: Rails debugging guide\n\n[1, 2, 3, 4, 5]\n\nTitle: Rails debugging guide\n\nCopy\n"],"body":"Another useful method for displaying object values is inspect, especially when working with arrays or hashes. This will print the object value as a string. For example:Will render:","title":"1.3 inspect","anchor":"#inspect"},{"code":[],"body":"It can also be useful to save information to log files at runtime. Rails maintains a separate log file for each runtime environment.","title":"2 The Logger","anchor":"#the-logger"},{"title":"2.1 What is the Logger?","anchor":"#what-is-the-logger-questionmark","code":["\nconfig.logger = Logger.new(STDOUT)\nconfig.logger = Log4r::Logger.new(\"Application Log\")\n\nconfig.logger = Logger.new(STDOUT)\nconfig.logger = Log4r::Logger.new(\"Application Log\")\n\nCopy\n","\nRails.logger = Logger.new(STDOUT)\nRails.logger = Log4r::Logger.new(\"Application Log\")\n\nRails.logger = Logger.new(STDOUT)\nRails.logger = Log4r::Logger.new(\"Application Log\")\n\nCopy\n"],"body":"Rails makes use of the ActiveSupport::Logger class to write log information. Other loggers, such as Log4r, may also be substituted.You can specify an alternative logger in config/application.rb or any other environment file, for example:Or in the Initializer section, add any of the following"},{"title":"2.2 Log Levels","anchor":"#log-levels","code":["\nconfig.log_level = :warn # In any environment initializer, or\nRails.logger.level = 0 # at any time\n\nconfig.log_level = :warn # In any environment initializer, or\nRails.logger.level = 0 # at any time\n\nCopy\n"],"body":"When something is logged, it's printed into the corresponding log if the log\nlevel of the message is equal to or higher than the configured log level. If you\nwant to know the current log level, you can call the Rails.logger.level\nmethod.The available log levels are: :debug, :info, :warn, :error, :fatal,\nand :unknown, corresponding to the log level numbers from 0 up to 5,\nrespectively. To change the default log level, useThis is useful when you want to log under development or staging without flooding your production log with unnecessary information."},{"title":"2.3 Sending Messages","anchor":"#sending-messages","code":["\nlogger.debug \"Person attributes hash: #{@person.attributes.inspect}\"\nlogger.info \"Processing the request...\"\nlogger.fatal \"Terminating application, raised unrecoverable error!!!\"\n\nlogger.debug \"Person attributes hash: #{@person.attributes.inspect}\"\nlogger.info \"Processing the request...\"\nlogger.fatal \"Terminating application, raised unrecoverable error!!!\"\n\nCopy\n","\nclass ArticlesController < ApplicationController\n  # ...\n\n  def create\n    @article = Article.new(article_params)\n    logger.debug \"New article: #{@article.attributes.inspect}\"\n    logger.debug \"Article should be valid: #{@article.valid?}\"\n\n    if @article.save\n      logger.debug \"The article was saved and now the user is going to be redirected...\"\n      redirect_to @article, notice: 'Article was successfully created.'\n    else\n      render :new\n    end\n  end\n\n  # ...\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body, :published)\n    end\nend\n\nclass ArticlesController < ApplicationController\n  # ...\n\n  def create\n    @article = Article.new(article_params)\n    logger.debug \"New article: #{@article.attributes.inspect}\"\n    logger.debug \"Article should be valid: #{@article.valid?}\"\n\n    if @article.save\n      logger.debug \"The article was saved and now the user is going to be redirected...\"\n      redirect_to @article, notice: 'Article was successfully created.'\n    else\n      render :new\n    end\n  end\n\n  # ...\n\n  private\n    def article_params\n      params.require(:article).permit(:title, :body, :published)\n    end\nend\n\nCopy\n","\nStarted POST \"/articles\" for 127.0.0.1 at 2018-10-18 20:09:23 -0400\nProcessing by ArticlesController#create as HTML\n  Parameters: {\"utf8\"=>\"✓\", \"authenticity_token\"=>\"XLveDrKzF1SwaiNRPTaMtkrsTzedtebPPkmxEFIU0ordLjICSnXsSNfrdMa4ccyBjuGwnnEiQhEoMN6H1Gtz3A==\", \"article\"=>{\"title\"=>\"Debugging Rails\", \"body\"=>\"I'm learning how to print in logs.\", \"published\"=>\"0\"}, \"commit\"=>\"Create Article\"}\nNew article: {\"id\"=>nil, \"title\"=>\"Debugging Rails\", \"body\"=>\"I'm learning how to print in logs.\", \"published\"=>false, \"created_at\"=>nil, \"updated_at\"=>nil}\nArticle should be valid: true\n   (0.0ms)  begin transaction\n  ↳ app/controllers/articles_controller.rb:31\n  Article Create (0.5ms)  INSERT INTO \"articles\" (\"title\", \"body\", \"published\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?, ?)  [[\"title\", \"Debugging Rails\"], [\"body\", \"I'm learning how to print in logs.\"], [\"published\", 0], [\"created_at\", \"2018-10-19 00:09:23.216549\"], [\"updated_at\", \"2018-10-19 00:09:23.216549\"]]\n  ↳ app/controllers/articles_controller.rb:31\n   (2.3ms)  commit transaction\n  ↳ app/controllers/articles_controller.rb:31\nThe article was saved and now the user is going to be redirected...\nRedirected to http://localhost:3000/articles/1\nCompleted 302 Found in 4ms (ActiveRecord: 0.8ms)\n\nStarted POST \"/articles\" for 127.0.0.1 at 2018-10-18 20:09:23 -0400\nProcessing by ArticlesController#create as HTML\n  Parameters: {\"utf8\"=>\"✓\", \"authenticity_token\"=>\"XLveDrKzF1SwaiNRPTaMtkrsTzedtebPPkmxEFIU0ordLjICSnXsSNfrdMa4ccyBjuGwnnEiQhEoMN6H1Gtz3A==\", \"article\"=>{\"title\"=>\"Debugging Rails\", \"body\"=>\"I'm learning how to print in logs.\", \"published\"=>\"0\"}, \"commit\"=>\"Create Article\"}\nNew article: {\"id\"=>nil, \"title\"=>\"Debugging Rails\", \"body\"=>\"I'm learning how to print in logs.\", \"published\"=>false, \"created_at\"=>nil, \"updated_at\"=>nil}\nArticle should be valid: true\n   (0.0ms)  begin transaction\n  ↳ app/controllers/articles_controller.rb:31\n  Article Create (0.5ms)  INSERT INTO \"articles\" (\"title\", \"body\", \"published\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?, ?)  [[\"title\", \"Debugging Rails\"], [\"body\", \"I'm learning how to print in logs.\"], [\"published\", 0], [\"created_at\", \"2018-10-19 00:09:23.216549\"], [\"updated_at\", \"2018-10-19 00:09:23.216549\"]]\n  ↳ app/controllers/articles_controller.rb:31\n   (2.3ms)  commit transaction\n  ↳ app/controllers/articles_controller.rb:31\nThe article was saved and now the user is going to be redirected...\nRedirected to http://localhost:3000/articles/1\nCompleted 302 Found in 4ms (ActiveRecord: 0.8ms)\n\nCopy\n"],"body":"To write in the current log use the logger.(debug|info|warn|error|fatal|unknown) method from within a controller, model, or mailer:Here's an example of a method instrumented with extra logging:Here's an example of the log generated when this controller action is executed:Adding extra logging like this makes it easy to search for unexpected or unusual behavior in your logs. If you add extra logging, be sure to make sensible use of log levels to avoid filling your production logs with useless trivia."},{"title":"2.4 Verbose Query Logs","anchor":"#verbose-query-logs","code":["\nirb(main):001:0> Article.pamplemousse\n  Article Load (0.4ms)  SELECT \"articles\".* FROM \"articles\"\n  Comment Load (0.2ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 1]]\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 2]]\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 3]]\n=> #<Comment id: 2, author: \"1\", body: \"Well, actually...\", article_id: 1, created_at: \"2018-10-19 00:56:10\", updated_at: \"2018-10-19 00:56:10\">\n\nirb(main):001:0> Article.pamplemousse\n  Article Load (0.4ms)  SELECT \"articles\".* FROM \"articles\"\n  Comment Load (0.2ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 1]]\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 2]]\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 3]]\n=> #<Comment id: 2, author: \"1\", body: \"Well, actually...\", article_id: 1, created_at: \"2018-10-19 00:56:10\", updated_at: \"2018-10-19 00:56:10\">\n\nCopy\n","\nirb(main):003:0> Article.pamplemousse\n  Article Load (0.2ms)  SELECT \"articles\".* FROM \"articles\"\n  ↳ app/models/article.rb:5\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 1]]\n  ↳ app/models/article.rb:6\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 2]]\n  ↳ app/models/article.rb:6\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 3]]\n  ↳ app/models/article.rb:6\n=> #<Comment id: 2, author: \"1\", body: \"Well, actually...\", article_id: 1, created_at: \"2018-10-19 00:56:10\", updated_at: \"2018-10-19 00:56:10\">\n\nirb(main):003:0> Article.pamplemousse\n  Article Load (0.2ms)  SELECT \"articles\".* FROM \"articles\"\n  ↳ app/models/article.rb:5\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 1]]\n  ↳ app/models/article.rb:6\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 2]]\n  ↳ app/models/article.rb:6\n  Comment Load (0.1ms)  SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"article_id\" = ?  [[\"article_id\", 3]]\n  ↳ app/models/article.rb:6\n=> #<Comment id: 2, author: \"1\", body: \"Well, actually...\", article_id: 1, created_at: \"2018-10-19 00:56:10\", updated_at: \"2018-10-19 00:56:10\">\n\nCopy\n"],"body":"When looking at database query output in logs, it may not be immediately clear why multiple database queries are triggered when a single method is called:After running ActiveRecord::Base.verbose_query_logs = true in the bin/rails console session to enable verbose query logs and running the method again, it becomes obvious what single line of code is generating all these discrete database calls:Below each database statement you can see arrows pointing to the specific source filename (and line number) of the method that resulted in a database call. This can help you identify and address performance problems caused by N+1 queries: single database queries that generates multiple additional queries.Verbose query logs are enabled by default in the development environment logs after Rails 5.2."},{"title":"2.5 Tagged Logging","anchor":"#tagged-logging","code":["\nlogger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))\nlogger.tagged(\"BCX\") { logger.info \"Stuff\" }                            # Logs \"[BCX] Stuff\"\nlogger.tagged(\"BCX\", \"Jason\") { logger.info \"Stuff\" }                   # Logs \"[BCX] [Jason] Stuff\"\nlogger.tagged(\"BCX\") { logger.tagged(\"Jason\") { logger.info \"Stuff\" } } # Logs \"[BCX] [Jason] Stuff\"\n\nlogger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))\nlogger.tagged(\"BCX\") { logger.info \"Stuff\" }                            # Logs \"[BCX] Stuff\"\nlogger.tagged(\"BCX\", \"Jason\") { logger.info \"Stuff\" }                   # Logs \"[BCX] [Jason] Stuff\"\nlogger.tagged(\"BCX\") { logger.tagged(\"Jason\") { logger.info \"Stuff\" } } # Logs \"[BCX] [Jason] Stuff\"\n\nCopy\n"],"body":"When running multi-user, multi-account applications, it's often useful\nto be able to filter the logs using some custom rules. TaggedLogging\nin Active Support helps you do exactly that by stamping log lines with subdomains, request ids, and anything else to aid debugging such applications."},{"code":["\nlogger.debug \"Person attributes hash: #{@person.attributes.inspect}\"\n\nlogger.debug \"Person attributes hash: #{@person.attributes.inspect}\"\n\nCopy\n","\nlogger.debug {\"Person attributes hash: #{@person.attributes.inspect}\"}\n\nlogger.debug {\"Person attributes hash: #{@person.attributes.inspect}\"}\n\nCopy\n"],"body":"Logging will always have a small impact on the performance of your Rails app,\nparticularly when logging to disk. Additionally, there are a few subtleties:Using the :debug level will have a greater performance penalty than :fatal,\nas a far greater number of strings are being evaluated and written to the\nlog output (e.g. disk).Another potential pitfall is too many calls to Logger in your code:In the above example, there will be a performance impact even if the allowed\noutput level doesn't include debug. The reason is that Ruby has to evaluate\nthese strings, which includes instantiating the somewhat heavy String object\nand interpolating the variables.Therefore, it's recommended to pass blocks to the logger methods, as these are\nonly evaluated if the output level is the same as — or included in — the allowed level\n(i.e. lazy loading). The same code rewritten would be:The contents of the block, and therefore the string interpolation, are only\nevaluated if debug is enabled. This performance savings are only really\nnoticeable with large amounts of logging, but it's a good practice to employ.","title":"2.6 Impact of Logs on Performance","anchor":"#impact-of-logs-on-performance"},{"title":"3 Debugging with the byebug gem","anchor":"#debugging-with-the-byebug-gem","code":[],"body":"When your code is behaving in unexpected ways, you can try printing to logs or\nthe console to diagnose the problem. Unfortunately, there are times when this\nsort of error tracking is not effective in finding the root cause of a problem.\nWhen you actually need to journey into your running source code, the debugger\nis your best companion.The debugger can also help you if you want to learn about the Rails source code\nbut don't know where to start. Just debug any request to your application and\nuse this guide to learn how to move from the code you have written into the\nunderlying Rails code."},{"title":"3.1 Setup","anchor":"#setup","code":["\n$ gem install byebug\n\ngem install byebug\n\nCopy\n","\nclass PeopleController < ApplicationController\n  def new\n    byebug\n    @person = Person.new\n  end\nend\n\nclass PeopleController < ApplicationController\n  def new\n    byebug\n    @person = Person.new\n  end\nend\n\nCopy\n"],"body":"You can use the byebug gem to set breakpoints and step through live code in\nRails. To install it, just run:Inside any Rails application you can then invoke the debugger by calling the\nbyebug method.Here's an example:"},{"code":["\n[1, 10] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n\n(byebug)\n\n[1, 10] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n\n(byebug)\n\nCopy\n","\n=> Booting Puma\n=> Rails 6.0.0 application starting in development\n=> Run `bin/rails server --help` for more startup options\nPuma starting in single mode...\n* Version 3.12.1 (ruby 2.5.7-p206), codename: Llamas in Pajamas\n* Min threads: 5, max threads: 5\n* Environment: development\n* Listening on tcp://localhost:3000\nUse Ctrl-C to stop\nStarted GET \"/\" for 127.0.0.1 at 2014-04-11 13:11:48 +0200\n  ActiveRecord::SchemaMigration Load (0.2ms)  SELECT \"schema_migrations\".* FROM \"schema_migrations\"\nProcessing by ArticlesController#index as HTML\n\n[3, 12] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n(byebug)\n\n=> Booting Puma\n=> Rails 6.0.0 application starting in development\n=> Run `bin/rails server --help` for more startup options\nPuma starting in single mode...\n* Version 3.12.1 (ruby 2.5.7-p206), codename: Llamas in Pajamas\n* Min threads: 5, max threads: 5\n* Environment: development\n* Listening on tcp://localhost:3000\nUse Ctrl-C to stop\nStarted GET \"/\" for 127.0.0.1 at 2014-04-11 13:11:48 +0200\n  ActiveRecord::SchemaMigration Load (0.2ms)  SELECT \"schema_migrations\".* FROM \"schema_migrations\"\nProcessing by ArticlesController#index as HTML\n\n[3, 12] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n(byebug)\n\nCopy\n","\n(byebug) help\n\n  break      -- Sets breakpoints in the source code\n  catch      -- Handles exception catchpoints\n  condition  -- Sets conditions on breakpoints\n  continue   -- Runs until program ends, hits a breakpoint or reaches a line\n  debug      -- Spawns a subdebugger\n  delete     -- Deletes breakpoints\n  disable    -- Disables breakpoints or displays\n  display    -- Evaluates expressions every time the debugger stops\n  down       -- Moves to a lower frame in the stack trace\n  edit       -- Edits source files\n  enable     -- Enables breakpoints or displays\n  finish     -- Runs the program until frame returns\n  frame      -- Moves to a frame in the call stack\n  help       -- Helps you using byebug\n  history    -- Shows byebug's history of commands\n  info       -- Shows several informations about the program being debugged\n  interrupt  -- Interrupts the program\n  irb        -- Starts an IRB session\n  kill       -- Sends a signal to the current process\n  list       -- Lists lines of source code\n  method     -- Shows methods of an object, class or module\n  next       -- Runs one or more lines of code\n  pry        -- Starts a Pry session\n  quit       -- Exits byebug\n  restart    -- Restarts the debugged program\n  save       -- Saves current byebug session to a file\n  set        -- Modifies byebug settings\n  show       -- Shows byebug settings\n  source     -- Restores a previously saved byebug session\n  step       -- Steps into blocks or methods one or more times\n  thread     -- Commands to manipulate threads\n  tracevar   -- Enables tracing of a global variable\n  undisplay  -- Stops displaying all or some expressions when program stops\n  untracevar -- Stops tracing a global variable\n  up         -- Moves to a higher frame in the stack trace\n  var        -- Shows variables and its values\n  where      -- Displays the backtrace\n\n(byebug)\n\n(byebug) help\n\n  break      -- Sets breakpoints in the source code\n  catch      -- Handles exception catchpoints\n  condition  -- Sets conditions on breakpoints\n  continue   -- Runs until program ends, hits a breakpoint or reaches a line\n  debug      -- Spawns a subdebugger\n  delete     -- Deletes breakpoints\n  disable    -- Disables breakpoints or displays\n  display    -- Evaluates expressions every time the debugger stops\n  down       -- Moves to a lower frame in the stack trace\n  edit       -- Edits source files\n  enable     -- Enables breakpoints or displays\n  finish     -- Runs the program until frame returns\n  frame      -- Moves to a frame in the call stack\n  help       -- Helps you using byebug\n  history    -- Shows byebug's history of commands\n  info       -- Shows several informations about the program being debugged\n  interrupt  -- Interrupts the program\n  irb        -- Starts an IRB session\n  kill       -- Sends a signal to the current process\n  list       -- Lists lines of source code\n  method     -- Shows methods of an object, class or module\n  next       -- Runs one or more lines of code\n  pry        -- Starts a Pry session\n  quit       -- Exits byebug\n  restart    -- Restarts the debugged program\n  save       -- Saves current byebug session to a file\n  set        -- Modifies byebug settings\n  show       -- Shows byebug settings\n  source     -- Restores a previously saved byebug session\n  step       -- Steps into blocks or methods one or more times\n  thread     -- Commands to manipulate threads\n  tracevar   -- Enables tracing of a global variable\n  undisplay  -- Stops displaying all or some expressions when program stops\n  untracevar -- Stops tracing a global variable\n  up         -- Moves to a higher frame in the stack trace\n  var        -- Shows variables and its values\n  where      -- Displays the backtrace\n\n(byebug)\n\nCopy\n","\n(byebug) l-\n\n[1, 10] in /PathTo/project/app/controllers/articles_controller.rb\n   1  class ArticlesController < ApplicationController\n   2    before_action :set_article, only: [:show, :edit, :update, :destroy]\n   3\n   4    # GET /articles\n   5    # GET /articles.json\n   6    def index\n   7      byebug\n   8      @articles = Article.find_recent\n   9\n   10     respond_to do |format|\n\n(byebug) l-\n\n[1, 10] in /PathTo/project/app/controllers/articles_controller.rb\n   1  class ArticlesController < ApplicationController\n   2    before_action :set_article, only: [:show, :edit, :update, :destroy]\n   3\n   4    # GET /articles\n   5    # GET /articles.json\n   6    def index\n   7      byebug\n   8      @articles = Article.find_recent\n   9\n   10     respond_to do |format|\n\nCopy\n","\n(byebug) list=\n\n[3, 12] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n(byebug)\n\n(byebug) list=\n\n[3, 12] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n(byebug)\n\nCopy\n"],"body":"As soon as your application calls the byebug method, the debugger will be\nstarted in a debugger shell inside the terminal window where you launched your\napplication server, and you will be placed at the debugger's prompt (byebug).\nBefore the prompt, the code around the line that is about to be run will be\ndisplayed and the current line will be marked by '=>', like this:If you got there by a browser request, the browser tab containing the request\nwill be hung until the debugger has finished and the trace has finished\nprocessing the entire request.For example:Now it's time to explore your application. A good place to start is\nby asking the debugger for help. Type: helpTo see the previous ten lines you should type list- (or l-).This way you can move inside the file and see the code above the line where you\nadded the byebug call. Finally, to see where you are in the code again you can\ntype list=","title":"3.2 The Shell","anchor":"#the-shell"},{"code":["\n(byebug) where\n--> #0  ArticlesController.index\n      at /PathToProject/app/controllers/articles_controller.rb:8\n    #1  ActionController::BasicImplicitRender.send_action(method#String, *args#Array)\n      at /PathToGems/actionpack-5.1.0/lib/action_controller/metal/basic_implicit_render.rb:4\n    #2  AbstractController::Base.process_action(action#NilClass, *args#Array)\n      at /PathToGems/actionpack-5.1.0/lib/abstract_controller/base.rb:181\n    #3  ActionController::Rendering.process_action(action, *args)\n      at /PathToGems/actionpack-5.1.0/lib/action_controller/metal/rendering.rb:30\n...\n\n(byebug) where\n--> #0  ArticlesController.index\n      at /PathToProject/app/controllers/articles_controller.rb:8\n    #1  ActionController::BasicImplicitRender.send_action(method#String, *args#Array)\n      at /PathToGems/actionpack-5.1.0/lib/action_controller/metal/basic_implicit_render.rb:4\n    #2  AbstractController::Base.process_action(action#NilClass, *args#Array)\n      at /PathToGems/actionpack-5.1.0/lib/abstract_controller/base.rb:181\n    #3  ActionController::Rendering.process_action(action, *args)\n      at /PathToGems/actionpack-5.1.0/lib/action_controller/metal/rendering.rb:30\n...\n\nCopy\n","\n(byebug) frame 2\n\n[176, 185] in /PathToGems/actionpack-5.1.0/lib/abstract_controller/base.rb\n   176:       # is the intended way to override action dispatching.\n   177:       #\n   178:       # Notice that the first argument is the method to be dispatched\n   179:       # which is *not* necessarily the same as the action name.\n   180:       def process_action(method_name, *args)\n=> 181:         send_action(method_name, *args)\n   182:       end\n   183:\n   184:       # Actually call the method associated with the action. Override\n   185:       # this method if you wish to change how action methods are called,\n(byebug)\n\n(byebug) frame 2\n\n[176, 185] in /PathToGems/actionpack-5.1.0/lib/abstract_controller/base.rb\n   176:       # is the intended way to override action dispatching.\n   177:       #\n   178:       # Notice that the first argument is the method to be dispatched\n   179:       # which is *not* necessarily the same as the action name.\n   180:       def process_action(method_name, *args)\n=> 181:         send_action(method_name, *args)\n   182:       end\n   183:\n   184:       # Actually call the method associated with the action. Override\n   185:       # this method if you wish to change how action methods are called,\n(byebug)\n\nCopy\n"],"body":"When you start debugging your application, you will be placed in different\ncontexts as you go through the different parts of the stack.The debugger creates a context when a stopping point or an event is reached. The\ncontext has information about the suspended program which enables the debugger\nto inspect the frame stack, evaluate variables from the perspective of the\ndebugged program, and know the place where the debugged program is stopped.At any time you can call the backtrace command (or its alias where) to print\nthe backtrace of the application. This can be very helpful to know how you got\nwhere you are. If you ever wondered about how you got somewhere in your code,\nthen backtrace will supply the answer.The current frame is marked with -->. You can move anywhere you want in this\ntrace (thus changing the context) by using the frame n command, where n is\nthe specified frame number. If you do that, byebug will display your new\ncontext.The available variables are the same as if you were running the code line by\nline. After all, that's what debugging is.You can also use up [n] and down [n] commands in order to change the context\nn frames up or down the stack respectively. n defaults to one. Up in this\ncase is towards higher-numbered stack frames, and down is towards lower-numbered\nstack frames.","title":"3.3 The Context","anchor":"#the-context"},{"title":"3.4 Threads","anchor":"#threads","code":[],"body":"The debugger can list, stop, resume, and switch between running threads by using\nthe thread command (or the abbreviated th). This command has a handful of\noptions:This command is very helpful when you are debugging concurrent threads and need\nto verify that there are no race conditions in your code."},{"title":"3.5 Inspecting Variables","anchor":"#debugging-with-the-byebug-gem-inspecting-variables","code":["\n[3, 12] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n\n(byebug) instance_variables\n[:@_action_has_layout, :@_routes, :@_request, :@_response, :@_lookup_context,\n :@_action_name, :@_response_body, :@marked_for_same_origin_verification,\n :@_config]\n\n[3, 12] in /PathTo/project/app/controllers/articles_controller.rb\n    3:\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     byebug\n=>  8:     @articles = Article.find_recent\n    9:\n   10:     respond_to do |format|\n   11:       format.html # index.html.erb\n   12:       format.json { render json: @articles }\n\n(byebug) instance_variables\n[:@_action_has_layout, :@_routes, :@_request, :@_response, :@_lookup_context,\n :@_action_name, :@_response_body, :@marked_for_same_origin_verification,\n :@_config]\n\nCopy\n","\n(byebug) next\n\n[5, 14] in /PathTo/project/app/controllers/articles_controller.rb\n   5     # GET /articles.json\n   6     def index\n   7       byebug\n   8       @articles = Article.find_recent\n   9\n=> 10      respond_to do |format|\n   11        format.html # index.html.erb\n   12        format.json { render json: @articles }\n   13      end\n   14    end\n   15\n(byebug)\n\n(byebug) next\n\n[5, 14] in /PathTo/project/app/controllers/articles_controller.rb\n   5     # GET /articles.json\n   6     def index\n   7       byebug\n   8       @articles = Article.find_recent\n   9\n=> 10      respond_to do |format|\n   11        format.html # index.html.erb\n   12        format.json { render json: @articles }\n   13      end\n   14    end\n   15\n(byebug)\n\nCopy\n","\n(byebug) instance_variables\n[:@_action_has_layout, :@_routes, :@_request, :@_response, :@_lookup_context,\n :@_action_name, :@_response_body, :@marked_for_same_origin_verification,\n :@_config, :@articles]\n\n(byebug) instance_variables\n[:@_action_has_layout, :@_routes, :@_request, :@_response, :@_lookup_context,\n :@_action_name, :@_response_body, :@marked_for_same_origin_verification,\n :@_config, :@articles]\n\nCopy\n","\n(byebug) help var\n\n  [v]ar <subcommand>\n\n  Shows variables and its values\n\n\n  var all      -- Shows local, global and instance variables of self.\n  var args     -- Information about arguments of the current scope\n  var const    -- Shows constants of an object.\n  var global   -- Shows global variables.\n  var instance -- Shows instance variables of self or a specific object.\n  var local    -- Shows local variables in current scope.\n\n\n(byebug) help var\n\n  [v]ar <subcommand>\n\n  Shows variables and its values\n\n\n  var all      -- Shows local, global and instance variables of self.\n  var args     -- Information about arguments of the current scope\n  var const    -- Shows constants of an object.\n  var global   -- Shows global variables.\n  var instance -- Shows instance variables of self or a specific object.\n  var local    -- Shows local variables in current scope.\n\n\nCopy\n","\n(byebug) var local\n(byebug)\n\n(byebug) var local\n(byebug)\n\nCopy\n","\n(byebug) var instance Article.new\n@_start_transaction_state = nil\n@aggregation_cache = {}\n@association_cache = {}\n@attributes = #<ActiveRecord::AttributeSet:0x007fd0682a9b18 @attributes={\"id\"=>#<ActiveRecord::Attribute::FromDatabase:0x007fd0682a9a00 @name=\"id\", @value_be...\n@destroyed = false\n@destroyed_by_association = nil\n@marked_for_destruction = false\n@new_record = true\n@readonly = false\n@transaction_state = nil\n\n(byebug) var instance Article.new\n@_start_transaction_state = nil\n@aggregation_cache = {}\n@association_cache = {}\n@attributes = #<ActiveRecord::AttributeSet:0x007fd0682a9b18 @attributes={\"id\"=>#<ActiveRecord::Attribute::FromDatabase:0x007fd0682a9a00 @name=\"id\", @value_be...\n@destroyed = false\n@destroyed_by_association = nil\n@marked_for_destruction = false\n@new_record = true\n@readonly = false\n@transaction_state = nil\n\nCopy\n","\n(byebug) display @articles\n1: @articles = nil\n\n(byebug) display @articles\n1: @articles = nil\n\nCopy\n"],"body":"Any expression can be evaluated in the current context. To evaluate an\nexpression, just type it!This example shows how you can print the instance variables defined within the\ncurrent context:As you may have figured out, all of the variables that you can access from a\ncontroller are displayed. This list is dynamically updated as you execute code.\nFor example, run the next line using next (you'll learn more about this\ncommand later in this guide).And then ask again for the instance_variables:Now @articles is included in the instance variables, because the line defining\nit was executed.The var method is the most convenient way to show variables and their values.\nLet's have byebug help us with it.This is a great way to inspect the values of the current context variables. For\nexample, to check that we have no local variables currently defined:You can also inspect for an object method this way:You can also use display to start watching variables. This is a good way of\ntracking the values of a variable while the execution goes on.The variables inside the displayed list will be printed with their values after\nyou move in the stack. To stop displaying a variable use undisplay n where\nn is the variable number (1 in the last example)."},{"title":"3.6 Step by Step","anchor":"#step-by-step","code":["\nStarted GET \"/\" for 127.0.0.1 at 2014-04-11 13:39:23 +0200\nProcessing by ArticlesController#index as HTML\n\n[1, 6] in /PathToProject/app/models/article.rb\n   1: class Article < ApplicationRecord\n   2:   def self.find_recent(limit = 10)\n   3:     byebug\n=> 4:     where('created_at > ?', 1.week.ago).limit(limit)\n   5:   end\n   6: end\n\n(byebug)\n\nStarted GET \"/\" for 127.0.0.1 at 2014-04-11 13:39:23 +0200\nProcessing by ArticlesController#index as HTML\n\n[1, 6] in /PathToProject/app/models/article.rb\n   1: class Article < ApplicationRecord\n   2:   def self.find_recent(limit = 10)\n   3:     byebug\n=> 4:     where('created_at > ?', 1.week.ago).limit(limit)\n   5:   end\n   6: end\n\n(byebug)\n\nCopy\n","\n(byebug) next\n[4, 13] in /PathToProject/app/controllers/articles_controller.rb\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     @articles = Article.find_recent\n    8:\n=>  9:     respond_to do |format|\n   10:       format.html # index.html.erb\n   11:       format.json { render json: @articles }\n   12:     end\n   13:   end\n\n(byebug)\n\n(byebug) next\n[4, 13] in /PathToProject/app/controllers/articles_controller.rb\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     @articles = Article.find_recent\n    8:\n=>  9:     respond_to do |format|\n   10:       format.html # index.html.erb\n   11:       format.json { render json: @articles }\n   12:     end\n   13:   end\n\n(byebug)\n\nCopy\n","\n(byebug) step\n\n[49, 58] in /PathToGems/activesupport-5.1.0/lib/active_support/core_ext/numeric/time.rb\n   49:\n   50:   # Returns a Duration instance matching the number of weeks provided.\n   51:   #\n   52:   #   2.weeks # => 14 days\n   53:   def weeks\n=> 54:     ActiveSupport::Duration.weeks(self)\n   55:   end\n   56:   alias :week :weeks\n   57:\n   58:   # Returns a Duration instance matching the number of fortnights provided.\n(byebug)\n\n(byebug) step\n\n[49, 58] in /PathToGems/activesupport-5.1.0/lib/active_support/core_ext/numeric/time.rb\n   49:\n   50:   # Returns a Duration instance matching the number of weeks provided.\n   51:   #\n   52:   #   2.weeks # => 14 days\n   53:   def weeks\n=> 54:     ActiveSupport::Duration.weeks(self)\n   55:   end\n   56:   alias :week :weeks\n   57:\n   58:   # Returns a Duration instance matching the number of fortnights provided.\n(byebug)\n\nCopy\n"],"body":"Now you should know where you are in the running trace and be able to print the\navailable variables. But let's continue and move on with the application\nexecution.Use step (abbreviated s) to continue running your program until the next\nlogical stopping point and return control to the debugger. next is similar to\nstep, but while step stops at the next line of code executed, doing just a\nsingle step, next moves to the next line without descending inside methods.For example, consider the following situation:If we use next, we won't go deep inside method calls. Instead, byebug will\ngo to the next line within the same context. In this case, it is the last line\nof the current method, so byebug will return to the next line of the caller\nmethod.If we use step in the same situation, byebug will literally go to the next\nRuby instruction to be executed -- in this case, Active Support's week method.This is one of the best ways to find bugs in your code."},{"title":"3.7 Breakpoints","anchor":"#breakpoints","code":["\n[4, 13] in /PathToProject/app/controllers/articles_controller.rb\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     @articles = Article.find_recent\n    8:\n=>  9:     respond_to do |format|\n   10:       format.html # index.html.erb\n   11:       format.json { render json: @articles }\n   12:     end\n   13:   end\n\n(byebug) break 11\nSuccessfully created breakpoint with id 1\n\n\n[4, 13] in /PathToProject/app/controllers/articles_controller.rb\n    4:   # GET /articles\n    5:   # GET /articles.json\n    6:   def index\n    7:     @articles = Article.find_recent\n    8:\n=>  9:     respond_to do |format|\n   10:       format.html # index.html.erb\n   11:       format.json { render json: @articles }\n   12:     end\n   13:   end\n\n(byebug) break 11\nSuccessfully created breakpoint with id 1\n\n\nCopy\n","\n(byebug) info breakpoints\nNum Enb What\n1   y   at /PathToProject/app/controllers/articles_controller.rb:11\n\n(byebug) info breakpoints\nNum Enb What\n1   y   at /PathToProject/app/controllers/articles_controller.rb:11\n\nCopy\n","\n(byebug) delete 1\n(byebug) info breakpoints\nNo breakpoints.\n\n(byebug) delete 1\n(byebug) info breakpoints\nNo breakpoints.\n\nCopy\n"],"body":"A breakpoint makes your application stop whenever a certain point in the program\nis reached. The debugger shell is invoked in that line.You can add breakpoints dynamically with the command break (or just b).\nThere are 3 possible ways of adding breakpoints manually:For example, in the previous situationUse info breakpoints to list breakpoints. If you supply a number, it lists\nthat breakpoint. Otherwise it lists all breakpoints.To delete breakpoints: use the command delete n to remove the breakpoint\nnumber n. If no number is specified, it deletes all breakpoints that are\ncurrently active.You can also enable or disable breakpoints:"},{"code":[],"body":"The command catch exception-name (or just cat exception-name) can be used to\nintercept an exception of type exception-name when there would otherwise be no\nhandler for it.To list all active catchpoints use catch.","title":"3.8 Catching Exceptions","anchor":"#catching-exceptions"},{"title":"3.9 Resuming Execution","anchor":"#resuming-execution","code":[],"body":"There are two ways to resume execution of an application that is stopped in the\ndebugger:"},{"code":[],"body":"Two commands allow you to open code from the debugger into an editor:","title":"3.10 Editing","anchor":"#editing"},{"code":[],"body":"To exit the debugger, use the quit command (abbreviated to q). Or, type q!\nto bypass the Really quit? (y/n) prompt and exit unconditionally.A simple quit tries to terminate all threads in effect. Therefore your server\nwill be stopped and you will have to start it again.","title":"3.11 Quitting","anchor":"#quitting"},{"title":"3.12 Settings","anchor":"#debugging-with-the-byebug-gem-settings","code":["\n(byebug) help set\n\n  set <setting> <value>\n\n  Modifies byebug settings\n\n  Boolean values take \"on\", \"off\", \"true\", \"false\", \"1\" or \"0\". If you\n  don't specify a value, the boolean setting will be enabled. Conversely,\n  you can use \"set no<setting>\" to disable them.\n\n  You can see these environment settings with the \"show\" command.\n\n  List of supported settings:\n\n  autosave       -- Automatically save command history record on exit\n  autolist       -- Invoke list command on every stop\n  width          -- Number of characters per line in byebug's output\n  autoirb        -- Invoke IRB on every stop\n  basename       -- <file>:<line> information after every stop uses short paths\n  linetrace      -- Enable line execution tracing\n  autopry        -- Invoke Pry on every stop\n  stack_on_error -- Display stack trace when `eval` raises an exception\n  fullpath       -- Display full file names in backtraces\n  histfile       -- File where cmd history is saved to. Default: ./.byebug_history\n  listsize       -- Set number of source lines to list by default\n  post_mortem    -- Enable/disable post-mortem mode\n  callstyle      -- Set how you want method call parameters to be displayed\n  histsize       -- Maximum number of commands that can be stored in byebug history\n  savefile       -- File where settings are saved to. Default: ~/.byebug_save\n\n(byebug) help set\n\n  set <setting> <value>\n\n  Modifies byebug settings\n\n  Boolean values take \"on\", \"off\", \"true\", \"false\", \"1\" or \"0\". If you\n  don't specify a value, the boolean setting will be enabled. Conversely,\n  you can use \"set no<setting>\" to disable them.\n\n  You can see these environment settings with the \"show\" command.\n\n  List of supported settings:\n\n  autosave       -- Automatically save command history record on exit\n  autolist       -- Invoke list command on every stop\n  width          -- Number of characters per line in byebug's output\n  autoirb        -- Invoke IRB on every stop\n  basename       -- <file>:<line> information after every stop uses short paths\n  linetrace      -- Enable line execution tracing\n  autopry        -- Invoke Pry on every stop\n  stack_on_error -- Display stack trace when `eval` raises an exception\n  fullpath       -- Display full file names in backtraces\n  histfile       -- File where cmd history is saved to. Default: ./.byebug_history\n  listsize       -- Set number of source lines to list by default\n  post_mortem    -- Enable/disable post-mortem mode\n  callstyle      -- Set how you want method call parameters to be displayed\n  histsize       -- Maximum number of commands that can be stored in byebug history\n  savefile       -- File where settings are saved to. Default: ~/.byebug_save\n\nCopy\n","\nset callstyle short\nset listsize 25\n\nset callstyle short\nset listsize 25\n\nCopy\n"],"body":"byebug has a few available options to tweak its behavior:"},{"code":[],"body":"Web Console is a bit like byebug, but it runs in the browser. In any page you\nare developing, you can request a console in the context of a view or a\ncontroller. The console would be rendered next to your HTML content.","title":"4 Debugging with the web-console gem","anchor":"#debugging-with-the-web-console-gem"},{"title":"4.1 Console","anchor":"#console","code":["\nclass PostsController < ApplicationController\n  def new\n    console\n    @post = Post.new\n  end\nend\n\nclass PostsController < ApplicationController\n  def new\n    console\n    @post = Post.new\n  end\nend\n\nCopy\n","\n<% console %>\n\n<h2>New Post</h2>\n\n<% console %>\n\n<h2>New Post</h2>\n\nCopy\n"],"body":"Inside any controller action or view, you can invoke the console by\ncalling the console method.For example, in a controller:Or in a view:This will render a console inside your view. You don't need to care about the\nlocation of the console call; it won't be rendered on the spot of its\ninvocation but next to your HTML content.The console executes pure Ruby code: You can define and instantiate\ncustom classes, create new models, and inspect variables."},{"title":"4.2 Inspecting Variables","anchor":"#debugging-with-the-web-console-gem-inspecting-variables","code":[],"body":"You can invoke instance_variables to list all the instance variables\navailable in your context. If you want to list all the local variables, you can\ndo that with local_variables."},{"title":"4.3 Settings","anchor":"#debugging-with-the-web-console-gem-settings","code":[],"body":"Since web-console evaluates plain Ruby code remotely on the server, don't try\nto use it in production."},{"title":"5 Debugging Memory Leaks","anchor":"#debugging-memory-leaks","code":[],"body":"A Ruby application (on Rails or not), can leak memory — either in the Ruby code\nor at the C code level.In this section, you will learn how to find and fix such leaks by using tools\nsuch as Valgrind."},{"title":"5.1 Valgrind","anchor":"#valgrind","code":[],"body":"Valgrind is an application for detecting C-based memory\nleaks and race conditions.There are Valgrind tools that can automatically detect many memory management\nand threading bugs, and profile your programs in detail. For example, if a C\nextension in the interpreter calls malloc() but doesn't properly call\nfree(), this memory won't be available until the app terminates.For further information on how to install Valgrind and use with Ruby, refer to\nValgrind and Ruby\nby Evan Weaver."},{"title":"5.2 Find a Memory Leak","anchor":"#find-a-memory-leak","code":[],"body":"There is an excellent article about detecting and fixing memory leaks at Derailed, which you can read here."},{"title":"6 Plugins for Debugging","anchor":"#plugins-for-debugging","code":[],"body":"There are some Rails plugins to help you to find errors and debug your\napplication. Here is a list of useful plugins for debugging:"},{"code":[],"body":"","title":"7 References","anchor":"#references"}]