[{"code":[],"body":"Rails automatically allows various operations to be performed at the same time.When using a threaded web server, such as the default Puma, multiple HTTP\nrequests will be served simultaneously, with each request provided its own\ncontroller instance.Threaded Active Job adapters, including the built-in Async, will likewise\nexecute several jobs at the same time. Action Cable channels are managed this\nway too.These mechanisms all involve multiple threads, each managing work for a unique\ninstance of some object (controller, job, channel), while sharing the global\nprocess space (such as classes and their configurations, and global variables).\nAs long as your code doesn't modify any of those shared things, it can mostly\nignore that other threads exist.The rest of this guide describes the mechanisms Rails uses to make it \"mostly\nignorable\", and how extensions and applications with special needs can use them.","title":"1 Automatic Concurrency","anchor":"#automatic-concurrency"},{"title":"2 Executor","anchor":"#executor","code":[],"body":"The Rails Executor separates application code from framework code: any time the\nframework invokes code you've written in your application, it will be wrapped by\nthe Executor.The Executor consists of two callbacks: to_run and to_complete. The Run\ncallback is called before the application code, and the Complete callback is\ncalled after."},{"title":"2.1 Default callbacks","anchor":"#default-callbacks","code":[],"body":"In a default Rails application, the Executor callbacks are used to:Prior to Rails 5.0, some of these were handled by separate Rack middleware\nclasses (such as ActiveRecord::ConnectionAdapters::ConnectionManagement), or\ndirectly wrapping code with methods like\nActiveRecord::Base.connection_pool.with_connection. The Executor replaces\nthese with a single more abstract interface."},{"title":"2.2 Wrapping application code","anchor":"#wrapping-application-code","code":["\nRails.application.executor.wrap do\n  # call application code here\nend\n\nRails.application.executor.wrap do\n  # call application code here\nend\n\nCopy\n","\nThread.new do\n  Rails.application.executor.wrap do\n    # your code here\n  end\nend\n\nThread.new do\n  Rails.application.executor.wrap do\n    # your code here\n  end\nend\n\nCopy\n","\nThread.new do\n  execution_context = Rails.application.executor.run!\n  # your code here\nensure\n  execution_context.complete! if execution_context\nend\n\nThread.new do\n  execution_context = Rails.application.executor.run!\n  # your code here\nensure\n  execution_context.complete! if execution_context\nend\n\nCopy\n"],"body":"If you're writing a library or component that will invoke application code, you\nshould wrap it with a call to the executor:Each thread should be wrapped before it runs application code, so if your\napplication manually delegates work to other threads, such as via Thread.new\nor Concurrent Ruby features that use thread pools, you should immediately wrap\nthe block:The Executor is safely re-entrant; if it is already active on the current\nthread, wrap is a no-op.If it's impractical to wrap the application code in a block (for\nexample, the Rack API makes this problematic), you can also use the run! /\ncomplete! pair:"},{"code":[],"body":"The Executor will put the current thread into running mode in the Load\nInterlock. This operation will block temporarily if another thread is currently\neither autoloading a constant or unloading/reloading the application.","title":"2.3 Concurrency","anchor":"#executor-concurrency"},{"title":"3 Reloader","anchor":"#reloader","code":["\nRails.application.reloader.wrap do\n  # call application code here\nend\n\nRails.application.reloader.wrap do\n  # call application code here\nend\n\nCopy\n"],"body":"Like the Executor, the Reloader also wraps application code. If the Executor is\nnot already active on the current thread, the Reloader will invoke it for you,\nso you only need to call one. This also guarantees that everything the Reloader\ndoes, including all its callback invocations, occurs wrapped inside the\nExecutor.The Reloader is only suitable where a long-running framework-level process\nrepeatedly calls into application code, such as for a web server or job queue.\nRails automatically wraps web requests and Active Job workers, so you'll rarely\nneed to invoke the Reloader for yourself. Always consider whether the Executor\nis a better fit for your use case."},{"title":"3.1 Callbacks","anchor":"#callbacks","code":[],"body":"Before entering the wrapped block, the Reloader will check whether the running\napplication needs to be reloaded -- for example, because a model's source file has\nbeen modified. If it determines a reload is required, it will wait until it's\nsafe, and then do so, before continuing. When the application is configured to\nalways reload regardless of whether any changes are detected, the reload is\ninstead performed at the end of the block.The Reloader also provides to_run and to_complete callbacks; they are\ninvoked at the same points as those of the Executor, but only when the current\nexecution has initiated an application reload. When no reload is deemed\nnecessary, the Reloader will invoke the wrapped block with no other callbacks."},{"title":"3.2 Class Unload","anchor":"#class-unload","code":[],"body":"The most significant part of the reloading process is the Class Unload, where\nall autoloaded classes are removed, ready to be loaded again. This will occur\nimmediately before either the Run or Complete callback, depending on the\nreload_classes_only_on_change setting.Often, additional reloading actions need to be performed either just before or\njust after the Class Unload, so the Reloader also provides before_class_unload\nand after_class_unload callbacks."},{"title":"3.3 Concurrency","anchor":"#reloader-concurrency","code":[],"body":"Only long-running \"top level\" processes should invoke the Reloader, because if\nit determines a reload is needed, it will block until all other threads have\ncompleted any Executor invocations.If this were to occur in a \"child\" thread, with a waiting parent inside the\nExecutor, it would cause an unavoidable deadlock: the reload must occur before\nthe child thread is executed, but it cannot be safely performed while the parent\nthread is mid-execution. Child threads should use the Executor instead."},{"title":"4 Framework Behavior","anchor":"#framework-behavior","code":[],"body":"The Rails framework components use these tools to manage their own concurrency\nneeds too.ActionDispatch::Executor and ActionDispatch::Reloader are Rack middlewares\nthat wrap requests with a supplied Executor or Reloader, respectively. They\nare automatically included in the default application stack. The Reloader will\nensure any arriving HTTP request is served with a freshly-loaded copy of the\napplication if any code changes have occurred.Active Job also wraps its job executions with the Reloader, loading the latest\ncode to execute each job as it comes off the queue.Action Cable uses the Executor instead: because a Cable connection is linked to\na specific instance of a class, it's not possible to reload for every arriving\nWebSocket message. Only the message handler is wrapped, though; a long-running\nCable connection does not prevent a reload that's triggered by a new incoming\nrequest or job. Instead, Action Cable uses the Reloader's before_class_unload\ncallback to disconnect all its connections. When the client automatically\nreconnects, it will be speaking to the new version of the code.The above are the entry points to the framework, so they are responsible for\nensuring their respective threads are protected, and deciding whether a reload\nis necessary. Other components only need to use the Executor when they spawn\nadditional threads."},{"title":"4.1 Configuration","anchor":"#configuration","code":[],"body":"The Reloader only checks for file changes when cache_classes is false and\nreload_classes_only_on_change is true (which is the default in the\ndevelopment environment).When cache_classes is true (in production, by default), the Reloader is only\na pass-through to the Executor.The Executor always has important work to do, like database connection\nmanagement. When cache_classes and eager_load are both true (production),\nno autoloading or class reloading will occur, so it does not need the Load\nInterlock. If either of those are false (development), then the Executor will\nuse the Load Interlock to ensure constants are only loaded when it is safe."},{"title":"5 Load Interlock","anchor":"#load-interlock","code":[],"body":"The Load Interlock allows autoloading and reloading to be enabled in a\nmulti-threaded runtime environment.When one thread is performing an autoload by evaluating the class definition\nfrom the appropriate file, it is important no other thread encounters a\nreference to the partially-defined constant.Similarly, it is only safe to perform an unload/reload when no application code\nis in mid-execution: after the reload, the User constant, for example, may\npoint to a different class. Without this rule, a poorly-timed reload would mean\nUser.new.class == User, or even User == User, could be false.Both of these constraints are addressed by the Load Interlock. It keeps track of\nwhich threads are currently running application code, loading a class, or\nunloading autoloaded constants.Only one thread may load or unload at a time, and to do either, it must wait\nuntil no other threads are running application code. If a thread is waiting to\nperform a load, it doesn't prevent other threads from loading (in fact, they'll\ncooperate, and each perform their queued load in turn, before all resuming\nrunning together)."},{"title":"5.1 permit_concurrent_loads","anchor":"#permit-concurrent-loads","code":["\nRails.application.executor.wrap do\n  th = Thread.new do\n    Rails.application.executor.wrap do\n      User # inner thread waits here; it cannot load\n           # User while another thread is running\n    end\n  end\n\n  th.join # outer thread waits here, holding 'running' lock\nend\n\nRails.application.executor.wrap do\n  th = Thread.new do\n    Rails.application.executor.wrap do\n      User # inner thread waits here; it cannot load\n           # User while another thread is running\n    end\n  end\n\n  th.join # outer thread waits here, holding 'running' lock\nend\n\nCopy\n","\nRails.application.executor.wrap do\n  th = Thread.new do\n    Rails.application.executor.wrap do\n      User # inner thread can acquire the 'load' lock,\n           # load User, and continue\n    end\n  end\n\n  ActiveSupport::Dependencies.interlock.permit_concurrent_loads do\n    th.join # outer thread waits here, but has no lock\n  end\nend\n\nRails.application.executor.wrap do\n  th = Thread.new do\n    Rails.application.executor.wrap do\n      User # inner thread can acquire the 'load' lock,\n           # load User, and continue\n    end\n  end\n\n  ActiveSupport::Dependencies.interlock.permit_concurrent_loads do\n    th.join # outer thread waits here, but has no lock\n  end\nend\n\nCopy\n","\nRails.application.executor.wrap do\n  futures = 3.times.collect do |i|\n    Concurrent::Future.execute do\n      Rails.application.executor.wrap do\n        # do work here\n      end\n    end\n  end\n\n  values = ActiveSupport::Dependencies.interlock.permit_concurrent_loads do\n    futures.collect(&:value)\n  end\nend\n\nRails.application.executor.wrap do\n  futures = 3.times.collect do |i|\n    Concurrent::Future.execute do\n      Rails.application.executor.wrap do\n        # do work here\n      end\n    end\n  end\n\n  values = ActiveSupport::Dependencies.interlock.permit_concurrent_loads do\n    futures.collect(&:value)\n  end\nend\n\nCopy\n"],"body":"The Executor automatically acquires a running lock for the duration of its\nblock, and autoload knows when to upgrade to a load lock, and switch back to\nrunning again afterwards.Other blocking operations performed inside the Executor block (which includes\nall application code), however, can needlessly retain the running lock. If\nanother thread encounters a constant it must autoload, this can cause a\ndeadlock.For example, assuming User is not yet loaded, the following will deadlock:To prevent this deadlock, the outer thread can permit_concurrent_loads. By\ncalling this method, the thread guarantees it will not dereference any\npossibly-autoloaded constant inside the supplied block. The safest way to meet\nthat promise is to put it as close as possible to the blocking call:Another example, using Concurrent Ruby:"},{"code":["\nconfig.middleware.insert_before Rack::Sendfile,\n                                  ActionDispatch::DebugLocks\n\nconfig.middleware.insert_before Rack::Sendfile,\n                                  ActionDispatch::DebugLocks\n\nCopy\n"],"body":"If your application is deadlocking and you think the Load Interlock may be\ninvolved, you can temporarily add the ActionDispatch::DebugLocks middleware to\nconfig/application.rb:If you then restart the application and re-trigger the deadlock condition,\n/rails/locks will show a summary of all threads currently known to the\ninterlock, which lock level they are holding or awaiting, and their current\nbacktrace.Generally a deadlock will be caused by the interlock conflicting with some other\nexternal lock or blocking I/O call. Once you find it, you can wrap it with\npermit_concurrent_loads.","title":"5.2 ActionDispatch::DebugLocks","anchor":"#actiondispatch-debuglocks"}]