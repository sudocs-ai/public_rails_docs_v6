[{"code":[],"body":"The Rails router recognizes URLs and dispatches them to a controller's action, or to a Rack application. It can also generate paths and URLs, avoiding the need to hardcode strings in your views.","title":"1 The Purpose of the Rails Router","anchor":"#the-purpose-of-the-rails-router"},{"title":"1.1 Connecting URLs to Code","anchor":"#connecting-urls-to-code","code":["\nGET /patients/17\n\nGET /patients/17\n\nCopy\n","\nget '/patients/:id', to: 'patients#show'\n\nget '/patients/:id', to: 'patients#show'\n\nCopy\n"],"body":"When your Rails application receives an incoming request for:it asks the router to match it to a controller action. If the first matching route is:the request is dispatched to the patients controller's show action with { id: '17' } in params."},{"title":"1.2 Generating Paths and URLs from Code","anchor":"#generating-paths-and-urls-from-code","code":["\nget '/patients/:id', to: 'patients#show', as: 'patient'\n\nget '/patients/:id', to: 'patients#show', as: 'patient'\n\nCopy\n","\n@patient = Patient.find(params[:id])\n\n@patient = Patient.find(params[:id])\n\nCopy\n","\n<%= link_to 'Patient Record', patient_path(@patient) %>\n\n<%= link_to 'Patient Record', patient_path(@patient) %>\n\nCopy\n"],"body":"You can also generate paths and URLs. If the route above is modified to be:and your application contains this code in the controller:and this in the corresponding view:then the router will generate the path /patients/17. This reduces the brittleness of your view and makes your code easier to understand. Note that the id does not need to be specified in the route helper."},{"title":"1.3 Configuring the Rails Router","anchor":"#configuring-the-rails-router","code":["\nRails.application.routes.draw do\n  resources :brands, only: [:index, :show] do\n    resources :products, only: [:index, :show]\n  end\n\n  resource :basket, only: [:show, :update, :destroy]\n\n  resolve(\"Basket\") { route_for(:basket) }\nend\n\nRails.application.routes.draw do\n  resources :brands, only: [:index, :show] do\n    resources :products, only: [:index, :show]\n  end\n\n  resource :basket, only: [:show, :update, :destroy]\n\n  resolve(\"Basket\") { route_for(:basket) }\nend\n\nCopy\n"],"body":"The routes for your application or engine live in the file config/routes.rb and typically looks like this:Since this is a regular Ruby source file you can use all of its features to help you define your routes but be careful with variable names as they can clash with the DSL methods of the router."},{"title":"2 Resource Routing: the Rails Default","anchor":"#resource-routing-the-rails-default","code":[],"body":"Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. A single call to resources can declare all of the necessary routes for your index, show, new, edit, create, update, and destroy actions."},{"title":"2.1 Resources on the Web","anchor":"#resources-on-the-web","code":["\nDELETE /photos/17\n\nDELETE /photos/17\n\nCopy\n","\nresources :photos\n\nresources :photos\n\nCopy\n"],"body":"Browsers request pages from Rails by making a request for a URL using a specific HTTP method, such as GET, POST, PATCH, PUT and DELETE. Each method is a request to perform an operation on the resource. A resource route maps a number of related requests to actions in a single controller.When your Rails application receives an incoming request for:it asks the router to map it to a controller action. If the first matching route is:Rails would dispatch that request to the destroy action on the photos controller with { id: '17' } in params."},{"title":"2.2 CRUD, Verbs, and Actions","anchor":"#crud-verbs-and-actions","code":["\nresources :photos\n\nresources :photos\n\nCopy\n"],"body":"In Rails, a resourceful route provides a mapping between HTTP verbs and URLs to\ncontroller actions. By convention, each action also maps to a specific CRUD\noperation in a database. A single entry in the routing file, such as:creates seven different routes in your application, all mapping to the Photos controller:"},{"title":"2.3 Path and URL Helpers","anchor":"#path-and-url-helpers","code":[],"body":"Creating a resourceful route will also expose a number of helpers to the controllers in your application. In the case of resources :photos:Each of these helpers has a corresponding _url helper (such as photos_url) which returns the same path prefixed with the current host, port, and path prefix."},{"title":"2.4 Defining Multiple Resources at the Same Time","anchor":"#defining-multiple-resources-at-the-same-time","code":["\nresources :photos, :books, :videos\n\nresources :photos, :books, :videos\n\nCopy\n","\nresources :photos\nresources :books\nresources :videos\n\nresources :photos\nresources :books\nresources :videos\n\nCopy\n"],"body":"If you need to create routes for more than one resource, you can save a bit of typing by defining them all with a single call to resources:This works exactly the same as:"},{"code":["\nget 'profile', to: 'users#show'\n\nget 'profile', to: 'users#show'\n\nCopy\n","\nget 'profile', action: :show, controller: 'users'\n\nget 'profile', action: :show, controller: 'users'\n\nCopy\n","\nresource :geocoder\nresolve('Geocoder') { [:geocoder] }\n\nresource :geocoder\nresolve('Geocoder') { [:geocoder] }\n\nCopy\n"],"body":"Sometimes, you have a resource that clients always look up without referencing an ID. For example, you would like /profile to always show the profile of the currently logged in user. In this case, you can use a singular resource to map /profile (rather than /profile/:id) to the show action:Passing a String to to: will expect a controller#action format. When using a Symbol, the to: option should be replaced with action:. When using a String without a #, the to: option should be replaced with controller::This resourceful route:creates six different routes in your application, all mapping to the Geocoders controller:A singular resourceful route generates these helpers:As with plural resources, the same helpers ending in _url will also include the host, port, and path prefix.","title":"2.5 Singular Resources","anchor":"#singular-resources"},{"title":"2.6 Controller Namespaces and Routing","anchor":"#controller-namespaces-and-routing","code":["\nnamespace :admin do\n  resources :articles, :comments\nend\n\nnamespace :admin do\n  resources :articles, :comments\nend\n\nCopy\n","\nscope module: 'admin' do\n  resources :articles, :comments\nend\n\nscope module: 'admin' do\n  resources :articles, :comments\nend\n\nCopy\n","\nresources :articles, module: 'admin'\n\nresources :articles, module: 'admin'\n\nCopy\n","\nscope '/admin' do\n  resources :articles, :comments\nend\n\nscope '/admin' do\n  resources :articles, :comments\nend\n\nCopy\n","\nresources :articles, path: '/admin/articles'\n\nresources :articles, path: '/admin/articles'\n\nCopy\n"],"body":"You may wish to organize groups of controllers under a namespace. Most commonly, you might group a number of administrative controllers under an Admin:: namespace, and place these controllers under the app/controllers/admin directory. You can route to such a group by using a namespace block:This will create a number of routes for each of the articles and comments controller. For Admin::ArticlesController, Rails will create:If instead you want to route /articles (without the prefix /admin) to Admin::ArticlesController, you can specify the module with a scope block:This can also be done for a single route:If instead you want to route /admin/articles to ArticlesController (without the Admin:: module prefix), you can specify the path with a scope block:This can also be done for a single route:In both of these cases, the named route helpers remain the same as if you did not use scope. In the last case, the following paths map to ArticlesController:"},{"title":"2.7 Nested Resources","anchor":"#nested-resources","code":["\nclass Magazine < ApplicationRecord\n  has_many :ads\nend\n\nclass Ad < ApplicationRecord\n  belongs_to :magazine\nend\n\nclass Magazine < ApplicationRecord\n  has_many :ads\nend\n\nclass Ad < ApplicationRecord\n  belongs_to :magazine\nend\n\nCopy\n","\nresources :magazines do\n  resources :ads\nend\n\nresources :magazines do\n  resources :ads\nend\n\nCopy\n"],"body":"It's common to have resources that are logically children of other resources. For example, suppose your application includes these models:Nested routes allow you to capture this relationship in your routing. In this case, you could include this route declaration:In addition to the routes for magazines, this declaration will also route ads to an AdsController. The ad URLs require a magazine:This will also create routing helpers such as magazine_ads_url and edit_magazine_ad_path. These helpers take an instance of Magazine as the first parameter (magazine_ads_url(@magazine))."},{"title":"2.7.1 Limits to Nesting","anchor":"#limits-to-nesting","code":["\nresources :publishers do\n  resources :magazines do\n    resources :photos\n  end\nend\n\nresources :publishers do\n  resources :magazines do\n    resources :photos\n  end\nend\n\nCopy\n","\n/publishers/1/magazines/2/photos/3\n\n/publishers/1/magazines/2/photos/3\n\nCopy\n"],"body":"You can nest resources within other nested resources if you like. For example:Deeply-nested resources quickly become cumbersome. In this case, for example, the application would recognize paths such as:The corresponding route helper would be publisher_magazine_photo_url, requiring you to specify objects at all three levels. Indeed, this situation is confusing enough that a popular article by Jamis Buck proposes a rule of thumb for good Rails design:"},{"title":"2.7.2 Shallow Nesting","anchor":"#shallow-nesting","code":["\nresources :articles do\n  resources :comments, only: [:index, :new, :create]\nend\nresources :comments, only: [:show, :edit, :update, :destroy]\n\nresources :articles do\n  resources :comments, only: [:index, :new, :create]\nend\nresources :comments, only: [:show, :edit, :update, :destroy]\n\nCopy\n","\nresources :articles do\n  resources :comments, shallow: true\nend\n\nresources :articles do\n  resources :comments, shallow: true\nend\n\nCopy\n","\nresources :articles, shallow: true do\n  resources :comments\n  resources :quotes\n  resources :drafts\nend\n\nresources :articles, shallow: true do\n  resources :comments\n  resources :quotes\n  resources :drafts\nend\n\nCopy\n","\nshallow do\n  resources :articles do\n    resources :comments\n    resources :quotes\n    resources :drafts\n  end\nend\n\nshallow do\n  resources :articles do\n    resources :comments\n    resources :quotes\n    resources :drafts\n  end\nend\n\nCopy\n","\nscope shallow_path: \"sekret\" do\n  resources :articles do\n    resources :comments, shallow: true\n  end\nend\n\nscope shallow_path: \"sekret\" do\n  resources :articles do\n    resources :comments, shallow: true\n  end\nend\n\nCopy\n","\nscope shallow_prefix: \"sekret\" do\n  resources :articles do\n    resources :comments, shallow: true\n  end\nend\n\nscope shallow_prefix: \"sekret\" do\n  resources :articles do\n    resources :comments, shallow: true\n  end\nend\n\nCopy\n"],"body":"One way to avoid deep nesting (as recommended above) is to generate the collection actions scoped under the parent, so as to get a sense of the hierarchy, but to not nest the member actions. In other words, to only build routes with the minimal amount of information to uniquely identify the resource, like this:This idea strikes a balance between descriptive routes and deep nesting. There exists shorthand syntax to achieve just that, via the :shallow option:This will generate the exact same routes as the first example. You can also specify the :shallow option in the parent resource, in which case all of the nested resources will be shallow:The shallow method of the DSL creates a scope inside of which every nesting is shallow. This generates the same routes as the previous example:There exist two options for scope to customize shallow routes. :shallow_path prefixes member paths with the specified parameter:The comments resource here will have the following routes generated for it:The :shallow_prefix option adds the specified parameter to the named route helpers:The comments resource here will have the following routes generated for it:"},{"code":["\nconcern :commentable do\n  resources :comments\nend\n\nconcern :image_attachable do\n  resources :images, only: :index\nend\n\nconcern :commentable do\n  resources :comments\nend\n\nconcern :image_attachable do\n  resources :images, only: :index\nend\n\nCopy\n","\nresources :messages, concerns: :commentable\n\nresources :articles, concerns: [:commentable, :image_attachable]\n\nresources :messages, concerns: :commentable\n\nresources :articles, concerns: [:commentable, :image_attachable]\n\nCopy\n","\nresources :messages do\n  resources :comments\nend\n\nresources :articles do\n  resources :comments\n  resources :images, only: :index\nend\n\nresources :messages do\n  resources :comments\nend\n\nresources :articles do\n  resources :comments\n  resources :images, only: :index\nend\n\nCopy\n","\nnamespace :articles do\n  concerns :commentable\nend\n\nnamespace :articles do\n  concerns :commentable\nend\n\nCopy\n"],"body":"Routing concerns allow you to declare common routes that can be reused inside other resources and routes. To define a concern, use a concern block:These concerns can be used in resources to avoid code duplication and share behavior across routes:The above is equivalent to:You can also use them anywhere by calling concerns. For example, in a scope or namespace block:","title":"2.8 Routing Concerns","anchor":"#routing-concerns"},{"code":["\nresources :magazines do\n  resources :ads\nend\n\nresources :magazines do\n  resources :ads\nend\n\nCopy\n","\n<%= link_to 'Ad details', magazine_ad_path(@magazine, @ad) %>\n\n<%= link_to 'Ad details', magazine_ad_path(@magazine, @ad) %>\n\nCopy\n","\n<%= link_to 'Ad details', url_for([@magazine, @ad]) %>\n\n<%= link_to 'Ad details', url_for([@magazine, @ad]) %>\n\nCopy\n","\n<%= link_to 'Ad details', [@magazine, @ad] %>\n\n<%= link_to 'Ad details', [@magazine, @ad] %>\n\nCopy\n","\n<%= link_to 'Magazine details', @magazine %>\n\n<%= link_to 'Magazine details', @magazine %>\n\nCopy\n","\n<%= link_to 'Edit Ad', [:edit, @magazine, @ad] %>\n\n<%= link_to 'Edit Ad', [:edit, @magazine, @ad] %>\n\nCopy\n"],"body":"In addition to using the routing helpers, Rails can also create paths and URLs from an array of parameters. For example, suppose you have this set of routes:When using magazine_ad_path, you can pass in instances of Magazine and Ad instead of the numeric IDs:You can also use url_for with a set of objects, and Rails will automatically determine which route you want:In this case, Rails will see that @magazine is a Magazine and @ad is an Ad and will therefore use the magazine_ad_path helper. In helpers like link_to, you can specify just the object in place of the full url_for call:If you wanted to link to just a magazine:For other actions, you just need to insert the action name as the first element of the array:This allows you to treat instances of your models as URLs, and is a key advantage to using the resourceful style.","title":"2.9 Creating Paths and URLs from Objects","anchor":"#creating-paths-and-urls-from-objects"},{"title":"2.10 Adding More RESTful Actions","anchor":"#adding-more-restful-actions","code":[],"body":"You are not limited to the seven routes that RESTful routing creates by default. If you like, you may add additional routes that apply to the collection or individual members of the collection."},{"title":"2.10.1 Adding Member Routes","anchor":"#adding-member-routes","code":["\nresources :photos do\n  member do\n    get 'preview'\n  end\nend\n\nresources :photos do\n  member do\n    get 'preview'\n  end\nend\n\nCopy\n","\nresources :photos do\n  get 'preview', on: :member\nend\n\nresources :photos do\n  get 'preview', on: :member\nend\n\nCopy\n"],"body":"To add a member route, just add a member block into the resource block:This will recognize /photos/1/preview with GET, and route to the preview action of PhotosController, with the resource id value passed in params[:id]. It will also create the preview_photo_url and preview_photo_path helpers.Within the block of member routes, each route name specifies the HTTP verb that\nwill be recognized. You can use get, patch, put, post, or delete here\n. If you don't have multiple member routes, you can also pass :on to a\nroute, eliminating the block:You can leave out the :on option, this will create the same member route except that the resource id value will be available in params[:photo_id] instead of params[:id]. Route helpers will also be renamed from preview_photo_url and preview_photo_path to photo_preview_url and photo_preview_path."},{"title":"2.10.2 Adding Collection Routes","anchor":"#adding-collection-routes","code":["\nresources :photos do\n  collection do\n    get 'search'\n  end\nend\n\nresources :photos do\n  collection do\n    get 'search'\n  end\nend\n\nCopy\n","\nresources :photos do\n  get 'search', on: :collection\nend\n\nresources :photos do\n  get 'search', on: :collection\nend\n\nCopy\n"],"body":"To add a route to the collection, use a collection block:This will enable Rails to recognize paths such as /photos/search with GET, and route to the search action of PhotosController. It will also create the search_photos_url and search_photos_path route helpers.Just as with member routes, you can pass :on to a route:"},{"title":"2.10.3 Adding Routes for Additional New Actions","anchor":"#adding-routes-for-additional-new-actions","code":["\nresources :comments do\n  get 'preview', on: :new\nend\n\nresources :comments do\n  get 'preview', on: :new\nend\n\nCopy\n"],"body":"To add an alternate new action using the :on shortcut:This will enable Rails to recognize paths such as /comments/new/preview with GET, and route to the preview action of CommentsController. It will also create the preview_new_comment_url and preview_new_comment_path route helpers."},{"title":"3 Non-Resourceful Routes","anchor":"#non-resourceful-routes","code":[],"body":"In addition to resource routing, Rails has powerful support for routing arbitrary URLs to actions. Here, you don't get groups of routes automatically generated by resourceful routing. Instead, you set up each route separately within your application.While you should usually use resourceful routing, there are still many places where the simpler routing is more appropriate. There's no need to try to shoehorn every last piece of your application into a resourceful framework if that's not a good fit.In particular, simple routing makes it very easy to map legacy URLs to new Rails actions."},{"title":"3.1 Bound Parameters","anchor":"#bound-parameters","code":["\nget 'photos(/:id)', to: 'photos#display'\n\nget 'photos(/:id)', to: 'photos#display'\n\nCopy\n"],"body":"When you set up a regular route, you supply a series of symbols that Rails maps to parts of an incoming HTTP request. For example, consider this route:If an incoming request of /photos/1 is processed by this route (because it hasn't matched any previous route in the file), then the result will be to invoke the display action of the PhotosController, and to make the final parameter \"1\" available as params[:id]. This route will also route the incoming request of /photos to PhotosController#display, since :id is an optional parameter, denoted by parentheses."},{"title":"3.2 Dynamic Segments","anchor":"#dynamic-segments","code":["\nget 'photos/:id/:user_id', to: 'photos#show'\n\nget 'photos/:id/:user_id', to: 'photos#show'\n\nCopy\n"],"body":"You can set up as many dynamic segments within a regular route as you like. Any segment will be available to the action as part of params. If you set up this route:An incoming path of /photos/1/2 will be dispatched to the show action of the PhotosController. params[:id] will be \"1\", and params[:user_id] will be \"2\"."},{"title":"3.3 Static Segments","anchor":"#static-segments","code":["\nget 'photos/:id/with_user/:user_id', to: 'photos#show'\n\nget 'photos/:id/with_user/:user_id', to: 'photos#show'\n\nCopy\n"],"body":"You can specify static segments when creating a route by not prepending a colon to a segment:This route would respond to paths such as /photos/1/with_user/2. In this case, params would be { controller: 'photos', action: 'show', id: '1', user_id: '2' }."},{"title":"3.4 The Query String","anchor":"#the-query-string","code":["\nget 'photos/:id', to: 'photos#show'\n\nget 'photos/:id', to: 'photos#show'\n\nCopy\n"],"body":"The params will also include any parameters from the query string. For example, with this route:An incoming path of /photos/1?user_id=2 will be dispatched to the show action of the Photos controller. params will be { controller: 'photos', action: 'show', id: '1', user_id: '2' }."},{"title":"3.5 Defining Defaults","anchor":"#defining-defaults","code":["\nget 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }\n\nget 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }\n\nCopy\n","\ndefaults format: :json do\n  resources :photos\nend\n\ndefaults format: :json do\n  resources :photos\nend\n\nCopy\n"],"body":"You can define defaults in a route by supplying a hash for the :defaults option. This even applies to parameters that you do not specify as dynamic segments. For example:Rails would match photos/12 to the show action of PhotosController, and set params[:format] to \"jpg\".You can also use a defaults block to define the defaults for multiple items:"},{"title":"3.6 Naming Routes","anchor":"#naming-routes","code":["\nget 'exit', to: 'sessions#destroy', as: :logout\n\nget 'exit', to: 'sessions#destroy', as: :logout\n\nCopy\n","\nget ':username', to: 'users#show', as: :user\nresources :users\n\nget ':username', to: 'users#show', as: :user\nresources :users\n\nCopy\n"],"body":"You can specify a name for any route using the :as option:This will create logout_path and logout_url as named route helpers in your application. Calling logout_path will return /exitYou can also use this to override routing methods defined by resources by placing custom routes before the resource is defined, like this:This will define a user_path method that will be available in controllers, helpers, and views that will go to a route such as /bob. Inside the show action of UsersController, params[:username] will contain the username for the user. Change :username in the route definition if you do not want your parameter name to be :username."},{"title":"3.7 HTTP Verb Constraints","anchor":"#http-verb-constraints","code":["\nmatch 'photos', to: 'photos#show', via: [:get, :post]\n\nmatch 'photos', to: 'photos#show', via: [:get, :post]\n\nCopy\n","\nmatch 'photos', to: 'photos#show', via: :all\n\nmatch 'photos', to: 'photos#show', via: :all\n\nCopy\n"],"body":"In general, you should use the get, post, put, patch, and delete methods to constrain a route to a particular verb. You can use the match method with the :via option to match multiple verbs at once:You can match all verbs to a particular route using via: :all:"},{"title":"3.8 Segment Constraints","anchor":"#segment-constraints","code":["\nget 'photos/:id', to: 'photos#show', constraints: { id: /[A-Z]\\d{5}/ }\n\nget 'photos/:id', to: 'photos#show', constraints: { id: /[A-Z]\\d{5}/ }\n\nCopy\n","\nget 'photos/:id', to: 'photos#show', id: /[A-Z]\\d{5}/\n\nget 'photos/:id', to: 'photos#show', id: /[A-Z]\\d{5}/\n\nCopy\n","\nget '/:id', to: 'articles#show', constraints: { id: /^\\d/ }\n\nget '/:id', to: 'articles#show', constraints: { id: /^\\d/ }\n\nCopy\n","\nget '/:id', to: 'articles#show', constraints: { id: /\\d.+/ }\nget '/:username', to: 'users#show'\n\nget '/:id', to: 'articles#show', constraints: { id: /\\d.+/ }\nget '/:username', to: 'users#show'\n\nCopy\n"],"body":"You can use the :constraints option to enforce a format for a dynamic segment:This route would match paths such as /photos/A12345, but not /photos/893. You can more succinctly express the same route this way::constraints takes regular expressions with the restriction that regexp anchors can't be used. For example, the following route will not work:However, note that you don't need to use anchors because all routes are anchored at the start and the end.For example, the following routes would allow for articles with to_param values like 1-hello-world that always begin with a number and users with to_param values like david that never begin with a number to share the root namespace:"},{"code":["\nget 'photos', to: 'photos#index', constraints: { subdomain: 'admin' }\n\nget 'photos', to: 'photos#index', constraints: { subdomain: 'admin' }\n\nCopy\n","\nnamespace :admin do\n  constraints subdomain: 'admin' do\n    resources :photos\n  end\nend\n\nnamespace :admin do\n  constraints subdomain: 'admin' do\n    resources :photos\n  end\nend\n\nCopy\n"],"body":"You can also constrain a route based on any method on the Request object that returns a String.You specify a request-based constraint the same way that you specify a segment constraint:You can also specify constraints by using a constraints block:","title":"3.9 Request-Based Constraints","anchor":"#request-based-constraints"},{"title":"3.10 Advanced Constraints","anchor":"#advanced-constraints","code":["\nclass RestrictedListConstraint\n  def initialize\n    @ips = RestrictedList.retrieve_ips\n  end\n\n  def matches?(request)\n    @ips.include?(request.remote_ip)\n  end\nend\n\nRails.application.routes.draw do\n  get '*path', to: 'restricted_list#index',\n    constraints: RestrictedListConstraint.new\nend\n\nclass RestrictedListConstraint\n  def initialize\n    @ips = RestrictedList.retrieve_ips\n  end\n\n  def matches?(request)\n    @ips.include?(request.remote_ip)\n  end\nend\n\nRails.application.routes.draw do\n  get '*path', to: 'restricted_list#index',\n    constraints: RestrictedListConstraint.new\nend\n\nCopy\n","\nRails.application.routes.draw do\n  get '*path', to: 'restricted_list#index',\n    constraints: lambda { |request| RestrictedList.retrieve_ips.include?(request.remote_ip) }\nend\n\nRails.application.routes.draw do\n  get '*path', to: 'restricted_list#index',\n    constraints: lambda { |request| RestrictedList.retrieve_ips.include?(request.remote_ip) }\nend\n\nCopy\n"],"body":"If you have a more advanced constraint, you can provide an object that responds to matches? that Rails should use. Let's say you wanted to route all users on a restricted list to the RestrictedListController. You could do:You can also specify constraints as a lambda:Both the matches? method and the lambda gets the request object as an argument."},{"title":"3.10.1 Constraints in a block form","anchor":"#constraints-in-a-block-form","code":["\nclass RestrictedListConstraint\n  # ...Same as the example above\nend\n\nRails.application.routes.draw do\n  constraints(RestrictedListConstraint.new) do\n    get '*path', to: 'restricted_list#index'\n    get '*other-path', to: 'other_restricted_list#index'\n  end\nend\n\nclass RestrictedListConstraint\n  # ...Same as the example above\nend\n\nRails.application.routes.draw do\n  constraints(RestrictedListConstraint.new) do\n    get '*path', to: 'restricted_list#index'\n    get '*other-path', to: 'other_restricted_list#index'\n  end\nend\n\nCopy\n","\nRails.application.routes.draw do\n  constraints(lambda { |request| RestrictedList.retrieve_ips.include?(request.remote_ip) }) do\n    get '*path', to: 'restricted_list#index'\n    get '*other-path', to: 'other_restricted_list#index'\n  end\nend\n\nRails.application.routes.draw do\n  constraints(lambda { |request| RestrictedList.retrieve_ips.include?(request.remote_ip) }) do\n    get '*path', to: 'restricted_list#index'\n    get '*other-path', to: 'other_restricted_list#index'\n  end\nend\n\nCopy\n"],"body":"You can specify constraints in a block form. This is useful for when you need to apply the same rule to several routes. For example:You can also use a lambda:"},{"code":["\nget 'photos/*other', to: 'photos#unknown'\n\nget 'photos/*other', to: 'photos#unknown'\n\nCopy\n","\nget 'books/*section/:title', to: 'books#show'\n\nget 'books/*section/:title', to: 'books#show'\n\nCopy\n","\nget '*a/foo/*b', to: 'test#index'\n\nget '*a/foo/*b', to: 'test#index'\n\nCopy\n","\nget '*pages', to: 'pages#show', format: false\n\nget '*pages', to: 'pages#show', format: false\n\nCopy\n","\nget '*pages', to: 'pages#show', format: true\n\nget '*pages', to: 'pages#show', format: true\n\nCopy\n"],"body":"Route globbing is a way to specify that a particular parameter should be matched to all the remaining parts of a route. For example:This route would match photos/12 or /photos/long/path/to/12, setting params[:other] to \"12\" or \"long/path/to/12\". The segments prefixed with a star are called \"wildcard segments\".Wildcard segments can occur anywhere in a route. For example:would match books/some/section/last-words-a-memoir with params[:section] equals 'some/section', and params[:title] equals 'last-words-a-memoir'.Technically, a route can have even more than one wildcard segment. The matcher assigns segments to parameters in an intuitive way. For example:would match zoo/woo/foo/bar/baz with params[:a] equals 'zoo/woo', and params[:b] equals 'bar/baz'.","title":"3.11 Route Globbing and Wildcard Segments","anchor":"#route-globbing-and-wildcard-segments"},{"code":["\nget '/stories', to: redirect('/articles')\n\nget '/stories', to: redirect('/articles')\n\nCopy\n","\nget '/stories/:name', to: redirect('/articles/%{name}')\n\nget '/stories/:name', to: redirect('/articles/%{name}')\n\nCopy\n","\nget '/stories/:name', to: redirect { |path_params, req| \"/articles/#{path_params[:name].pluralize}\" }\nget '/stories', to: redirect { |path_params, req| \"/articles/#{req.subdomain}\" }\n\nget '/stories/:name', to: redirect { |path_params, req| \"/articles/#{path_params[:name].pluralize}\" }\nget '/stories', to: redirect { |path_params, req| \"/articles/#{req.subdomain}\" }\n\nCopy\n","\nget '/stories/:name', to: redirect('/articles/%{name}', status: 302)\n\nget '/stories/:name', to: redirect('/articles/%{name}', status: 302)\n\nCopy\n"],"body":"You can redirect any path to another path by using the redirect helper in your router:You can also reuse dynamic segments from the match in the path to redirect to:You can also provide a block to redirect, which receives the symbolized path parameters and the request object:Please note that default redirection is a 301 \"Moved Permanently\" redirect. Keep in mind that some web browsers or proxy servers will cache this type of redirect, making the old page inaccessible. You can use the :status option to change the response status:In all of these cases, if you don't provide the leading host (http://www.example.com), Rails will take those details from the current request.","title":"3.12 Redirection","anchor":"#redirection"},{"title":"3.13 Routing to Rack Applications","anchor":"#routing-to-rack-applications","code":["\nmatch '/application.js', to: MyRackApp, via: :all\n\nmatch '/application.js', to: MyRackApp, via: :all\n\nCopy\n","\nmatch '/admin', to: AdminApp, via: :all\n\nmatch '/admin', to: AdminApp, via: :all\n\nCopy\n","\nmount AdminApp, at: '/admin'\n\nmount AdminApp, at: '/admin'\n\nCopy\n"],"body":"Instead of a String like 'articles#index', which corresponds to the index action in the ArticlesController, you can specify any Rack application as the endpoint for a matcher:As long as MyRackApp responds to call and returns a [status, headers, body], the router won't know the difference between the Rack application and an action. This is an appropriate use of via: :all, as you will want to allow your Rack application to handle all verbs as it considers appropriate.If you specify a Rack application as the endpoint for a matcher, remember that\nthe route will be unchanged in the receiving application. With the following\nroute your Rack application should expect the route to be /admin:If you would prefer to have your Rack application receive requests at the root\npath instead, use mount:"},{"code":["\nroot to: 'pages#main'\nroot 'pages#main' # shortcut for the above\n\nroot to: 'pages#main'\nroot 'pages#main' # shortcut for the above\n\nCopy\n","\nnamespace :admin do\n  root to: \"admin#index\"\nend\n\nroot to: \"home#index\"\n\nnamespace :admin do\n  root to: \"admin#index\"\nend\n\nroot to: \"home#index\"\n\nCopy\n"],"body":"You can specify what Rails should route '/' to with the root method:You should put the root route at the top of the file, because it is the most popular route and should be matched first.You can also use root inside namespaces and scopes as well. For example:","title":"3.14 Using root","anchor":"#using-root"},{"code":["\nget 'こんにちは', to: 'welcome#index'\n\nget 'こんにちは', to: 'welcome#index'\n\nCopy\n"],"body":"You can specify unicode character routes directly. For example:","title":"3.15 Unicode Character Routes","anchor":"#unicode-character-routes"},{"code":["\ndirect :homepage do\n  \"http://www.rubyonrails.org\"\nend\n\n# >> homepage_url\n# => \"http://www.rubyonrails.org\"\n\ndirect :homepage do\n  \"http://www.rubyonrails.org\"\nend\n\n# >> homepage_url\n# => \"http://www.rubyonrails.org\"\n\nCopy\n","\ndirect :commentable do |model|\n  [ model, anchor: model.dom_id ]\nend\n\ndirect :main do\n  { controller: 'pages', action: 'index', subdomain: 'www' }\nend\n\ndirect :commentable do |model|\n  [ model, anchor: model.dom_id ]\nend\n\ndirect :main do\n  { controller: 'pages', action: 'index', subdomain: 'www' }\nend\n\nCopy\n"],"body":"You can create custom URL helpers directly by calling direct. For example:The return value of the block must be a valid argument for the url_for method. So, you can pass a valid string URL, Hash, Array, an Active Model instance, or an Active Model class.","title":"3.16 Direct Routes","anchor":"#direct-routes"},{"code":["\nresource :basket\n\nresolve(\"Basket\") { [:basket] }\n\nresource :basket\n\nresolve(\"Basket\") { [:basket] }\n\nCopy\n","\n<%= form_with model: @basket do |form| %>\n  <!-- basket form -->\n<% end %>\n\n<%= form_with model: @basket do |form| %>\n  <!-- basket form -->\n<% end %>\n\nCopy\n"],"body":"The resolve method allows customizing polymorphic mapping of models. For example:This will generate the singular URL /basket instead of the usual /baskets/:id.","title":"3.17 Using resolve","anchor":"#using-resolve"},{"title":"4 Customizing Resourceful Routes","anchor":"#customizing-resourceful-routes","code":[],"body":"While the default routes and helpers generated by resources will usually serve you well, you may want to customize them in some way. Rails allows you to customize virtually any generic part of the resourceful helpers."},{"title":"4.1 Specifying a Controller to Use","anchor":"#specifying-a-controller-to-use","code":["\nresources :photos, controller: 'images'\n\nresources :photos, controller: 'images'\n\nCopy\n","\nresources :user_permissions, controller: 'admin/user_permissions'\n\nresources :user_permissions, controller: 'admin/user_permissions'\n\nCopy\n"],"body":"The :controller option lets you explicitly specify a controller to use for the resource. For example:will recognize incoming paths beginning with /photos but route to the Images controller:For namespaced controllers you can use the directory notation. For example:This will route to the Admin::UserPermissions controller."},{"title":"4.2 Specifying Constraints","anchor":"#specifying-constraints","code":["\nresources :photos, constraints: { id: /[A-Z][A-Z][0-9]+/ }\n\nresources :photos, constraints: { id: /[A-Z][A-Z][0-9]+/ }\n\nCopy\n","\nconstraints(id: /[A-Z][A-Z][0-9]+/) do\n  resources :photos\n  resources :accounts\nend\n\nconstraints(id: /[A-Z][A-Z][0-9]+/) do\n  resources :photos\n  resources :accounts\nend\n\nCopy\n"],"body":"You can use the :constraints option to specify a required format on the implicit id. For example:This declaration constrains the :id parameter to match the supplied regular expression. So, in this case, the router would no longer match /photos/1 to this route. Instead, /photos/RR27 would match.You can specify a single constraint to apply to a number of routes by using the block form:"},{"title":"4.3 Overriding the Named Route Helpers","anchor":"#overriding-the-named-route-helpers","code":["\nresources :photos, as: 'images'\n\nresources :photos, as: 'images'\n\nCopy\n"],"body":"The :as option lets you override the normal naming for the named route helpers. For example:will recognize incoming paths beginning with /photos and route the requests to PhotosController, but use the value of the :as option to name the helpers."},{"code":["\nresources :photos, path_names: { new: 'make', edit: 'change' }\n\nresources :photos, path_names: { new: 'make', edit: 'change' }\n\nCopy\n","\n/photos/make\n/photos/1/change\n\n/photos/make\n/photos/1/change\n\nCopy\n","\nscope path_names: { new: 'make' } do\n  # rest of your routes\nend\n\nscope path_names: { new: 'make' } do\n  # rest of your routes\nend\n\nCopy\n"],"body":"The :path_names option lets you override the automatically-generated new and edit segments in paths:This would cause the routing to recognize paths such as:","title":"4.4 Overriding the new and edit Segments","anchor":"#overriding-the-new-and-edit-segments"},{"code":["\nscope 'admin' do\n  resources :photos, as: 'admin_photos'\nend\n\nresources :photos\n\nscope 'admin' do\n  resources :photos, as: 'admin_photos'\nend\n\nresources :photos\n\nCopy\n","\nscope 'admin', as: 'admin' do\n  resources :photos, :accounts\nend\n\nresources :photos, :accounts\n\nscope 'admin', as: 'admin' do\n  resources :photos, :accounts\nend\n\nresources :photos, :accounts\n\nCopy\n","\nscope ':username' do\n  resources :articles\nend\n\nscope ':username' do\n  resources :articles\nend\n\nCopy\n"],"body":"You can use the :as option to prefix the named route helpers that Rails generates for a route. Use this option to prevent name collisions between routes using a path scope. For example:This will provide route helpers such as admin_photos_path, new_admin_photo_path, etc.To prefix a group of route helpers, use :as with scope:This will generate routes such as admin_photos_path and admin_accounts_path which map to /admin/photos and /admin/accounts respectively.You can prefix routes with a named parameter also:This will provide you with URLs such as /bob/articles/1 and will allow you to reference the username part of the path as params[:username] in controllers, helpers, and views.","title":"4.5 Prefixing the Named Route Helpers","anchor":"#prefixing-the-named-route-helpers"},{"title":"4.6 Restricting the Routes Created","anchor":"#restricting-the-routes-created","code":["\nresources :photos, only: [:index, :show]\n\nresources :photos, only: [:index, :show]\n\nCopy\n","\nresources :photos, except: :destroy\n\nresources :photos, except: :destroy\n\nCopy\n"],"body":"By default, Rails creates routes for the seven default actions (index, show, new, create, edit, update, and destroy) for every RESTful route in your application. You can use the :only and :except options to fine-tune this behavior. The :only option tells Rails to create only the specified routes:Now, a GET request to /photos would succeed, but a POST request to /photos (which would ordinarily be routed to the create action) will fail.The :except option specifies a route or list of routes that Rails should not create:In this case, Rails will create all of the normal routes except the route for destroy (a DELETE request to /photos/:id)."},{"title":"4.7 Translated Paths","anchor":"#translated-paths","code":["\nscope(path_names: { new: 'neu', edit: 'bearbeiten' }) do\n  resources :categories, path: 'kategorien'\nend\n\nscope(path_names: { new: 'neu', edit: 'bearbeiten' }) do\n  resources :categories, path: 'kategorien'\nend\n\nCopy\n"],"body":"Using scope, we can alter path names generated by resources:Rails now creates routes to the CategoriesController."},{"code":["\nActiveSupport::Inflector.inflections do |inflect|\n  inflect.irregular 'tooth', 'teeth'\nend\n\nActiveSupport::Inflector.inflections do |inflect|\n  inflect.irregular 'tooth', 'teeth'\nend\n\nCopy\n"],"body":"If you want to override the singular form of a resource, you should add additional rules to the inflector via inflections:","title":"4.8 Overriding the Singular Form","anchor":"#overriding-the-singular-form"},{"code":["\nresources :magazines do\n  resources :ads, as: 'periodical_ads'\nend\n\nresources :magazines do\n  resources :ads, as: 'periodical_ads'\nend\n\nCopy\n"],"body":"The :as option overrides the automatically-generated name for the resource in nested route helpers. For example:This will create routing helpers such as magazine_periodical_ads_url and edit_magazine_periodical_ad_path.","title":"4.9 Using :as in Nested Resources","anchor":"#using-as-in-nested-resources"},{"title":"4.10 Overriding Named Route Parameters","anchor":"#overriding-named-route-parameters","code":["\nresources :videos, param: :identifier\n\nresources :videos, param: :identifier\n\nCopy\n","\n    videos GET  /videos(.:format)                  videos#index\n           POST /videos(.:format)                  videos#create\n new_video GET  /videos/new(.:format)              videos#new\nedit_video GET  /videos/:identifier/edit(.:format) videos#edit\n\n    videos GET  /videos(.:format)                  videos#index\n           POST /videos(.:format)                  videos#create\n new_video GET  /videos/new(.:format)              videos#new\nedit_video GET  /videos/:identifier/edit(.:format) videos#edit\n\nCopy\n","\nVideo.find_by(identifier: params[:identifier])\n\nVideo.find_by(identifier: params[:identifier])\n\nCopy\n","\nclass Video < ApplicationRecord\n  def to_param\n    identifier\n  end\nend\n\nclass Video < ApplicationRecord\n  def to_param\n    identifier\n  end\nend\n\nCopy\n","\nvideo = Video.find_by(identifier: \"Roman-Holiday\")\nedit_video_path(video) # => \"/videos/Roman-Holiday/edit\"\n\nvideo = Video.find_by(identifier: \"Roman-Holiday\")\nedit_video_path(video) # => \"/videos/Roman-Holiday/edit\"\n\nCopy\n"],"body":"The :param option overrides the default resource identifier :id (name of\nthe dynamic segment used to generate the\nroutes). You can access that segment from your controller using\nparams[<:param>].You can override ActiveRecord::Base#to_param of the associated model to construct\na URL:"},{"code":["\n# config/routes.rb\n\nRails.application.routes.draw do\n  get 'foo', to: 'foo#bar'\n\n  draw(:admin) # Will load another route file located in `config/routes/admin.rb`\nend\n\n# config/routes.rb\n\nRails.application.routes.draw do\n  get 'foo', to: 'foo#bar'\n\n  draw(:admin) # Will load another route file located in `config/routes/admin.rb`\nend\n\nCopy\n","\n# config/routes/admin.rb\n\nnamespace :admin do\n  resources :comments\nend\n\n# config/routes/admin.rb\n\nnamespace :admin do\n  resources :comments\nend\n\nCopy\n"],"body":"If you work in a large application with thousands of routes,\na single config/routes.rb file can become cumbersome and hard to read.Rails offers a way to break a gigantic single routes.rb file into multiple small ones using the draw macro.Calling draw(:admin) inside the Rails.application.routes.draw block itself will try to load a route\nfile that has the same name as the argument given (admin.rb in this case).\nThe file needs to be located inside the config/routes directory or any sub-directory (i.e. config/routes/admin.rb or config/routes/external/admin.rb).You can use the normal routing DSL inside the admin.rb routing file, however you shouldn't surround it with the Rails.application.routes.draw block like you did in the main config/routes.rb file.","title":"5 Breaking up very large route file into multiple small ones:","anchor":"#breaking-up-very-large-route-file-into-multiple-small-ones"},{"title":"5.1 When to use and not use this feature","anchor":"#when-to-use-and-not-use-this-feature","code":[],"body":"Drawing routes from external files can be very useful to organise a large set of routes into multiple organised ones. You could have a admin.rb route that contains all the routes for the admin area, another api.rb file to route API related resources, etc...However, you shouldn't abuse this feature as having too many route files make discoverability and understandability more difficult. Depending on the application, it might be easier for developers to have a single routing file even if you have few hundreds routes. You shouldn't try to create a new routing file for each category (e.g. admin, api, ...) at all cost; the Rails routing DSL already offers a way to break routes in a organised manner with namespaces and scopes."},{"title":"6 Inspecting and Testing Routes","anchor":"#inspecting-and-testing-routes","code":[],"body":"Rails offers facilities for inspecting and testing your routes."},{"title":"6.1 Listing Existing Routes","anchor":"#listing-existing-routes","code":["\n    users GET    /users(.:format)          users#index\n          POST   /users(.:format)          users#create\n new_user GET    /users/new(.:format)      users#new\nedit_user GET    /users/:id/edit(.:format) users#edit\n\n    users GET    /users(.:format)          users#index\n          POST   /users(.:format)          users#create\n new_user GET    /users/new(.:format)      users#new\nedit_user GET    /users/:id/edit(.:format) users#edit\n\nCopy\n","\n$ bin/rails routes --expanded\n\n--[ Route 1 ]----------------------------------------------------\nPrefix            | users\nVerb              | GET\nURI               | /users(.:format)\nController#Action | users#index\n--[ Route 2 ]----------------------------------------------------\nPrefix            |\nVerb              | POST\nURI               | /users(.:format)\nController#Action | users#create\n--[ Route 3 ]----------------------------------------------------\nPrefix            | new_user\nVerb              | GET\nURI               | /users/new(.:format)\nController#Action | users#new\n--[ Route 4 ]----------------------------------------------------\nPrefix            | edit_user\nVerb              | GET\nURI               | /users/:id/edit(.:format)\nController#Action | users#edit\n\nbin/rails routes --expanded\n\nCopy\n","\n$ bin/rails routes -g new_comment\n$ bin/rails routes -g POST\n$ bin/rails routes -g admin\n\nbin/rails routes -g new_comment\nbin/rails routes -g POST\nbin/rails routes -g admin\n\nCopy\n","\n$ bin/rails routes -c users\n$ bin/rails routes -c admin/users\n$ bin/rails routes -c Comments\n$ bin/rails routes -c Articles::CommentsController\n\nbin/rails routes -c users\nbin/rails routes -c admin/users\nbin/rails routes -c Comments\nbin/rails routes -c Articles::CommentsController\n\nCopy\n"],"body":"To get a complete list of the available routes in your application, visit http://localhost:3000/rails/info/routes in your browser while your server is running in the development environment. You can also execute the bin/rails routes command in your terminal to produce the same output.Both methods will list all of your routes, in the same order that they appear in config/routes.rb. For each route, you'll see:For example, here's a small section of the bin/rails routes output for a RESTful route:You can also use the --expanded option to turn on the expanded table formatting mode.You can search through your routes with the grep option: -g. This outputs any routes that partially match the URL helper method name, the HTTP verb, or the URL path.If you only want to see the routes that map to a specific controller, there's the -c option."},{"title":"6.2 Testing Routes","anchor":"#testing-routes","code":[],"body":"Routes should be included in your testing strategy (just like the rest of your application). Rails offers three built-in assertions designed to make testing routes simpler:"},{"code":["\nassert_generates '/photos/1', { controller: 'photos', action: 'show', id: '1' }\nassert_generates '/about', controller: 'pages', action: 'about'\n\nassert_generates '/photos/1', { controller: 'photos', action: 'show', id: '1' }\nassert_generates '/about', controller: 'pages', action: 'about'\n\nCopy\n"],"body":"assert_generates asserts that a particular set of options generate a particular path and can be used with default routes or custom routes. For example:","title":"6.2.1 The assert_generates Assertion","anchor":"#the-assert-generates-assertion"},{"code":["\nassert_recognizes({ controller: 'photos', action: 'show', id: '1' }, '/photos/1')\n\nassert_recognizes({ controller: 'photos', action: 'show', id: '1' }, '/photos/1')\n\nCopy\n","\nassert_recognizes({ controller: 'photos', action: 'create' }, { path: 'photos', method: :post })\n\nassert_recognizes({ controller: 'photos', action: 'create' }, { path: 'photos', method: :post })\n\nCopy\n"],"body":"assert_recognizes is the inverse of assert_generates. It asserts that a given path is recognized and routes it to a particular spot in your application. For example:You can supply a :method argument to specify the HTTP verb:","title":"6.2.2 The assert_recognizes Assertion","anchor":"#the-assert-recognizes-assertion"},{"code":["\nassert_routing({ path: 'photos', method: :post }, { controller: 'photos', action: 'create' })\n\nassert_routing({ path: 'photos', method: :post }, { controller: 'photos', action: 'create' })\n\nCopy\n"],"body":"The assert_routing assertion checks the route both ways: it tests that the path generates the options, and that the options generate the path. Thus, it combines the functions of assert_generates and assert_recognizes:","title":"6.2.3 The assert_routing Assertion","anchor":"#the-assert-routing-assertion"}]