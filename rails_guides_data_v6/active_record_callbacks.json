[{"code":[],"body":"During the normal operation of a Rails application, objects may be created, updated, and destroyed. Active Record provides hooks into this object life cycle so that you can control your application and its data.Callbacks allow you to trigger logic before or after an alteration of an object's state.","title":"1 The Object Life Cycle","anchor":"#the-object-life-cycle"},{"title":"2 Callbacks Overview","anchor":"#callbacks-overview","code":[],"body":"Callbacks are methods that get called at certain moments of an object's life cycle. With callbacks it is possible to write code that will run whenever an Active Record object is created, saved, updated, deleted, validated, or loaded from the database."},{"title":"2.1 Callback Registration","anchor":"#callback-registration","code":["\nclass User < ApplicationRecord\n  validates :login, :email, presence: true\n\n  before_validation :ensure_login_has_a_value\n\n  private\n    def ensure_login_has_a_value\n      if login.nil?\n        self.login = email unless email.blank?\n      end\n    end\nend\n\nclass User < ApplicationRecord\n  validates :login, :email, presence: true\n\n  before_validation :ensure_login_has_a_value\n\n  private\n    def ensure_login_has_a_value\n      if login.nil?\n        self.login = email unless email.blank?\n      end\n    end\nend\n\nCopy\n","\nclass User < ApplicationRecord\n  validates :login, :email, presence: true\n\n  before_create do\n    self.name = login.capitalize if name.blank?\n  end\nend\n\nclass User < ApplicationRecord\n  validates :login, :email, presence: true\n\n  before_create do\n    self.name = login.capitalize if name.blank?\n  end\nend\n\nCopy\n","\nclass User < ApplicationRecord\n  before_validation :normalize_name, on: :create\n\n  # :on takes an array as well\n  after_validation :set_location, on: [ :create, :update ]\n\n  private\n    def normalize_name\n      self.name = name.downcase.titleize\n    end\n\n    def set_location\n      self.location = LocationService.query(self)\n    end\nend\n\nclass User < ApplicationRecord\n  before_validation :normalize_name, on: :create\n\n  # :on takes an array as well\n  after_validation :set_location, on: [ :create, :update ]\n\n  private\n    def normalize_name\n      self.name = name.downcase.titleize\n    end\n\n    def set_location\n      self.location = LocationService.query(self)\n    end\nend\n\nCopy\n"],"body":"In order to use the available callbacks, you need to register them. You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks:The macro-style class methods can also receive a block. Consider using this style if the code inside your block is so short that it fits in a single line:Callbacks can also be registered to only fire on certain life cycle events:It is considered good practice to declare callback methods as private. If left public, they can be called from outside of the model and violate the principle of object encapsulation."},{"title":"3 Available Callbacks","anchor":"#available-callbacks","code":[],"body":"Here is a list with all the available Active Record callbacks, listed in the same order in which they will get called during the respective operations:"},{"title":"3.1 Creating an Object","anchor":"#creating-an-object","code":[],"body":""},{"code":[],"body":"","title":"3.2 Updating an Object","anchor":"#updating-an-object"},{"code":[],"body":"","title":"3.3 Destroying an Object","anchor":"#destroying-an-object"},{"title":"3.4 after_initialize and after_find","anchor":"#after-initialize-and-after-find","code":["\nclass User < ApplicationRecord\n  after_initialize do |user|\n    puts \"You have initialized an object!\"\n  end\n\n  after_find do |user|\n    puts \"You have found an object!\"\n  end\nend\n\nclass User < ApplicationRecord\n  after_initialize do |user|\n    puts \"You have initialized an object!\"\n  end\n\n  after_find do |user|\n    puts \"You have found an object!\"\n  end\nend\n\nCopy\n","\nirb> User.new\nYou have initialized an object!\n=> #<User id: nil>\n\nirb> User.first\nYou have found an object!\nYou have initialized an object!\n=> #<User id: 1>\n\nUser.new\nUser.first\n\nCopy\n"],"body":"The after_initialize callback will be called whenever an Active Record object is instantiated, either by directly using new or when a record is loaded from the database. It can be useful to avoid the need to directly override your Active Record initialize method.The after_find callback will be called whenever Active Record loads a record from the database. after_find is called before after_initialize if both are defined.The after_initialize and after_find callbacks have no before_* counterparts, but they can be registered just like the other Active Record callbacks."},{"code":["\nclass User < ApplicationRecord\n  after_touch do |user|\n    puts \"You have touched an object\"\n  end\nend\n\nclass User < ApplicationRecord\n  after_touch do |user|\n    puts \"You have touched an object\"\n  end\nend\n\nCopy\n","\nirb> u = User.create(name: 'Kuldeep')\n=> #<User id: 1, name: \"Kuldeep\", created_at: \"2013-11-25 12:17:49\", updated_at: \"2013-11-25 12:17:49\">\n\nirb> u.touch\nYou have touched an object\n=> true\n\nu = User.create(name: 'Kuldeep')\nu.touch\n\nCopy\n","\nclass Employee < ApplicationRecord\n  belongs_to :company, touch: true\n  after_touch do\n    puts 'An Employee was touched'\n  end\nend\n\nclass Company < ApplicationRecord\n  has_many :employees\n  after_touch :log_when_employees_or_company_touched\n\n  private\n    def log_when_employees_or_company_touched\n      puts 'Employee/Company was touched'\n    end\nend\n\nclass Employee < ApplicationRecord\n  belongs_to :company, touch: true\n  after_touch do\n    puts 'An Employee was touched'\n  end\nend\n\nclass Company < ApplicationRecord\n  has_many :employees\n  after_touch :log_when_employees_or_company_touched\n\n  private\n    def log_when_employees_or_company_touched\n      puts 'Employee/Company was touched'\n    end\nend\n\nCopy\n","\nirb> @employee = Employee.last\n=> #<Employee id: 1, company_id: 1, created_at: \"2013-11-25 17:04:22\", updated_at: \"2013-11-25 17:05:05\">\n\nirb> @employee.touch # triggers @employee.company.touch\nAn Employee was touched\nEmployee/Company was touched\n=> true\n\n@employee = Employee.last\n@employee.touch # triggers @employee.company.touch\n\nCopy\n"],"body":"The after_touch callback will be called whenever an Active Record object is touched.It can be used along with belongs_to:","title":"3.5 after_touch","anchor":"#after-touch"},{"code":[],"body":"The following methods trigger callbacks:Additionally, the after_find callback is triggered by the following finder methods:The after_initialize callback is triggered every time a new object of the class is initialized.","title":"4 Running Callbacks","anchor":"#running-callbacks"},{"title":"5 Skipping Callbacks","anchor":"#skipping-callbacks","code":[],"body":"Just as with validations, it is also possible to skip callbacks by using the following methods:These methods should be used with caution, however, because important business rules and application logic may be kept in callbacks. Bypassing them without understanding the potential implications may lead to invalid data."},{"title":"6 Halting Execution","anchor":"#halting-execution","code":["\nthrow :abort\n\nthrow :abort\n\nCopy\n"],"body":"As you start registering new callbacks for your models, they will be queued for execution. This queue will include all your model's validations, the registered callbacks, and the database operation to be executed.The whole callback chain is wrapped in a transaction. If any callback raises an exception, the execution chain gets halted and a ROLLBACK is issued. To intentionally stop a chain use:"},{"title":"7 Relational Callbacks","anchor":"#relational-callbacks","code":["\nclass User < ApplicationRecord\n  has_many :articles, dependent: :destroy\nend\n\nclass Article < ApplicationRecord\n  after_destroy :log_destroy_action\n\n  def log_destroy_action\n    puts 'Article destroyed'\n  end\nend\n\nclass User < ApplicationRecord\n  has_many :articles, dependent: :destroy\nend\n\nclass Article < ApplicationRecord\n  after_destroy :log_destroy_action\n\n  def log_destroy_action\n    puts 'Article destroyed'\n  end\nend\n\nCopy\n","\nirb> user = User.first\n=> #<User id: 1>\nirb> user.articles.create!\n=> #<Article id: 1, user_id: 1>\nirb> user.destroy\nArticle destroyed\n=> #<User id: 1>\n\nuser = User.first\nuser.articles.create!\nuser.destroy\n\nCopy\n"],"body":"Callbacks work through model relationships, and can even be defined by them. Suppose an example where a user has many articles. A user's articles should be destroyed if the user is destroyed. Let's add an after_destroy callback to the User model by way of its relationship to the Article model:"},{"code":[],"body":"As with validations, we can also make the calling of a callback method conditional on the satisfaction of a given predicate. We can do this using the :if and :unless options, which can take a symbol, a Proc or an Array. You may use the :if option when you want to specify under which conditions the callback should be called. If you want to specify the conditions under which the callback should not be called, then you may use the :unless option.","title":"8 Conditional Callbacks","anchor":"#conditional-callbacks"},{"title":"8.1 Using :if and :unless with a Symbol","anchor":"#using-if-and-unless-with-a-symbol","code":["\nclass Order < ApplicationRecord\n  before_save :normalize_card_number, if: :paid_with_card?\nend\n\nclass Order < ApplicationRecord\n  before_save :normalize_card_number, if: :paid_with_card?\nend\n\nCopy\n"],"body":"You can associate the :if and :unless options with a symbol corresponding to the name of a predicate method that will get called right before the callback. When using the :if option, the callback won't be executed if the predicate method returns false; when using the :unless option, the callback won't be executed if the predicate method returns true. This is the most common option. Using this form of registration it is also possible to register several different predicates that should be called to check if the callback should be executed."},{"code":["\nclass Order < ApplicationRecord\n  before_save :normalize_card_number,\n    if: Proc.new { |order| order.paid_with_card? }\nend\n\nclass Order < ApplicationRecord\n  before_save :normalize_card_number,\n    if: Proc.new { |order| order.paid_with_card? }\nend\n\nCopy\n","\nclass Order < ApplicationRecord\n  before_save :normalize_card_number, if: Proc.new { paid_with_card? }\nend\n\nclass Order < ApplicationRecord\n  before_save :normalize_card_number, if: Proc.new { paid_with_card? }\nend\n\nCopy\n"],"body":"It is possible to associate :if and :unless with a Proc object. This option is best suited when writing short validation methods, usually one-liners:As the proc is evaluated in the context of the object, it is also possible to write this as:","title":"8.2 Using :if and :unless with a Proc","anchor":"#using-if-and-unless-with-a-proc"},{"code":["\nclass Comment < ApplicationRecord\n  after_create :send_email_to_author, if: :author_wants_emails?,\n    unless: Proc.new { |comment| comment.article.ignore_comments? }\nend\n\nclass Comment < ApplicationRecord\n  after_create :send_email_to_author, if: :author_wants_emails?,\n    unless: Proc.new { |comment| comment.article.ignore_comments? }\nend\n\nCopy\n"],"body":"When writing conditional callbacks, it is possible to mix both :if and :unless in the same callback declaration:","title":"8.3 Multiple Conditions for Callbacks","anchor":"#multiple-conditions-for-callbacks"},{"code":["\nclass Comment < ApplicationRecord\n  after_create :send_email_to_author,\n    if: [Proc.new { |c| c.user.allow_send_email? }, :author_wants_emails?],\n    unless: Proc.new { |c| c.article.ignore_comments? }\nend\n\nclass Comment < ApplicationRecord\n  after_create :send_email_to_author,\n    if: [Proc.new { |c| c.user.allow_send_email? }, :author_wants_emails?],\n    unless: Proc.new { |c| c.article.ignore_comments? }\nend\n\nCopy\n"],"body":"When multiple conditions define whether or not a callback should happen, an Array can be used. Moreover, you can apply both :if and :unless to the same callback.The callback only runs when all the :if conditions and none of the :unless conditions are evaluated to true.","title":"8.4 Combining Callback Conditions","anchor":"#combining-callback-conditions"},{"title":"9 Callback Classes","anchor":"#callback-classes","code":["\nclass PictureFileCallbacks\n  def after_destroy(picture_file)\n    if File.exist?(picture_file.filepath)\n      File.delete(picture_file.filepath)\n    end\n  end\nend\n\nclass PictureFileCallbacks\n  def after_destroy(picture_file)\n    if File.exist?(picture_file.filepath)\n      File.delete(picture_file.filepath)\n    end\n  end\nend\n\nCopy\n","\nclass PictureFile < ApplicationRecord\n  after_destroy PictureFileCallbacks.new\nend\n\nclass PictureFile < ApplicationRecord\n  after_destroy PictureFileCallbacks.new\nend\n\nCopy\n","\nclass PictureFileCallbacks\n  def self.after_destroy(picture_file)\n    if File.exist?(picture_file.filepath)\n      File.delete(picture_file.filepath)\n    end\n  end\nend\n\nclass PictureFileCallbacks\n  def self.after_destroy(picture_file)\n    if File.exist?(picture_file.filepath)\n      File.delete(picture_file.filepath)\n    end\n  end\nend\n\nCopy\n","\nclass PictureFile < ApplicationRecord\n  after_destroy PictureFileCallbacks\nend\n\nclass PictureFile < ApplicationRecord\n  after_destroy PictureFileCallbacks\nend\n\nCopy\n"],"body":"Sometimes the callback methods that you'll write will be useful enough to be reused by other models. Active Record makes it possible to create classes that encapsulate the callback methods, so they can be reused.Here's an example where we create a class with an after_destroy callback for a PictureFile model:When declared inside a class, as above, the callback methods will receive the model object as a parameter. We can now use the callback class in the model:Note that we needed to instantiate a new PictureFileCallbacks object, since we declared our callback as an instance method. This is particularly useful if the callbacks make use of the state of the instantiated object. Often, however, it will make more sense to declare the callbacks as class methods:If the callback method is declared this way, it won't be necessary to instantiate a PictureFileCallbacks object.You can declare as many callbacks as you want inside your callback classes."},{"title":"10 Transaction Callbacks","anchor":"#transaction-callbacks","code":["\nPictureFile.transaction do\n  picture_file_1.destroy\n  picture_file_2.save!\nend\n\nPictureFile.transaction do\n  picture_file_1.destroy\n  picture_file_2.save!\nend\n\nCopy\n","\nclass PictureFile < ApplicationRecord\n  after_commit :delete_picture_file_from_disk, on: :destroy\n\n  def delete_picture_file_from_disk\n    if File.exist?(filepath)\n      File.delete(filepath)\n    end\n  end\nend\n\nclass PictureFile < ApplicationRecord\n  after_commit :delete_picture_file_from_disk, on: :destroy\n\n  def delete_picture_file_from_disk\n    if File.exist?(filepath)\n      File.delete(filepath)\n    end\n  end\nend\n\nCopy\n","\nclass PictureFile < ApplicationRecord\n  after_destroy_commit :delete_picture_file_from_disk\n\n  def delete_picture_file_from_disk\n    if File.exist?(filepath)\n      File.delete(filepath)\n    end\n  end\nend\n\nclass PictureFile < ApplicationRecord\n  after_destroy_commit :delete_picture_file_from_disk\n\n  def delete_picture_file_from_disk\n    if File.exist?(filepath)\n      File.delete(filepath)\n    end\n  end\nend\n\nCopy\n","\nclass User < ApplicationRecord\n  after_create_commit :log_user_saved_to_db\n  after_update_commit :log_user_saved_to_db\n\n  private\n  def log_user_saved_to_db\n    puts 'User was saved to database'\n  end\nend\n\nclass User < ApplicationRecord\n  after_create_commit :log_user_saved_to_db\n  after_update_commit :log_user_saved_to_db\n\n  private\n  def log_user_saved_to_db\n    puts 'User was saved to database'\n  end\nend\n\nCopy\n","\nirb> @user = User.create # prints nothing\n\nirb> @user.save # updating @user\nUser was saved to database\n\n@user = User.create # prints nothing\n@user.save # updating @user\n\nCopy\n","\nclass User < ApplicationRecord\n  after_save_commit :log_user_saved_to_db\n\n  private\n  def log_user_saved_to_db\n    puts 'User was saved to database'\n  end\nend\n\nclass User < ApplicationRecord\n  after_save_commit :log_user_saved_to_db\n\n  private\n  def log_user_saved_to_db\n    puts 'User was saved to database'\n  end\nend\n\nCopy\n","\nirb> @user = User.create # creating a User\nUser was saved to database\n\nirb> @user.save # updating @user\nUser was saved to database\n\n@user = User.create # creating a User\n@user.save # updating @user\n\nCopy\n"],"body":"There are two additional callbacks that are triggered by the completion of a database transaction: after_commit and after_rollback. These callbacks are very similar to the after_save callback except that they don't execute until after database changes have either been committed or rolled back. They are most useful when your active record models need to interact with external systems which are not part of the database transaction.Consider, for example, the previous example where the PictureFile model needs to delete a file after the corresponding record is destroyed. If anything raises an exception after the after_destroy callback is called and the transaction rolls back, the file will have been deleted and the model will be left in an inconsistent state. For example, suppose that picture_file_2 in the code below is not valid and the save! method raises an error.By using the after_commit callback we can account for this case.Since using the after_commit callback only on create, update, or delete is\ncommon, there are aliases for those operations:There is also an alias for using the after_commit callback for both create and update together:"}]