[{"code":[],"body":"In order to use the PostgreSQL adapter you need to have at least version 9.3\ninstalled. Older versions are not supported.To get started with PostgreSQL have a look at the\nconfiguring Rails guide.\nIt describes how to properly set up Active Record for PostgreSQL.PostgreSQL offers a number of specific datatypes. Following is a list of types,\nthat are supported by the PostgreSQL adapter.","title":"1 Datatypes","anchor":"#datatypes"},{"title":"1.1 Bytea","anchor":"#bytea","code":["\n# db/migrate/20140207133952_create_documents.rb\ncreate_table :documents do |t|\n  t.binary 'payload'\nend\n\n# db/migrate/20140207133952_create_documents.rb\ncreate_table :documents do |t|\n  t.binary 'payload'\nend\n\nCopy\n","\n# app/models/document.rb\nclass Document < ApplicationRecord\nend\n\n# app/models/document.rb\nclass Document < ApplicationRecord\nend\n\nCopy\n","\n# Usage\ndata = File.read(Rails.root + \"tmp/output.pdf\")\nDocument.create payload: data\n\n# Usage\ndata = File.read(Rails.root + \"tmp/output.pdf\")\nDocument.create payload: data\n\nCopy\n"],"body":""},{"code":["\n# db/migrate/20140207133952_create_books.rb\ncreate_table :books do |t|\n  t.string 'title'\n  t.string 'tags', array: true\n  t.integer 'ratings', array: true\nend\nadd_index :books, :tags, using: 'gin'\nadd_index :books, :ratings, using: 'gin'\n\n# db/migrate/20140207133952_create_books.rb\ncreate_table :books do |t|\n  t.string 'title'\n  t.string 'tags', array: true\n  t.integer 'ratings', array: true\nend\nadd_index :books, :tags, using: 'gin'\nadd_index :books, :ratings, using: 'gin'\n\nCopy\n","\n# app/models/book.rb\nclass Book < ApplicationRecord\nend\n\n# app/models/book.rb\nclass Book < ApplicationRecord\nend\n\nCopy\n","\n# Usage\nBook.create title: \"Brave New World\",\n            tags: [\"fantasy\", \"fiction\"],\n            ratings: [4, 5]\n\n## Books for a single tag\nBook.where(\"'fantasy' = ANY (tags)\")\n\n## Books for multiple tags\nBook.where(\"tags @> ARRAY[?]::varchar[]\", [\"fantasy\", \"fiction\"])\n\n## Books with 3 or more ratings\nBook.where(\"array_length(ratings, 1) >= 3\")\n\n# Usage\nBook.create title: \"Brave New World\",\n            tags: [\"fantasy\", \"fiction\"],\n            ratings: [4, 5]\n\n## Books for a single tag\nBook.where(\"'fantasy' = ANY (tags)\")\n\n## Books for multiple tags\nBook.where(\"tags @> ARRAY[?]::varchar[]\", [\"fantasy\", \"fiction\"])\n\n## Books with 3 or more ratings\nBook.where(\"array_length(ratings, 1) >= 3\")\n\nCopy\n"],"body":"","title":"1.2 Array","anchor":"#array"},{"code":["\n# db/migrate/20131009135255_create_profiles.rb\nActiveRecord::Schema.define do\n  enable_extension 'hstore' unless extension_enabled?('hstore')\n  create_table :profiles do |t|\n    t.hstore 'settings'\n  end\nend\n\n# db/migrate/20131009135255_create_profiles.rb\nActiveRecord::Schema.define do\n  enable_extension 'hstore' unless extension_enabled?('hstore')\n  create_table :profiles do |t|\n    t.hstore 'settings'\n  end\nend\n\nCopy\n","\n# app/models/profile.rb\nclass Profile < ApplicationRecord\nend\n\n# app/models/profile.rb\nclass Profile < ApplicationRecord\nend\n\nCopy\n","\nirb> Profile.create(settings: { \"color\" => \"blue\", \"resolution\" => \"800x600\" })\n\nirb> profile = Profile.first\nirb> profile.settings\n=> {\"color\"=>\"blue\", \"resolution\"=>\"800x600\"}\n\nirb> profile.settings = {\"color\" => \"yellow\", \"resolution\" => \"1280x1024\"}\nirb> profile.save!\n\nirb> Profile.where(\"settings->'color' = ?\", \"yellow\")\n=> #<ActiveRecord::Relation [#<Profile id: 1, settings: {\"color\"=>\"yellow\", \"resolution\"=>\"1280x1024\"}>]>\n\nProfile.create(settings: { \"color\" => \"blue\", \"resolution\" => \"800x600\" })\nprofile = Profile.first\nprofile.settings\nprofile.settings = {\"color\" => \"yellow\", \"resolution\" => \"1280x1024\"}\nprofile.save!\nProfile.where(\"settings->'color' = ?\", \"yellow\")\n\nCopy\n"],"body":"","title":"1.3 Hstore","anchor":"#hstore"},{"code":["\n# db/migrate/20131220144913_create_events.rb\n# ... for json datatype:\ncreate_table :events do |t|\n  t.json 'payload'\nend\n# ... or for jsonb datatype:\ncreate_table :events do |t|\n  t.jsonb 'payload'\nend\n\n# db/migrate/20131220144913_create_events.rb\n# ... for json datatype:\ncreate_table :events do |t|\n  t.json 'payload'\nend\n# ... or for jsonb datatype:\ncreate_table :events do |t|\n  t.jsonb 'payload'\nend\n\nCopy\n","\n# app/models/event.rb\nclass Event < ApplicationRecord\nend\n\n# app/models/event.rb\nclass Event < ApplicationRecord\nend\n\nCopy\n","\nirb> Event.create(payload: { kind: \"user_renamed\", change: [\"jack\", \"john\"]})\n\nirb> event = Event.first\nirb> event.payload\n=> {\"kind\"=>\"user_renamed\", \"change\"=>[\"jack\", \"john\"]}\n\n## Query based on JSON document\n# The -> operator returns the original JSON type (which might be an object), whereas ->> returns text\nirb> Event.where(\"payload->>'kind' = ?\", \"user_renamed\")\n\nEvent.create(payload: { kind: \"user_renamed\", change: [\"jack\", \"john\"]})\nevent = Event.first\nevent.payload\nEvent.where(\"payload->>'kind' = ?\", \"user_renamed\")\n\nCopy\n"],"body":"","title":"1.4 JSON and JSONB","anchor":"#json-and-jsonb"},{"code":["\n# db/migrate/20130923065404_create_events.rb\ncreate_table :events do |t|\n  t.daterange 'duration'\nend\n\n# db/migrate/20130923065404_create_events.rb\ncreate_table :events do |t|\n  t.daterange 'duration'\nend\n\nCopy\n","\n# app/models/event.rb\nclass Event < ApplicationRecord\nend\n\n# app/models/event.rb\nclass Event < ApplicationRecord\nend\n\nCopy\n","\nirb> Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))\n\nirb> event = Event.first\nirb> event.duration\n=> Tue, 11 Feb 2014...Thu, 13 Feb 2014\n\n## All Events on a given date\nirb> Event.where(\"duration @> ?::date\", Date.new(2014, 2, 12))\n\n## Working with range bounds\nirb> event = Event.select(\"lower(duration) AS starts_at\").select(\"upper(duration) AS ends_at\").first\n\nirb> event.starts_at\n=> Tue, 11 Feb 2014\nirb> event.ends_at\n=> Thu, 13 Feb 2014\n\nEvent.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))\nevent = Event.first\nevent.duration\nEvent.where(\"duration @> ?::date\", Date.new(2014, 2, 12))\nevent = Event.select(\"lower(duration) AS starts_at\").select(\"upper(duration) AS ends_at\").first\nevent.starts_at\nevent.ends_at\n\nCopy\n"],"body":"This type is mapped to Ruby Range objects.","title":"1.5 Range Types","anchor":"#range-types"},{"code":["\nCREATE TYPE full_address AS\n(\n  city VARCHAR(90),\n  street VARCHAR(90)\n);\n\nCREATE TYPE full_address AS\n(\n  city VARCHAR(90),\n  street VARCHAR(90)\n);\n\nCopy\n","\n# db/migrate/20140207133952_create_contacts.rb\nexecute <<-SQL\n  CREATE TYPE full_address AS\n  (\n    city VARCHAR(90),\n    street VARCHAR(90)\n  );\nSQL\ncreate_table :contacts do |t|\n  t.column :address, :full_address\nend\n\n# db/migrate/20140207133952_create_contacts.rb\nexecute <<-SQL\n  CREATE TYPE full_address AS\n  (\n    city VARCHAR(90),\n    street VARCHAR(90)\n  );\nSQL\ncreate_table :contacts do |t|\n  t.column :address, :full_address\nend\n\nCopy\n","\n# app/models/contact.rb\nclass Contact < ApplicationRecord\nend\n\n# app/models/contact.rb\nclass Contact < ApplicationRecord\nend\n\nCopy\n","\nirb> Contact.create address: \"(Paris,Champs-Élysées)\"\nirb> contact = Contact.first\nirb> contact.address\n=> \"(Paris,Champs-Élysées)\"\nirb> contact.address = \"(Paris,Rue Basse)\"\nirb> contact.save!\n\nContact.create address: \"(Paris,Champs-Élysées)\"\ncontact = Contact.first\ncontact.address\ncontact.address = \"(Paris,Rue Basse)\"\ncontact.save!\n\nCopy\n"],"body":"Currently there is no special support for composite types. They are mapped to\nnormal text columns:","title":"1.6 Composite Types","anchor":"#composite-types"},{"code":["\n# db/migrate/20131220144913_create_articles.rb\ndef up\n  execute <<-SQL\n    CREATE TYPE article_status AS ENUM ('draft', 'published');\n  SQL\n  create_table :articles do |t|\n    t.column :status, :article_status\n  end\nend\n\n# NOTE: It's important to drop table before dropping enum.\ndef down\n  drop_table :articles\n\n  execute <<-SQL\n    DROP TYPE article_status;\n  SQL\nend\n\n# db/migrate/20131220144913_create_articles.rb\ndef up\n  execute <<-SQL\n    CREATE TYPE article_status AS ENUM ('draft', 'published');\n  SQL\n  create_table :articles do |t|\n    t.column :status, :article_status\n  end\nend\n\n# NOTE: It's important to drop table before dropping enum.\ndef down\n  drop_table :articles\n\n  execute <<-SQL\n    DROP TYPE article_status;\n  SQL\nend\n\nCopy\n","\n# app/models/article.rb\nclass Article < ApplicationRecord\nend\n\n# app/models/article.rb\nclass Article < ApplicationRecord\nend\n\nCopy\n","\nirb> Article.create status: \"draft\"\nirb> article = Article.first\nirb> article.status\n=> \"draft\"\n\nirb> article.status = \"published\"\nirb> article.save!\n\nArticle.create status: \"draft\"\narticle = Article.first\narticle.status\narticle.status = \"published\"\narticle.save!\n\nCopy\n","\n# db/migrate/20150720144913_add_new_state_to_articles.rb\n# NOTE: ALTER TYPE ... ADD VALUE cannot be executed inside of a transaction block so here we are using disable_ddl_transaction!\ndisable_ddl_transaction!\n\ndef up\n  execute <<-SQL\n    ALTER TYPE article_status ADD VALUE IF NOT EXISTS 'archived' AFTER 'published';\n  SQL\nend\n\n# db/migrate/20150720144913_add_new_state_to_articles.rb\n# NOTE: ALTER TYPE ... ADD VALUE cannot be executed inside of a transaction block so here we are using disable_ddl_transaction!\ndisable_ddl_transaction!\n\ndef up\n  execute <<-SQL\n    ALTER TYPE article_status ADD VALUE IF NOT EXISTS 'archived' AFTER 'published';\n  SQL\nend\n\nCopy\n","\nSELECT n.nspname AS enum_schema,\n       t.typname AS enum_name,\n       e.enumlabel AS enum_value\n  FROM pg_type t\n      JOIN pg_enum e ON t.oid = e.enumtypid\n      JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n\nSELECT n.nspname AS enum_schema,\n       t.typname AS enum_name,\n       e.enumlabel AS enum_value\n  FROM pg_type t\n      JOIN pg_enum e ON t.oid = e.enumtypid\n      JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n\nCopy\n"],"body":"Currently there is no special support for enumerated types. They are mapped as\nnormal text columns:To add a new value before/after existing one you should use ALTER TYPE:Hint: to show all the values of the all enums you have, you should call this query in bin/rails db or psql console:","title":"1.7 Enumerated Types","anchor":"#enumerated-types"},{"code":["\n# db/migrate/20131220144913_create_revisions.rb\ncreate_table :revisions do |t|\n  t.uuid :identifier\nend\n\n# db/migrate/20131220144913_create_revisions.rb\ncreate_table :revisions do |t|\n  t.uuid :identifier\nend\n\nCopy\n","\n# app/models/revision.rb\nclass Revision < ApplicationRecord\nend\n\n# app/models/revision.rb\nclass Revision < ApplicationRecord\nend\n\nCopy\n","\nirb> Revision.create identifier: \"A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\"\n\nirb> revision = Revision.first\nirb> revision.identifier\n=> \"a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\"\n\nRevision.create identifier: \"A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\"\nrevision = Revision.first\nrevision.identifier\n\nCopy\n","\n# db/migrate/20150418012400_create_blog.rb\nenable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')\ncreate_table :posts, id: :uuid\n\ncreate_table :comments, id: :uuid do |t|\n  # t.belongs_to :post, type: :uuid\n  t.references :post, type: :uuid\nend\n\n# db/migrate/20150418012400_create_blog.rb\nenable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')\ncreate_table :posts, id: :uuid\n\ncreate_table :comments, id: :uuid do |t|\n  # t.belongs_to :post, type: :uuid\n  t.references :post, type: :uuid\nend\n\nCopy\n","\n# app/models/post.rb\nclass Post < ApplicationRecord\n  has_many :comments\nend\n\n# app/models/post.rb\nclass Post < ApplicationRecord\n  has_many :comments\nend\n\nCopy\n","\n# app/models/comment.rb\nclass Comment < ApplicationRecord\n  belongs_to :post\nend\n\n# app/models/comment.rb\nclass Comment < ApplicationRecord\n  belongs_to :post\nend\n\nCopy\n"],"body":"You can use uuid type to define references in migrations:See this section for more details on using UUIDs as primary key.","title":"1.8 UUID","anchor":"#uuid"},{"title":"1.9 Bit String Types","anchor":"#bit-string-types","code":["\n# db/migrate/20131220144913_create_users.rb\ncreate_table :users, force: true do |t|\n  t.column :settings, \"bit(8)\"\nend\n\n# db/migrate/20131220144913_create_users.rb\ncreate_table :users, force: true do |t|\n  t.column :settings, \"bit(8)\"\nend\n\nCopy\n","\n# app/models/user.rb\nclass User < ApplicationRecord\nend\n\n# app/models/user.rb\nclass User < ApplicationRecord\nend\n\nCopy\n","\nirb> User.create settings: \"01010011\"\nirb> user = User.first\nirb> user.settings\n=> \"01010011\"\nirb> user.settings = \"0xAF\"\nirb> user.settings\n=> 10101111\nirb> user.save!\n\nUser.create settings: \"01010011\"\nuser = User.first\nuser.settings\nuser.settings = \"0xAF\"\nuser.settings\nuser.save!\n\nCopy\n"],"body":""},{"code":["\n# db/migrate/20140508144913_create_devices.rb\ncreate_table(:devices, force: true) do |t|\n  t.inet 'ip'\n  t.cidr 'network'\n  t.macaddr 'address'\nend\n\n# db/migrate/20140508144913_create_devices.rb\ncreate_table(:devices, force: true) do |t|\n  t.inet 'ip'\n  t.cidr 'network'\n  t.macaddr 'address'\nend\n\nCopy\n","\n# app/models/device.rb\nclass Device < ApplicationRecord\nend\n\n# app/models/device.rb\nclass Device < ApplicationRecord\nend\n\nCopy\n","\nirb> macbook = Device.create(ip: \"192.168.1.12\", network: \"192.168.2.0/24\", address: \"32:01:16:6d:05:ef\")\n\nirb> macbook.ip\n=> #<IPAddr: IPv4:192.168.1.12/255.255.255.255>\n\nirb> macbook.network\n=> #<IPAddr: IPv4:192.168.2.0/255.255.255.0>\n\nirb> macbook.address\n=> \"32:01:16:6d:05:ef\"\n\nmacbook = Device.create(ip: \"192.168.1.12\", network: \"192.168.2.0/24\", address: \"32:01:16:6d:05:ef\")\nmacbook.ip\nmacbook.network\nmacbook.address\n\nCopy\n"],"body":"The types inet and cidr are mapped to Ruby\nIPAddr\nobjects. The macaddr type is mapped to normal text.","title":"1.10 Network Address Types","anchor":"#network-address-types"},{"code":[],"body":"All geometric types, with the exception of points are mapped to normal text.\nA point is casted to an array containing x and y coordinates.","title":"1.11 Geometric Types","anchor":"#geometric-types"},{"title":"1.12 Interval","anchor":"#interval","code":["\n# db/migrate/20200120000000_create_events.rb\ncreate_table :events do |t|\n  t.interval 'duration'\nend\n\n# db/migrate/20200120000000_create_events.rb\ncreate_table :events do |t|\n  t.interval 'duration'\nend\n\nCopy\n","\n# app/models/event.rb\nclass Event < ApplicationRecord\nend\n\n# app/models/event.rb\nclass Event < ApplicationRecord\nend\n\nCopy\n","\nirb> Event.create(duration: 2.days)\n\nirb> event = Event.first\nirb> event.duration\n=> 2 days\n\nEvent.create(duration: 2.days)\nevent = Event.first\nevent.duration\n\nCopy\n"],"body":"This type is mapped to ActiveSupport::Duration objects."},{"code":["\n# db/migrate/20131220144913_create_devices.rb\nenable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')\ncreate_table :devices, id: :uuid do |t|\n  t.string :kind\nend\n\n# db/migrate/20131220144913_create_devices.rb\nenable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')\ncreate_table :devices, id: :uuid do |t|\n  t.string :kind\nend\n\nCopy\n","\n# app/models/device.rb\nclass Device < ApplicationRecord\nend\n\n# app/models/device.rb\nclass Device < ApplicationRecord\nend\n\nCopy\n","\nirb> device = Device.create\nirb> device.id\n=> \"814865cd-5a1d-4771-9306-4268f188fe9e\"\n\nirb> device = Device.create\nirb> device.id\n=> \"814865cd-5a1d-4771-9306-4268f188fe9e\"\n\nCopy\n"],"body":"","title":"2 UUID Primary Keys","anchor":"#uuid-primary-keys"},{"title":"3 Full Text Search","anchor":"#full-text-search","code":["\n# db/migrate/20131220144913_create_documents.rb\ncreate_table :documents do |t|\n  t.string 'title'\n  t.string 'body'\nend\n\nadd_index :documents, \"to_tsvector('english', title || ' ' || body)\", using: :gin, name: 'documents_idx'\n\n# db/migrate/20131220144913_create_documents.rb\ncreate_table :documents do |t|\n  t.string 'title'\n  t.string 'body'\nend\n\nadd_index :documents, \"to_tsvector('english', title || ' ' || body)\", using: :gin, name: 'documents_idx'\n\nCopy\n","\n# app/models/document.rb\nclass Document < ApplicationRecord\nend\n\n# app/models/document.rb\nclass Document < ApplicationRecord\nend\n\nCopy\n","\n# Usage\nDocument.create(title: \"Cats and Dogs\", body: \"are nice!\")\n\n## all documents matching 'cat & dog'\nDocument.where(\"to_tsvector('english', title || ' ' || body) @@ to_tsquery(?)\",\n                 \"cat & dog\")\n\n# Usage\nDocument.create(title: \"Cats and Dogs\", body: \"are nice!\")\n\n## all documents matching 'cat & dog'\nDocument.where(\"to_tsvector('english', title || ' ' || body) @@ to_tsquery(?)\",\n                 \"cat & dog\")\n\nCopy\n"],"body":""},{"code":["\nrails_pg_guide=# \\d \"TBL_ART\"\n                                        Table \"public.TBL_ART\"\n   Column   |            Type             |                         Modifiers\n------------+-----------------------------+------------------------------------------------------------\n INT_ID     | integer                     | not null default nextval('\"TBL_ART_INT_ID_seq\"'::regclass)\n STR_TITLE  | character varying           |\n STR_STAT   | character varying           | default 'draft'::character varying\n DT_PUBL_AT | timestamp without time zone |\n BL_ARCH    | boolean                     | default false\nIndexes:\n    \"TBL_ART_pkey\" PRIMARY KEY, btree (\"INT_ID\")\n\nrails_pg_guide=# \\d \"TBL_ART\"\n                                        Table \"public.TBL_ART\"\n   Column   |            Type             |                         Modifiers\n------------+-----------------------------+------------------------------------------------------------\n INT_ID     | integer                     | not null default nextval('\"TBL_ART_INT_ID_seq\"'::regclass)\n STR_TITLE  | character varying           |\n STR_STAT   | character varying           | default 'draft'::character varying\n DT_PUBL_AT | timestamp without time zone |\n BL_ARCH    | boolean                     | default false\nIndexes:\n    \"TBL_ART_pkey\" PRIMARY KEY, btree (\"INT_ID\")\n\nCopy\n","\n# db/migrate/20131220144913_create_articles_view.rb\nexecute <<-SQL\nCREATE VIEW articles AS\n  SELECT \"INT_ID\" AS id,\n         \"STR_TITLE\" AS title,\n         \"STR_STAT\" AS status,\n         \"DT_PUBL_AT\" AS published_at,\n         \"BL_ARCH\" AS archived\n  FROM \"TBL_ART\"\n  WHERE \"BL_ARCH\" = 'f'\n  SQL\n\n# db/migrate/20131220144913_create_articles_view.rb\nexecute <<-SQL\nCREATE VIEW articles AS\n  SELECT \"INT_ID\" AS id,\n         \"STR_TITLE\" AS title,\n         \"STR_STAT\" AS status,\n         \"DT_PUBL_AT\" AS published_at,\n         \"BL_ARCH\" AS archived\n  FROM \"TBL_ART\"\n  WHERE \"BL_ARCH\" = 'f'\n  SQL\n\nCopy\n","\n# app/models/article.rb\nclass Article < ApplicationRecord\n  self.primary_key = \"id\"\n  def archive!\n    update_attribute :archived, true\n  end\nend\n\n# app/models/article.rb\nclass Article < ApplicationRecord\n  self.primary_key = \"id\"\n  def archive!\n    update_attribute :archived, true\n  end\nend\n\nCopy\n","\nirb> first = Article.create! title: \"Winter is coming\", status: \"published\", published_at: 1.year.ago\nirb> second = Article.create! title: \"Brace yourself\", status: \"draft\", published_at: 1.month.ago\n\nirb> Article.count\n=> 2\nirb> first.archive!\nirb> Article.count\n=> 1\n\nfirst = Article.create! title: \"Winter is coming\", status: \"published\", published_at: 1.year.ago\nsecond = Article.create! title: \"Brace yourself\", status: \"draft\", published_at: 1.month.ago\nArticle.count\nfirst.archive!\nArticle.count\n\nCopy\n"],"body":"Imagine you need to work with a legacy database containing the following table:This table does not follow the Rails conventions at all.\nBecause simple PostgreSQL views are updateable by default,\nwe can wrap it as follows:","title":"4 Database Views","anchor":"#database-views"}]