[{"code":[],"body":"Internationalization is a complex problem. Natural languages differ in so many ways (e.g. in pluralization rules) that it is hard to provide tools for solving all problems at once. For that reason the Rails I18n API focuses on:As part of this solution, every static string in the Rails framework - e.g. Active Record validation messages, time and date formats - has been internationalized. Localization of a Rails application means defining translated values for these strings in desired languages.To localize store and update content in your application (e.g. translate blog posts), see the Translating model content section.","title":"1 How I18n in Ruby on Rails Works","anchor":"#how-i18n-in-ruby-on-rails-works"},{"title":"1.1 The Overall Architecture of the Library","anchor":"#the-overall-architecture-of-the-library","code":[],"body":"Thus, the Ruby I18n gem is split into two parts:As a user you should always only access the public methods on the I18n module, but it is useful to know about the capabilities of the backend."},{"title":"1.2 The Public I18n API","anchor":"#the-public-i18n-api","code":["\ntranslate # Lookup text translations\nlocalize  # Localize Date and Time objects to local formats\n\ntranslate # Lookup text translations\nlocalize  # Localize Date and Time objects to local formats\n\nCopy\n","\nI18n.t 'store.title'\nI18n.l Time.now\n\nI18n.t 'store.title'\nI18n.l Time.now\n\nCopy\n","\nload_path                 # Announce your custom translation files\nlocale                    # Get and set the current locale\ndefault_locale            # Get and set the default locale\navailable_locales         # Permitted locales available for the application\nenforce_available_locales # Enforce locale permission (true or false)\nexception_handler         # Use a different exception_handler\nbackend                   # Use a different backend\n\nload_path                 # Announce your custom translation files\nlocale                    # Get and set the current locale\ndefault_locale            # Get and set the default locale\navailable_locales         # Permitted locales available for the application\nenforce_available_locales # Enforce locale permission (true or false)\nexception_handler         # Use a different exception_handler\nbackend                   # Use a different backend\n\nCopy\n"],"body":"The most important methods of the I18n API are:These have the aliases #t and #l so you can use them like this:There are also attribute readers and writers for the following attributes:So, let's internationalize a simple Rails application from the ground up in the next chapters!"},{"title":"2 Setup the Rails Application for Internationalization","anchor":"#setup-the-rails-application-for-internationalization","code":[],"body":"There are a few steps to get up and running with I18n support for a Rails application."},{"title":"2.1 Configure the I18n Module","anchor":"#configure-the-i18n-module","code":["\nen:\n  hello: \"Hello world\"\n\nen:\n  hello: \"Hello world\"\n\nCopy\n","\nconfig.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}')]\nconfig.i18n.default_locale = :de\n\nconfig.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}')]\nconfig.i18n.default_locale = :de\n\nCopy\n","\n# config/initializers/locale.rb\n\n# Where the I18n library should search for translation files\nI18n.load_path += Dir[Rails.root.join('lib', 'locale', '*.{rb,yml}')]\n\n# Permitted locales available for the application\nI18n.available_locales = [:en, :pt]\n\n# Set default locale to something other than :en\nI18n.default_locale = :pt\n\n# config/initializers/locale.rb\n\n# Where the I18n library should search for translation files\nI18n.load_path += Dir[Rails.root.join('lib', 'locale', '*.{rb,yml}')]\n\n# Permitted locales available for the application\nI18n.available_locales = [:en, :pt]\n\n# Set default locale to something other than :en\nI18n.default_locale = :pt\n\nCopy\n"],"body":"Following the convention over configuration philosophy, Rails I18n provides reasonable default translation strings. When different translation strings are needed, they can be overridden.Rails adds all .rb and .yml files from the config/locales directory to the translations load path, automatically.The default en.yml locale in this directory contains a sample pair of translation strings:This means, that in the :en locale, the key hello will map to the Hello world string. Every string inside Rails is internationalized in this way, see for instance Active Model validation messages in the activemodel/lib/active_model/locale/en.yml file or time and date formats in the activesupport/lib/active_support/locale/en.yml file. You can use YAML or standard Ruby Hashes to store translations in the default (Simple) backend.The I18n library will use English as a default locale, i.e. if a different locale is not set, :en will be used for looking up translations.The translations load path (I18n.load_path) is an array of paths to files that will be loaded automatically. Configuring this path allows for customization of translations directory structure and file naming scheme.You can change the default locale as well as configure the translations load paths in config/application.rb as follows:The load path must be specified before any translations are looked up. To change the default locale from an initializer instead of config/application.rb:Note that appending directly to I18n.load_path instead of to the application's configured i18n will not override translations from external gems."},{"title":"2.2 Managing the Locale across Requests","anchor":"#managing-the-locale-across-requests","code":["\naround_action :switch_locale\n\ndef switch_locale(&action)\n  locale = params[:locale] || I18n.default_locale\n  I18n.with_locale(locale, &action)\nend\n\naround_action :switch_locale\n\ndef switch_locale(&action)\n  locale = params[:locale] || I18n.default_locale\n  I18n.with_locale(locale, &action)\nend\n\nCopy\n"],"body":"A localized application will likely need to provide support for multiple locales. To accomplish this, the locale should be set at the beginning of each request so that all strings are translated using the desired locale during the lifetime of that request.The default locale is used for all translations unless I18n.locale= or I18n.with_locale is used.I18n.locale can leak into subsequent requests served by the same thread/process if it is not consistently set in every controller. For example executing I18n.locale = :es in one POST requests will have effects for all later requests to controllers that don't set the locale, but only in that particular thread/process. For that reason, instead of I18n.locale = you can use I18n.with_locale which does not have this leak issue.The locale can be set in an around_action in the ApplicationController:This example illustrates this using a URL query parameter to set the locale (e.g. http://example.com/books?locale=pt). With this approach, http://localhost:3000?locale=pt renders the Portuguese localization, while http://localhost:3000?locale=de loads a German localization.The locale can be set using one of many different approaches."},{"title":"2.2.1 Setting the Locale from the Domain Name","anchor":"#setting-the-locale-from-the-domain-name","code":["\naround_action :switch_locale\n\ndef switch_locale(&action)\n  locale = extract_locale_from_tld || I18n.default_locale\n  I18n.with_locale(locale, &action)\nend\n\n# Get locale from top-level domain or return +nil+ if such locale is not available\n# You have to put something like:\n#   127.0.0.1 application.com\n#   127.0.0.1 application.it\n#   127.0.0.1 application.pl\n# in your /etc/hosts file to try this out locally\ndef extract_locale_from_tld\n  parsed_locale = request.host.split('.').last\n  I18n.available_locales.map(&:to_s).include?(parsed_locale) ? parsed_locale : nil\nend\n\naround_action :switch_locale\n\ndef switch_locale(&action)\n  locale = extract_locale_from_tld || I18n.default_locale\n  I18n.with_locale(locale, &action)\nend\n\n# Get locale from top-level domain or return +nil+ if such locale is not available\n# You have to put something like:\n#   127.0.0.1 application.com\n#   127.0.0.1 application.it\n#   127.0.0.1 application.pl\n# in your /etc/hosts file to try this out locally\ndef extract_locale_from_tld\n  parsed_locale = request.host.split('.').last\n  I18n.available_locales.map(&:to_s).include?(parsed_locale) ? parsed_locale : nil\nend\n\nCopy\n","\n# Get locale code from request subdomain (like http://it.application.local:3000)\n# You have to put something like:\n#   127.0.0.1 gr.application.local\n# in your /etc/hosts file to try this out locally\ndef extract_locale_from_subdomain\n  parsed_locale = request.subdomains.first\n  I18n.available_locales.map(&:to_s).include?(parsed_locale) ? parsed_locale : nil\nend\n\n# Get locale code from request subdomain (like http://it.application.local:3000)\n# You have to put something like:\n#   127.0.0.1 gr.application.local\n# in your /etc/hosts file to try this out locally\ndef extract_locale_from_subdomain\n  parsed_locale = request.subdomains.first\n  I18n.available_locales.map(&:to_s).include?(parsed_locale) ? parsed_locale : nil\nend\n\nCopy\n","\nlink_to(\"Deutsch\", \"#{APP_CONFIG[:deutsch_website_url]}#{request.env['PATH_INFO']}\")\n\nlink_to(\"Deutsch\", \"#{APP_CONFIG[:deutsch_website_url]}#{request.env['PATH_INFO']}\")\n\nCopy\n"],"body":"One option you have is to set the locale from the domain name where your application runs. For example, we want www.example.com to load the English (or default) locale, and www.example.es to load the Spanish locale. Thus the top-level domain name is used for locale setting. This has several advantages:You can implement it like this in your ApplicationController:We can also set the locale from the subdomain in a very similar way:If your application includes a locale switching menu, you would then have something like this in it:assuming you would set APP_CONFIG[:deutsch_website_url] to some value like http://www.application.de.This solution has aforementioned advantages, however, you may not be able or may not want to provide different localizations (\"language versions\") on different domains. The most obvious solution would be to include locale code in the URL params (or request path)."},{"title":"2.2.2 Setting the Locale from URL Params","anchor":"#setting-the-locale-from-url-params","code":["\n# app/controllers/application_controller.rb\ndef default_url_options\n  { locale: I18n.locale }\nend\n\n# app/controllers/application_controller.rb\ndef default_url_options\n  { locale: I18n.locale }\nend\n\nCopy\n","\n# config/routes.rb\nscope \"/:locale\" do\n  resources :books\nend\n\n# config/routes.rb\nscope \"/:locale\" do\n  resources :books\nend\n\nCopy\n","\n# config/routes.rb\nscope \"(:locale)\", locale: /en|nl/ do\n  resources :books\nend\n\n# config/routes.rb\nscope \"(:locale)\", locale: /en|nl/ do\n  resources :books\nend\n\nCopy\n","\n# config/routes.rb\nget '/:locale' => 'dashboard#index'\n\n# config/routes.rb\nget '/:locale' => 'dashboard#index'\n\nCopy\n"],"body":"The most usual way of setting (and passing) the locale would be to include it in URL params, as we did in the I18n.with_locale(params[:locale], &action) around_action in the first example. We would like to have URLs like www.example.com/books?locale=ja or www.example.com/ja/books in this case.This approach has almost the same set of advantages as setting the locale from the domain name: namely that it's RESTful and in accord with the rest of the World Wide Web. It does require a little bit more work to implement, though.Getting the locale from params and setting it accordingly is not hard; including it in every URL and thus passing it through the requests is. To include an explicit option in every URL, e.g. link_to(books_url(locale: I18n.locale)), would be tedious and probably impossible, of course.Rails contains infrastructure for \"centralizing dynamic decisions about the URLs\" in its ApplicationController#default_url_options, which is useful precisely in this scenario: it enables us to set \"defaults\" for url_for and helper methods dependent on it (by implementing/overriding default_url_options).We can include something like this in our ApplicationController then:Every helper method dependent on url_for (e.g. helpers for named routes like root_path or root_url, resource routes like books_path or books_url, etc.) will now automatically include the locale in the query string, like this: http://localhost:3001/?locale=ja.You may be satisfied with this. It does impact the readability of URLs, though, when the locale \"hangs\" at the end of every URL in your application. Moreover, from the architectural standpoint, locale is usually hierarchically above the other parts of the application domain: and URLs should reflect this.You probably want URLs to look like this: http://www.example.com/en/books (which loads the English locale) and http://www.example.com/nl/books (which loads the Dutch locale). This is achievable with the \"over-riding default_url_options\" strategy from above: you just have to set up your routes with scope:Now, when you call the books_path method you should get \"/en/books\" (for the default locale). A URL like http://localhost:3001/nl/books should load the Dutch locale, then, and following calls to books_path should return \"/nl/books\" (because the locale changed).If you don't want to force the use of a locale in your routes you can use an optional path scope (denoted by the parentheses) like so:With this approach you will not get a Routing Error when accessing your resources such as http://localhost:3001/books without a locale. This is useful for when you want to use the default locale when one is not specified.Of course, you need to take special care of the root URL (usually \"homepage\" or \"dashboard\") of your application. A URL like http://localhost:3001/nl will not work automatically, because the root to: \"dashboard#index\" declaration in your routes.rb doesn't take locale into account. (And rightly so: there's only one \"root\" URL.)You would probably need to map URLs like these:Do take special care about the order of your routes, so this route declaration does not \"eat\" other ones. (You may want to add it directly before the root :to declaration.)"},{"title":"2.2.3 Setting the Locale from User Preferences","anchor":"#setting-the-locale-from-user-preferences","code":["\naround_action :switch_locale\n\ndef switch_locale(&action)\n  locale = current_user.try(:locale) || I18n.default_locale\n  I18n.with_locale(locale, &action)\nend\n\naround_action :switch_locale\n\ndef switch_locale(&action)\n  locale = current_user.try(:locale) || I18n.default_locale\n  I18n.with_locale(locale, &action)\nend\n\nCopy\n"],"body":"An application with authenticated users may allow users to set a locale preference through the application's interface. With this approach, a user's selected locale preference is persisted in the database and used to set the locale for authenticated requests by that user."},{"code":["\ndef switch_locale(&action)\n  logger.debug \"* Accept-Language: #{request.env['HTTP_ACCEPT_LANGUAGE']}\"\n  locale = extract_locale_from_accept_language_header\n  logger.debug \"* Locale set to '#{locale}'\"\n  I18n.with_locale(locale, &action)\nend\n\nprivate\n  def extract_locale_from_accept_language_header\n    request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first\n  end\n\ndef switch_locale(&action)\n  logger.debug \"* Accept-Language: #{request.env['HTTP_ACCEPT_LANGUAGE']}\"\n  locale = extract_locale_from_accept_language_header\n  logger.debug \"* Locale set to '#{locale}'\"\n  I18n.with_locale(locale, &action)\nend\n\nprivate\n  def extract_locale_from_accept_language_header\n    request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first\n  end\n\nCopy\n"],"body":"When an explicit locale has not been set for a request (e.g. via one of the above methods), an application should attempt to infer the desired locale.The Accept-Language HTTP header indicates the preferred language for request's response. Browsers set this header value based on the user's language preference settings, making it a good first choice when inferring a locale.A trivial implementation of using an Accept-Language header would be:In practice, more robust code is necessary to do this reliably. Iain Hecker's http_accept_language library or Ryan Tomayko's locale Rack middleware provide solutions to this problem.The IP address of the client making the request can be used to infer the client's region and thus their locale. Services such as GeoIP Lite Country or gems like geocoder can be used to implement this approach.In general, this approach is far less reliable than using the language header and is not recommended for most web applications.","title":"2.2.4 Choosing an Implied Locale","anchor":"#choosing-an-implied-locale"},{"title":"2.2.5 Storing the Locale from the Session or Cookies","anchor":"#storing-the-locale-from-the-session-or-cookies","code":[],"body":""},{"title":"3 Internationalization and Localization","anchor":"#internationalization-and-localization","code":["\n# config/routes.rb\nRails.application.routes.draw do\n  root to: \"home#index\"\nend\n\n# config/routes.rb\nRails.application.routes.draw do\n  root to: \"home#index\"\nend\n\nCopy\n","\n# app/controllers/application_controller.rb\nclass ApplicationController < ActionController::Base\n\n  around_action :switch_locale\n\n  def switch_locale(&action)\n    locale = params[:locale] || I18n.default_locale\n    I18n.with_locale(locale, &action)\n  end\nend\n\n# app/controllers/application_controller.rb\nclass ApplicationController < ActionController::Base\n\n  around_action :switch_locale\n\n  def switch_locale(&action)\n    locale = params[:locale] || I18n.default_locale\n    I18n.with_locale(locale, &action)\n  end\nend\n\nCopy\n","\n# app/controllers/home_controller.rb\nclass HomeController < ApplicationController\n  def index\n    flash[:notice] = \"Hello Flash\"\n  end\nend\n\n# app/controllers/home_controller.rb\nclass HomeController < ApplicationController\n  def index\n    flash[:notice] = \"Hello Flash\"\n  end\nend\n\nCopy\n","\n<!-- app/views/home/index.html.erb -->\n<h1>Hello World</h1>\n<p><%= flash[:notice] %></p>\n\n<!-- app/views/home/index.html.erb -->\n<h1>Hello World</h1>\n<p><%= flash[:notice] %></p>\n\nCopy\n"],"body":"OK! Now you've initialized I18n support for your Ruby on Rails application and told it which locale to use and how to preserve it between requests.Next we need to internationalize our application by abstracting every locale-specific element. Finally, we need to localize it by providing necessary translations for these abstracts.Given the following example:"},{"title":"3.1 Abstracting Localized Code","anchor":"#abstracting-localized-code","code":["\n# app/controllers/home_controller.rb\nclass HomeController < ApplicationController\n  def index\n    flash[:notice] = t(:hello_flash)\n  end\nend\n\n# app/controllers/home_controller.rb\nclass HomeController < ApplicationController\n  def index\n    flash[:notice] = t(:hello_flash)\n  end\nend\n\nCopy\n","\n<!-- app/views/home/index.html.erb -->\n<h1><%= t :hello_world %></h1>\n<p><%= flash[:notice] %></p>\n\n<!-- app/views/home/index.html.erb -->\n<h1><%= t :hello_world %></h1>\n<p><%= flash[:notice] %></p>\n\nCopy\n"],"body":"There are two strings in our code that are in English and that users will be rendered in our response (\"Hello Flash\" and \"Hello World\"). In order to internationalize this code, these strings need to be replaced by calls to Rails' #t helper with an appropriate key for each string:Now, when this view is rendered, it will show an error message which tells you that the translations for the keys :hello_world and :hello_flash are missing."},{"title":"3.2 Providing Translations for Internationalized Strings","anchor":"#providing-translations-for-internationalized-strings","code":["\n# config/locales/en.yml\nen:\n  hello_world: Hello world!\n  hello_flash: Hello flash!\n\n# config/locales/en.yml\nen:\n  hello_world: Hello world!\n  hello_flash: Hello flash!\n\nCopy\n","\n# config/locales/pirate.yml\npirate:\n  hello_world: Ahoy World\n  hello_flash: Ahoy Flash\n\n# config/locales/pirate.yml\npirate:\n  hello_world: Ahoy World\n  hello_flash: Ahoy Flash\n\nCopy\n","\n# config/locales/en.yml\nen:\n  success:\n    'true':  'True!'\n    'on':    'On!'\n    'false': 'False!'\n  failure:\n    true:    'True!'\n    off:     'Off!'\n    false:   'False!'\n\n# config/locales/en.yml\nen:\n  success:\n    'true':  'True!'\n    'on':    'On!'\n    'false': 'False!'\n  failure:\n    true:    'True!'\n    off:     'Off!'\n    false:   'False!'\n\nCopy\n","\nI18n.t 'success.true'  # => 'True!'\nI18n.t 'success.on'    # => 'On!'\nI18n.t 'success.false' # => 'False!'\nI18n.t 'failure.false' # => Translation Missing\nI18n.t 'failure.off'   # => Translation Missing\nI18n.t 'failure.true'  # => Translation Missing\n\nI18n.t 'success.true'  # => 'True!'\nI18n.t 'success.on'    # => 'On!'\nI18n.t 'success.false' # => 'False!'\nI18n.t 'failure.false' # => Translation Missing\nI18n.t 'failure.off'   # => Translation Missing\nI18n.t 'failure.true'  # => Translation Missing\n\nCopy\n"],"body":"Add the missing translations into the translation dictionary files:Because the default_locale hasn't changed, translations use the :en locale and the response renders the english strings:If the locale is set via the URL to the pirate locale (http://localhost:3000?locale=pirate), the response renders the pirate strings:You may use YAML (.yml) or plain Ruby (.rb) files for storing your translations in SimpleStore. YAML is the preferred option among Rails developers. However, it has one big disadvantage. YAML is very sensitive to whitespace and special characters, so the application may not load your dictionary properly. Ruby files will crash your application on first request, so you may easily find what's wrong. (If you encounter any \"weird issues\" with YAML dictionaries, try putting the relevant portion of your dictionary into a Ruby file.)If your translations are stored in YAML files, certain keys must be escaped. They are:Examples:"},{"code":["\n<!-- app/views/products/show.html.erb -->\n<%= \"#{t('currency')}#{@product.price}\" %>\n\n<!-- app/views/products/show.html.erb -->\n<%= \"#{t('currency')}#{@product.price}\" %>\n\nCopy\n","\n# config/locales/en.yml\nen:\n  currency: \"$\"\n\n# config/locales/en.yml\nen:\n  currency: \"$\"\n\nCopy\n","\n# config/locales/es.yml\nes:\n  currency: \"€\"\n\n# config/locales/es.yml\nes:\n  currency: \"€\"\n\nCopy\n","\n<!-- app/views/products/show.html.erb -->\n<%= t('product_price', price: @product.price) %>\n\n<!-- app/views/products/show.html.erb -->\n<%= t('product_price', price: @product.price) %>\n\nCopy\n","\n# config/locales/en.yml\nen:\n  product_price: \"$%{price}\"\n\n# config/locales/en.yml\nen:\n  product_price: \"$%{price}\"\n\nCopy\n","\n# config/locales/es.yml\nes:\n  product_price: \"%{price} €\"\n\n# config/locales/es.yml\nes:\n  product_price: \"%{price} €\"\n\nCopy\n"],"body":"One key consideration for successfully internationalizing an application is to\navoid making incorrect assumptions about grammar rules when abstracting localized\ncode. Grammar rules that seem fundamental in one locale may not hold true in\nanother one.Improper abstraction is shown in the following example, where assumptions are\nmade about the ordering of the different parts of the translation. Note that Rails\nprovides a number_to_currency helper to handle the following case.If the product's price is 10 then the proper translation for Spanish is \"10 €\"\ninstead of \"€10\" but the abstraction cannot give it.To create proper abstraction, the I18n gem ships with a feature called variable\ninterpolation that allows you to use variables in translation definitions and\npass the values for these variables to the translation method.Proper abstraction is shown in the following example:All grammatical and punctuation decisions are made in the definition itself, so\nthe abstraction can give a proper translation.","title":"3.3 Passing Variables to Translations","anchor":"#passing-variables-to-translations"},{"title":"3.4 Adding Date/Time Formats","anchor":"#adding-date-time-formats","code":["\n<!-- app/views/home/index.html.erb -->\n<h1><%= t :hello_world %></h1>\n<p><%= flash[:notice] %></p>\n<p><%= l Time.now, format: :short %></p>\n\n<!-- app/views/home/index.html.erb -->\n<h1><%= t :hello_world %></h1>\n<p><%= flash[:notice] %></p>\n<p><%= l Time.now, format: :short %></p>\n\nCopy\n","\n# config/locales/pirate.yml\npirate:\n  time:\n    formats:\n      short: \"arrrround %H'ish\"\n\n# config/locales/pirate.yml\npirate:\n  time:\n    formats:\n      short: \"arrrround %H'ish\"\n\nCopy\n"],"body":"OK! Now let's add a timestamp to the view, so we can demo the date/time localization feature as well. To localize the time format you pass the Time object to I18n.l or (preferably) use Rails' #l helper. You can pick a format by passing the :format option - by default the :default format is used.And in our pirate translations file let's add a time format (it's already there in Rails' defaults for English):So that would give you:"},{"title":"3.5 Inflection Rules for Other Locales","anchor":"#inflection-rules-for-other-locales","code":[],"body":"Rails allows you to define inflection rules (such as rules for singularization and pluralization) for locales other than English. In config/initializers/inflections.rb, you can define these rules for multiple locales. The initializer contains a default example for specifying additional rules for English; follow that format for other locales as you see fit."},{"title":"3.6 Localized Views","anchor":"#localized-views","code":[],"body":"Let's say you have a BooksController in your application. Your index action renders content in app/views/books/index.html.erb template. When you put a localized variant of this template: index.es.html.erb in the same directory, Rails will render content in this template, when the locale is set to :es. When the locale is set to the default locale, the generic index.html.erb view will be used. (Future Rails versions may well bring this automagic localization to assets in public, etc.)You can make use of this feature, e.g. when working with a large amount of static content, which would be clumsy to put inside YAML or Ruby dictionaries. Bear in mind, though, that any change you would like to do later to the template must be propagated to all of them."},{"title":"3.7 Organization of Locale Files","anchor":"#organization-of-locale-files","code":["\n|-defaults\n|---es.yml\n|---en.yml\n|-models\n|---book\n|-----es.yml\n|-----en.yml\n|-views\n|---defaults\n|-----es.yml\n|-----en.yml\n|---books\n|-----es.yml\n|-----en.yml\n|---users\n|-----es.yml\n|-----en.yml\n|---navigation\n|-----es.yml\n|-----en.yml\n\n|-defaults\n|---es.yml\n|---en.yml\n|-models\n|---book\n|-----es.yml\n|-----en.yml\n|-views\n|---defaults\n|-----es.yml\n|-----en.yml\n|---books\n|-----es.yml\n|-----en.yml\n|---users\n|-----es.yml\n|-----en.yml\n|---navigation\n|-----es.yml\n|-----en.yml\n\nCopy\n","\n# config/application.rb\nconfig.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.{rb,yml}')]\n\n# config/application.rb\nconfig.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.{rb,yml}')]\n\nCopy\n"],"body":"When you are using the default SimpleStore shipped with the i18n library,\ndictionaries are stored in plain-text files on the disk. Putting translations\nfor all parts of your application in one file per locale could be hard to\nmanage. You can store these files in a hierarchy which makes sense to you.For example, your config/locales directory could look like this:This way, you can separate model and model attribute names from text inside views, and all of this from the \"defaults\" (e.g. date and time formats). Other stores for the i18n library could provide different means of such separation."},{"code":[],"body":"You should have a good understanding of using the i18n library now and know how\nto internationalize a basic Rails application. In the following chapters, we'll\ncover its features in more depth.These chapters will show examples using both the I18n.translate method as well as the translate view helper method (noting the additional feature provide by the view helper method).Covered are features like these:","title":"4 Overview of the I18n API Features","anchor":"#overview-of-the-i18n-api-features"},{"code":[],"body":"","title":"4.1 Looking up Translations","anchor":"#looking-up-translations"},{"title":"4.1.1 Basic Lookup, Scopes, and Nested Keys","anchor":"#basic-lookup-scopes-and-nested-keys","code":["\nI18n.t :message\nI18n.t 'message'\n\nI18n.t :message\nI18n.t 'message'\n\nCopy\n","\nI18n.t :record_invalid, scope: [:activerecord, :errors, :messages]\n\nI18n.t :record_invalid, scope: [:activerecord, :errors, :messages]\n\nCopy\n","\nI18n.translate \"activerecord.errors.messages.record_invalid\"\n\nI18n.translate \"activerecord.errors.messages.record_invalid\"\n\nCopy\n","\nI18n.t 'activerecord.errors.messages.record_invalid'\nI18n.t 'errors.messages.record_invalid', scope: :activerecord\nI18n.t :record_invalid, scope: 'activerecord.errors.messages'\nI18n.t :record_invalid, scope: [:activerecord, :errors, :messages]\n\nI18n.t 'activerecord.errors.messages.record_invalid'\nI18n.t 'errors.messages.record_invalid', scope: :activerecord\nI18n.t :record_invalid, scope: 'activerecord.errors.messages'\nI18n.t :record_invalid, scope: [:activerecord, :errors, :messages]\n\nCopy\n"],"body":"Translations are looked up by keys which can be both Symbols or Strings, so these calls are equivalent:The translate method also takes a :scope option which can contain one or more additional keys that will be used to specify a \"namespace\" or scope for a translation key:This looks up the :record_invalid message in the Active Record error messages.Additionally, both the key and scopes can be specified as dot-separated keys as in:Thus the following calls are equivalent:"},{"code":["\nI18n.t :missing, default: 'Not here'\n# => 'Not here'\n\nI18n.t :missing, default: 'Not here'\n# => 'Not here'\n\nCopy\n","\nI18n.t :missing, default: [:also_missing, 'Not here']\n# => 'Not here'\n\nI18n.t :missing, default: [:also_missing, 'Not here']\n# => 'Not here'\n\nCopy\n"],"body":"When a :default option is given, its value will be returned if the translation is missing:If the :default value is a Symbol, it will be used as a key and translated. One can provide multiple values as default. The first one that results in a value will be returned.E.g., the following first tries to translate the key :missing and then the key :also_missing. As both do not yield a result, the string \"Not here\" will be returned:","title":"4.1.2 Defaults","anchor":"#defaults"},{"code":["\nI18n.t [:odd, :even], scope: 'errors.messages'\n# => [\"must be odd\", \"must be even\"]\n\nI18n.t [:odd, :even], scope: 'errors.messages'\n# => [\"must be odd\", \"must be even\"]\n\nCopy\n","\nI18n.t 'activerecord.errors.messages'\n# => {:inclusion=>\"is not included in the list\", :exclusion=> ... }\n\nI18n.t 'activerecord.errors.messages'\n# => {:inclusion=>\"is not included in the list\", :exclusion=> ... }\n\nCopy\n","\nen:\n  welcome:\n    title: \"Welcome!\"\n    content: \"Welcome to the %{app_name}\"\n\nen:\n  welcome:\n    title: \"Welcome!\"\n    content: \"Welcome to the %{app_name}\"\n\nCopy\n","\nI18n.t 'welcome', app_name: 'book store'\n# => {:title=>\"Welcome!\", :content=>\"Welcome to the %{app_name}\"}\n\nI18n.t 'welcome', deep_interpolation: true, app_name: 'book store'\n# => {:title=>\"Welcome!\", :content=>\"Welcome to the book store\"}\n\nI18n.t 'welcome', app_name: 'book store'\n# => {:title=>\"Welcome!\", :content=>\"Welcome to the %{app_name}\"}\n\nI18n.t 'welcome', deep_interpolation: true, app_name: 'book store'\n# => {:title=>\"Welcome!\", :content=>\"Welcome to the book store\"}\n\nCopy\n"],"body":"To look up multiple translations at once, an array of keys can be passed:Also, a key can translate to a (potentially nested) hash of grouped translations. E.g., one can receive all Active Record error messages as a Hash with:If you want to perform interpolation on a bulk hash of translations, you need to pass deep_interpolation: true as a parameter. When you have the following dictionary:then the nested interpolation will be ignored without the setting:","title":"4.1.3 Bulk and Namespace Lookup","anchor":"#bulk-and-namespace-lookup"},{"code":["\nes:\n  books:\n    index:\n      title: \"Título\"\n\nes:\n  books:\n    index:\n      title: \"Título\"\n\nCopy\n","\n<%= t '.title' %>\n\n<%= t '.title' %>\n\nCopy\n","\nen:\n  books:\n    create:\n      success: Book created!\n\nen:\n  books:\n    create:\n      success: Book created!\n\nCopy\n","\nclass BooksController < ApplicationController\n  def create\n    # ...\n    redirect_to books_url, notice: t('.success')\n  end\nend\n\nclass BooksController < ApplicationController\n  def create\n    # ...\n    redirect_to books_url, notice: t('.success')\n  end\nend\n\nCopy\n"],"body":"Rails implements a convenient way to look up the locale inside views. When you have the following dictionary:you can look up the books.index.title value inside app/views/books/index.html.erb template like this (note the dot):\"Lazy\" lookup can also be used in controllers:This is useful for setting flash messages for instance:","title":"4.1.4 \"Lazy\" Lookup","anchor":"#lazy-lookup"},{"code":["\nI18n.backend.store_translations :en, inbox: {\n  zero: 'no messages', # optional\n  one: 'one message',\n  other: '%{count} messages'\n}\nI18n.translate :inbox, count: 2\n# => '2 messages'\n\nI18n.translate :inbox, count: 1\n# => 'one message'\n\nI18n.translate :inbox, count: 0\n# => 'no messages'\n\nI18n.backend.store_translations :en, inbox: {\n  zero: 'no messages', # optional\n  one: 'one message',\n  other: '%{count} messages'\n}\nI18n.translate :inbox, count: 2\n# => '2 messages'\n\nI18n.translate :inbox, count: 1\n# => 'one message'\n\nI18n.translate :inbox, count: 0\n# => 'no messages'\n\nCopy\n","\nlookup_key = :zero if count == 0 && entry.has_key?(:zero)\nlookup_key ||= count == 1 ? :one : :other\nentry[lookup_key]\n\nlookup_key = :zero if count == 0 && entry.has_key?(:zero)\nlookup_key ||= count == 1 ? :one : :other\nentry[lookup_key]\n\nCopy\n"],"body":"In many languages — including English — there are only two forms, a singular and a plural, for\na given string, e.g. \"1 message\" and \"2 messages\". Other languages (Arabic, Japanese, Russian and many more) have different grammars that have additional or fewer plural forms. Thus, the I18n API provides a flexible pluralization feature.The :count interpolation variable has a special role in that it both is interpolated to the translation and used to pick a pluralization from the translations according to the pluralization rules defined in the\npluralization backend. By default, only the English pluralization rules are applied.The algorithm for pluralizations in :en is as simple as:The translation denoted as :one is regarded as singular, and the :other is used as plural. If the count is zero, and a :zero entry is present, then it will be used instead of :other.If the lookup for the key does not return a Hash suitable for pluralization, an I18n::InvalidPluralizationData exception is raised.","title":"4.2 Pluralization","anchor":"#pluralization"},{"title":"4.2.1 Locale-specific rules","anchor":"#locale-specific-rules","code":["\nI18n::Backend::Simple.include(I18n::Backend::Pluralization)\nI18n.backend.store_translations :pt, i18n: { plural: { rule: lambda { |n| [0, 1].include?(n) ? :one : :other } } }\nI18n.backend.store_translations :pt, apples: { one: 'one or none', other: 'more than one' }\n\nI18n.t :apples, count: 0, locale: :pt\n# => 'one or none'\n\nI18n::Backend::Simple.include(I18n::Backend::Pluralization)\nI18n.backend.store_translations :pt, i18n: { plural: { rule: lambda { |n| [0, 1].include?(n) ? :one : :other } } }\nI18n.backend.store_translations :pt, apples: { one: 'one or none', other: 'more than one' }\n\nI18n.t :apples, count: 0, locale: :pt\n# => 'one or none'\n\nCopy\n"],"body":"The I18n gem provides a Pluralization backend that can be used to enable locale-specific rules. Include it\nto the Simple backend, then add the localized pluralization algorithms to translation store, as i18n.plural.rule.Alternatively, the separate gem rails-i18n can be used to provide a fuller set of locale-specific pluralization rules."},{"title":"4.3 Setting and Passing a Locale","anchor":"#setting-and-passing-a-locale","code":["\nI18n.locale = :de\nI18n.t :foo\nI18n.l Time.now\n\nI18n.locale = :de\nI18n.t :foo\nI18n.l Time.now\n\nCopy\n","\nI18n.t :foo, locale: :de\nI18n.l Time.now, locale: :de\n\nI18n.t :foo, locale: :de\nI18n.l Time.now, locale: :de\n\nCopy\n","\nI18n.default_locale = :de\n\nI18n.default_locale = :de\n\nCopy\n"],"body":"The locale can be either set pseudo-globally to I18n.locale (which uses Thread.current like, e.g., Time.zone) or can be passed as an option to #translate and #localize.If no locale is passed, I18n.locale is used:Explicitly passing a locale:The I18n.locale defaults to I18n.default_locale which defaults to :en. The default locale can be set like this:"},{"code":["\n# config/locales/en.yml\nen:\n  welcome: <b>welcome!</b>\n  hello_html: <b>hello!</b>\n  title:\n    html: <b>title!</b>\n\n# config/locales/en.yml\nen:\n  welcome: <b>welcome!</b>\n  hello_html: <b>hello!</b>\n  title:\n    html: <b>title!</b>\n\nCopy\n","\n<!-- app/views/home/index.html.erb -->\n<div><%= t('welcome') %></div>\n<div><%= raw t('welcome') %></div>\n<div><%= t('hello_html') %></div>\n<div><%= t('title.html') %></div>\n\n<!-- app/views/home/index.html.erb -->\n<div><%= t('welcome') %></div>\n<div><%= raw t('welcome') %></div>\n<div><%= t('hello_html') %></div>\n<div><%= t('title.html') %></div>\n\nCopy\n","\nen:\n  welcome_html: \"<b>Welcome %{username}!</b>\"\n\nen:\n  welcome_html: \"<b>Welcome %{username}!</b>\"\n\nCopy\n","\n<%# This is safe, it is going to be escaped if needed. %>\n<%= t('welcome_html', username: @current_user.username) %>\n\n<%# This is safe, it is going to be escaped if needed. %>\n<%= t('welcome_html', username: @current_user.username) %>\n\nCopy\n"],"body":"Keys with a '_html' suffix and keys named 'html' are marked as HTML safe. When you use them in views the HTML will not be escaped.Interpolation escapes as needed though. For example, given:you can safely pass the username as set by the user:Safe strings on the other hand are interpolated verbatim.","title":"4.4 Using Safe HTML Translations","anchor":"#using-safe-html-translations"},{"title":"4.5 Translations for Active Record Models","anchor":"#translations-for-active-record-models","code":["\nen:\n  activerecord:\n    models:\n      user: Customer\n    attributes:\n      user:\n        login: \"Handle\"\n      # will translate User attribute \"login\" as \"Handle\"\n\nen:\n  activerecord:\n    models:\n      user: Customer\n    attributes:\n      user:\n        login: \"Handle\"\n      # will translate User attribute \"login\" as \"Handle\"\n\nCopy\n","\nen:\n  activerecord:\n    models:\n      user:\n        one: Customer\n        other: Customers\n\nen:\n  activerecord:\n    models:\n      user:\n        one: Customer\n        other: Customers\n\nCopy\n","\nen:\n  activerecord:\n    attributes:\n      user/role:\n        admin: \"Admin\"\n        contributor: \"Contributor\"\n\nen:\n  activerecord:\n    attributes:\n      user/role:\n        admin: \"Admin\"\n        contributor: \"Contributor\"\n\nCopy\n"],"body":"You can use the methods Model.model_name.human and Model.human_attribute_name(attribute) to transparently look up translations for your model and attribute names.For example when you add the following translations:Then User.model_name.human will return \"Customer\" and User.human_attribute_name(\"login\") will return \"Handle\".You can also set a plural form for model names, adding as following:Then User.model_name.human(count: 2) will return \"Customers\". With count: 1 or without params will return \"Customer\".In the event you need to access nested attributes within a given model, you should nest these under model/attribute at the model level of your translation file:Then User.human_attribute_name(\"role.admin\") will return \"Admin\"."},{"title":"4.5.1 Error Message Scopes","anchor":"#error-message-scopes","code":["\nclass User < ApplicationRecord\n  validates :name, presence: true\nend\n\nclass User < ApplicationRecord\n  validates :name, presence: true\nend\n\nCopy\n","\nactiverecord.errors.models.[model_name].attributes.[attribute_name]\nactiverecord.errors.models.[model_name]\nactiverecord.errors.messages\nerrors.attributes.[attribute_name]\nerrors.messages\n\nactiverecord.errors.models.[model_name].attributes.[attribute_name]\nactiverecord.errors.models.[model_name]\nactiverecord.errors.messages\nerrors.attributes.[attribute_name]\nerrors.messages\n\nCopy\n","\nactiverecord.errors.models.user.attributes.name.blank\nactiverecord.errors.models.user.blank\nactiverecord.errors.messages.blank\nerrors.attributes.name.blank\nerrors.messages.blank\n\nactiverecord.errors.models.user.attributes.name.blank\nactiverecord.errors.models.user.blank\nactiverecord.errors.messages.blank\nerrors.attributes.name.blank\nerrors.messages.blank\n\nCopy\n","\nclass Admin < User\n  validates :name, presence: true\nend\n\nclass Admin < User\n  validates :name, presence: true\nend\n\nCopy\n","\nactiverecord.errors.models.admin.attributes.name.blank\nactiverecord.errors.models.admin.blank\nactiverecord.errors.models.user.attributes.name.blank\nactiverecord.errors.models.user.blank\nactiverecord.errors.messages.blank\nerrors.attributes.name.blank\nerrors.messages.blank\n\nactiverecord.errors.models.admin.attributes.name.blank\nactiverecord.errors.models.admin.blank\nactiverecord.errors.models.user.attributes.name.blank\nactiverecord.errors.models.user.blank\nactiverecord.errors.messages.blank\nerrors.attributes.name.blank\nerrors.messages.blank\n\nCopy\n"],"body":"Active Record validation error messages can also be translated easily. Active Record gives you a couple of namespaces where you can place your message translations in order to provide different messages and translation for certain models, attributes, and/or validations. It also transparently takes single table inheritance into account.This gives you quite powerful means to flexibly adjust your messages to your application's needs.Consider a User model with a validation for the name attribute like this:The key for the error message in this case is :blank. Active Record will look up this key in the namespaces:Thus, in our example it will try the following keys in this order and return the first result:When your models are additionally using inheritance then the messages are looked up in the inheritance chain.For example, you might have an Admin model inheriting from User:Then Active Record will look for messages in this order:This way you can provide special translations for various error messages at different points in your model's inheritance chain and in the attributes, models, or default scopes."},{"title":"4.5.2 Error Message Interpolation","anchor":"#error-message-interpolation","code":[],"body":"The translated model name, translated attribute name, and value are always available for interpolation as model, attribute and value respectively.So, for example, instead of the default error message \"cannot be blank\" you could use the attribute name like this : \"Please fill in your %{attribute}\"."},{"code":["\n# user_mailer.rb\nclass UserMailer < ActionMailer::Base\n  def welcome(user)\n    #...\n  end\nend\n\n# user_mailer.rb\nclass UserMailer < ActionMailer::Base\n  def welcome(user)\n    #...\n  end\nend\n\nCopy\n","\nen:\n  user_mailer:\n    welcome:\n      subject: \"Welcome to Rails Guides!\"\n\nen:\n  user_mailer:\n    welcome:\n      subject: \"Welcome to Rails Guides!\"\n\nCopy\n","\n# user_mailer.rb\nclass UserMailer < ActionMailer::Base\n  def welcome(user)\n    mail(to: user.email, subject: default_i18n_subject(user: user.name))\n  end\nend\n\n# user_mailer.rb\nclass UserMailer < ActionMailer::Base\n  def welcome(user)\n    mail(to: user.email, subject: default_i18n_subject(user: user.name))\n  end\nend\n\nCopy\n","\nen:\n  user_mailer:\n    welcome:\n      subject: \"%{user}, welcome to Rails Guides!\"\n\nen:\n  user_mailer:\n    welcome:\n      subject: \"%{user}, welcome to Rails Guides!\"\n\nCopy\n"],"body":"If you don't pass a subject to the mail method, Action Mailer will try to find\nit in your translations. The performed lookup will use the pattern\n<mailer_scope>.<action_name>.subject to construct the key.To send parameters to interpolation use the default_i18n_subject method on the mailer.","title":"4.6 Translations for Action Mailer E-Mail Subjects","anchor":"#translations-for-action-mailer-e-mail-subjects"},{"code":[],"body":"Rails uses fixed strings and other localizations, such as format strings and other format information in a couple of helpers. Here's a brief overview.","title":"4.7 Overview of Other Built-In Methods that Provide I18n Support","anchor":"#overview-of-other-built-in-methods-that-provide-i18n-support"},{"title":"4.7.1 Action View Helper Methods","anchor":"#action-view-helper-methods","code":[],"body":""},{"code":[],"body":"","title":"4.7.2 Active Model Methods","anchor":"#active-model-methods"},{"code":[],"body":"","title":"4.7.3 Active Support Methods","anchor":"#active-support-methods"},{"code":["\n{\n  pt: {\n    foo: {\n      bar: \"baz\"\n    }\n  }\n}\n\n{\n  pt: {\n    foo: {\n      bar: \"baz\"\n    }\n  }\n}\n\nCopy\n","\npt:\n  foo:\n    bar: baz\n\npt:\n  foo:\n    bar: baz\n\nCopy\n","\nen:\n  date:\n    formats:\n      default: \"%Y-%m-%d\"\n      short: \"%b %d\"\n      long: \"%B %d, %Y\"\n\nen:\n  date:\n    formats:\n      default: \"%Y-%m-%d\"\n      short: \"%b %d\"\n      long: \"%B %d, %Y\"\n\nCopy\n","\nI18n.t 'date.formats.short'\nI18n.t 'formats.short', scope: :date\nI18n.t :short, scope: 'date.formats'\nI18n.t :short, scope: [:date, :formats]\n\nI18n.t 'date.formats.short'\nI18n.t 'formats.short', scope: :date\nI18n.t :short, scope: 'date.formats'\nI18n.t :short, scope: [:date, :formats]\n\nCopy\n"],"body":"The Simple backend shipped with Active Support allows you to store translations in both plain Ruby and YAML format.2For example a Ruby Hash providing translations can look like this:The equivalent YAML file would look like this:As you see, in both cases the top level key is the locale. :foo is a namespace key and :bar is the key for the translation \"baz\".Here is a \"real\" example from the Active Support en.yml translations YAML file:So, all of the following equivalent lookups will return the :short date format \"%b %d\":Generally we recommend using YAML as a format for storing translations. There are cases, though, where you want to store Ruby lambdas as part of your locale data, e.g. for special date formats.","title":"5 How to Store your Custom Translations","anchor":"#how-to-store-your-custom-translations"},{"title":"6 Customize your I18n Setup","anchor":"#customize-your-i18n-setup","code":[],"body":""},{"title":"6.1 Using Different Backends","anchor":"#using-different-backends","code":["\nI18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)\n\nI18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)\n\nCopy\n"],"body":"For several reasons the Simple backend shipped with Active Support only does the \"simplest thing that could possibly work\" for Ruby on Rails3 ... which means that it is only guaranteed to work for English and, as a side effect, languages that are very similar to English. Also, the simple backend is only capable of reading translations but cannot dynamically store them to any format.That does not mean you're stuck with these limitations, though. The Ruby I18n gem makes it very easy to exchange the Simple backend implementation with something else that fits better for your needs, by passing a backend instance to the I18n.backend= setter.For example, you can replace the Simple backend with the Chain backend to chain multiple backends together. This is useful when you want to use standard translations with a Simple backend but store custom application translations in a database or other backends.With the Chain backend, you could use the Active Record backend and fall back to the (default) Simple backend:"},{"code":["\nMissingTranslationData       # no translation was found for the requested key\nInvalidLocale                # the locale set to I18n.locale is invalid (e.g. nil)\nInvalidPluralizationData     # a count option was passed but the translation data is not suitable for pluralization\nMissingInterpolationArgument # the translation expects an interpolation argument that has not been passed\nReservedInterpolationKey     # the translation contains a reserved interpolation variable name (i.e. one of: scope, default)\nUnknownFileType              # the backend does not know how to handle a file type that was added to I18n.load_path\n\nMissingTranslationData       # no translation was found for the requested key\nInvalidLocale                # the locale set to I18n.locale is invalid (e.g. nil)\nInvalidPluralizationData     # a count option was passed but the translation data is not suitable for pluralization\nMissingInterpolationArgument # the translation expects an interpolation argument that has not been passed\nReservedInterpolationKey     # the translation contains a reserved interpolation variable name (i.e. one of: scope, default)\nUnknownFileType              # the backend does not know how to handle a file type that was added to I18n.load_path\n\nCopy\n","\nmodule I18n\n  class JustRaiseExceptionHandler < ExceptionHandler\n    def call(exception, locale, key, options)\n      if exception.is_a?(MissingTranslation)\n        raise exception.to_exception\n      else\n        super\n      end\n    end\n  end\nend\n\nI18n.exception_handler = I18n::JustRaiseExceptionHandler.new\n\nmodule I18n\n  class JustRaiseExceptionHandler < ExceptionHandler\n    def call(exception, locale, key, options)\n      if exception.is_a?(MissingTranslation)\n        raise exception.to_exception\n      else\n        super\n      end\n    end\n  end\nend\n\nI18n.exception_handler = I18n::JustRaiseExceptionHandler.new\n\nCopy\n","\nif exception.is_a?(MissingTranslation) && key.to_s != 'i18n.plural.rule'\n  raise exception.to_exception\nelse\n  super\nend\n\nif exception.is_a?(MissingTranslation) && key.to_s != 'i18n.plural.rule'\n  raise exception.to_exception\nelse\n  super\nend\n\nCopy\n","\nI18n.t :foo, raise: true # always re-raises exceptions from the backend\n\nI18n.t :foo, raise: true # always re-raises exceptions from the backend\n\nCopy\n"],"body":"The I18n API defines the following exceptions that will be raised by backends when the corresponding unexpected conditions occur:The I18n API will catch all of these exceptions when they are thrown in the backend and pass them to the default_exception_handler method. This method will re-raise all exceptions except for MissingTranslationData exceptions. When a MissingTranslationData exception has been caught, it will return the exception's error message string containing the missing key/scope.The reason for this is that during development you'd usually want your views to still render even though a translation is missing.In other contexts you might want to change this behavior, though. E.g. the default exception handling does not allow to catch missing translations during automated tests easily. For this purpose a different exception handler can be specified. The specified exception handler must be a method on the I18n module or a class with a call method:This would re-raise only the MissingTranslationData exception, passing all other input to the default exception handler.However, if you are using I18n::Backend::Pluralization this handler will also raise I18n::MissingTranslationData: translation missing: en.i18n.plural.rule exception that should normally be ignored to fall back to the default pluralization rule for English locale. To avoid this you may use an additional check for the translation key:Another example where the default behavior is less desirable is the Rails TranslationHelper which provides the method #t (as well as #translate). When a MissingTranslationData exception occurs in this context, the helper wraps the message into a span with the CSS class translation_missing.To do so, the helper forces I18n#translate to raise exceptions no matter what exception handler is defined by setting the :raise option:","title":"6.2 Using Different Exception Handlers","anchor":"#using-different-exception-handlers"},{"code":[],"body":"The I18n API described in this guide is primarily intended for translating interface strings. If you are looking to translate model content (e.g. blog posts), you will need a different solution to help with this.Several gems can help with this:","title":"7 Translating Model Content","anchor":"#translating-model-content"},{"code":[],"body":"At this point you should have a good overview about how I18n support in Ruby on Rails works and are ready to start translating your project.","title":"8 Conclusion","anchor":"#conclusion"},{"title":"9 Contributing to Rails I18n","anchor":"#contributing-to-rails-i18n","code":[],"body":"I18n support in Ruby on Rails was introduced in the release 2.2 and is still evolving. The project follows the good Ruby on Rails development tradition of evolving solutions in gems and real applications first, and only then cherry-picking the best-of-breed of most widely useful features for inclusion in the core.Thus we encourage everybody to experiment with new ideas and features in gems or other libraries and make them available to the community. (Don't forget to announce your work on our mailing list!)If you find your own locale (language) missing from our example translations data repository for Ruby on Rails, please fork the repository, add your data, and send a pull request."},{"title":"10 Resources","anchor":"#resources","code":[],"body":""},{"code":[],"body":"","title":"11 Authors","anchor":"#authors"},{"code":[],"body":"1 Or, to quote Wikipedia: \"Internationalization is the process of designing a software application so that it can be adapted to various languages and regions without engineering changes. Localization is the process of adapting software for a specific region or language by adding locale-specific components and translating text.\"2 Other backends might allow or require to use other formats, e.g. a GetText backend might allow to read GetText files.3 One of these reasons is that we don't want to imply any unnecessary load for applications that do not need any I18n capabilities, so we need to keep the I18n library as simple as possible for English. Another reason is that it is virtually impossible to implement a one-fits-all solution for all problems related to I18n for all existing languages. So a solution that allows us to exchange the entire implementation easily is appropriate anyway. This also makes it much easier to experiment with custom features and extensions.","title":"12 Footnotes","anchor":"#footnotes"}]