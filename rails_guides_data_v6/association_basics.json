[{"code":["\nclass Author < ApplicationRecord\nend\n\nclass Book < ApplicationRecord\nend\n\nclass Author < ApplicationRecord\nend\n\nclass Book < ApplicationRecord\nend\n\nCopy\n","\n@book = Book.create(published_at: Time.now, author_id: @author.id)\n\n@book = Book.create(published_at: Time.now, author_id: @author.id)\n\nCopy\n","\n@books = Book.where(author_id: @author.id)\n@books.each do |book|\n  book.destroy\nend\n@author.destroy\n\n@books = Book.where(author_id: @author.id)\n@books.each do |book|\n  book.destroy\nend\n@author.destroy\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, dependent: :destroy\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nclass Author < ApplicationRecord\n  has_many :books, dependent: :destroy\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nCopy\n","\n@book = @author.books.create(published_at: Time.now)\n\n@book = @author.books.create(published_at: Time.now)\n\nCopy\n","\n@author.destroy\n\n@author.destroy\n\nCopy\n"],"body":"In Rails, an association is a connection between two Active Record models. Why do we need associations between models? Because they make common operations simpler and easier in your code. For example, consider a simple Rails application that includes a model for authors and a model for books. Each author can have many books. Without associations, the model declarations would look like this:Now, suppose we wanted to add a new book for an existing author. We'd need to do something like this:Or consider deleting an author, and ensuring that all of its books get deleted as well:With Active Record associations, we can streamline these - and other - operations by declaratively telling Rails that there is a connection between the two models. Here's the revised code for setting up authors and books:With this change, creating a new book for a particular author is easier:Deleting an author and all of its books is much easier:To learn more about the different types of associations, read the next section of this guide. That's followed by some tips and tricks for working with associations, and then by a complete reference to the methods and options for associations in Rails.","title":"1 Why Associations?","anchor":"#why-associations-questionmark"},{"title":"2 The Types of Associations","anchor":"#the-types-of-associations","code":[],"body":"Rails supports six types of associations:Associations are implemented using macro-style calls, so that you can declaratively add features to your models. For example, by declaring that one model belongs_to another, you instruct Rails to maintain Primary Key-Foreign Key information between instances of the two models, and you also get a number of utility methods added to your model.In the remainder of this guide, you'll learn how to declare and use the various forms of associations. But first, a quick introduction to the situations where each association type is appropriate."},{"title":"2.1 The belongs_to Association","anchor":"#the-belongs-to-association","code":["\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nCopy\n","\nclass CreateBooks < ActiveRecord::Migration[6.0]\n  def change\n    create_table :authors do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :books do |t|\n      t.belongs_to :author\n      t.datetime :published_at\n      t.timestamps\n    end\n  end\nend\n\nclass CreateBooks < ActiveRecord::Migration[6.0]\n  def change\n    create_table :authors do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :books do |t|\n      t.belongs_to :author\n      t.datetime :published_at\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\ncreate_table :books do |t|\n  t.belongs_to :author, foreign_key: true\n  # ...\nend\n\ncreate_table :books do |t|\n  t.belongs_to :author, foreign_key: true\n  # ...\nend\n\nCopy\n"],"body":"A belongs_to association sets up a connection with another model, such that each instance of the declaring model \"belongs to\" one instance of the other model. For example, if your application includes authors and books, and each book can be assigned to exactly one author, you'd declare the book model this way:The corresponding migration might look like this:When used alone, belongs_to produces a one-directional one-to-one connection. Therefore each book in the above example \"knows\" its author, but the authors don't know about their books.\nTo setup a bi-directional association - use belongs_to in combination with a has_one or has_many on the other model.belongs_to does not ensure reference consistency, so depending on the use case, you might also need to add a database-level foreign key constraint on the reference column, like this:"},{"code":["\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nCopy\n","\nclass CreateSuppliers < ActiveRecord::Migration[6.0]\n  def change\n    create_table :suppliers do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :accounts do |t|\n      t.belongs_to :supplier\n      t.string :account_number\n      t.timestamps\n    end\n  end\nend\n\nclass CreateSuppliers < ActiveRecord::Migration[6.0]\n  def change\n    create_table :suppliers do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :accounts do |t|\n      t.belongs_to :supplier\n      t.string :account_number\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\ncreate_table :accounts do |t|\n  t.belongs_to :supplier, index: { unique: true }, foreign_key: true\n  # ...\nend\n\ncreate_table :accounts do |t|\n  t.belongs_to :supplier, index: { unique: true }, foreign_key: true\n  # ...\nend\n\nCopy\n"],"body":"A has_one association indicates that one other model has a reference to this model. That model can be fetched through this association.For example, if each supplier in your application has only one account, you'd declare the supplier model like this:The main difference from belongs_to is that the link column supplier_id is located in the other table:The corresponding migration might look like this:Depending on the use case, you might also need to create a unique index and/or\na foreign key constraint on the supplier column for the accounts table. In this\ncase, the column definition might look like this:This relation can be bi-directional when used in combination with belongs_to on the other model.","title":"2.2 The has_one Association","anchor":"#the-has-one-association"},{"title":"2.3 The has_many Association","anchor":"#the-has-many-association","code":["\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n","\nclass CreateAuthors < ActiveRecord::Migration[6.0]\n  def change\n    create_table :authors do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :books do |t|\n      t.belongs_to :author\n      t.datetime :published_at\n      t.timestamps\n    end\n  end\nend\n\nclass CreateAuthors < ActiveRecord::Migration[6.0]\n  def change\n    create_table :authors do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :books do |t|\n      t.belongs_to :author\n      t.datetime :published_at\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\ncreate_table :books do |t|\n  t.belongs_to :author, index: true, foreign_key: true\n  # ...\nend\n\ncreate_table :books do |t|\n  t.belongs_to :author, index: true, foreign_key: true\n  # ...\nend\n\nCopy\n"],"body":"A has_many association is similar to has_one, but indicates a one-to-many connection with another model. You'll often find this association on the \"other side\" of a belongs_to association. This association indicates that each instance of the model has zero or more instances of another model. For example, in an application containing authors and books, the author model could be declared like this:The corresponding migration might look like this:Depending on the use case, it's usually a good idea to create a non-unique index and optionally\na foreign key constraint on the author column for the books table:"},{"code":["\nclass Physician < ApplicationRecord\n  has_many :appointments\n  has_many :patients, through: :appointments\nend\n\nclass Appointment < ApplicationRecord\n  belongs_to :physician\n  belongs_to :patient\nend\n\nclass Patient < ApplicationRecord\n  has_many :appointments\n  has_many :physicians, through: :appointments\nend\n\nclass Physician < ApplicationRecord\n  has_many :appointments\n  has_many :patients, through: :appointments\nend\n\nclass Appointment < ApplicationRecord\n  belongs_to :physician\n  belongs_to :patient\nend\n\nclass Patient < ApplicationRecord\n  has_many :appointments\n  has_many :physicians, through: :appointments\nend\n\nCopy\n","\nclass CreateAppointments < ActiveRecord::Migration[6.0]\n  def change\n    create_table :physicians do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :patients do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :appointments do |t|\n      t.belongs_to :physician\n      t.belongs_to :patient\n      t.datetime :appointment_date\n      t.timestamps\n    end\n  end\nend\n\nclass CreateAppointments < ActiveRecord::Migration[6.0]\n  def change\n    create_table :physicians do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :patients do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :appointments do |t|\n      t.belongs_to :physician\n      t.belongs_to :patient\n      t.datetime :appointment_date\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\nphysician.patients = patients\n\nphysician.patients = patients\n\nCopy\n","\nclass Document < ApplicationRecord\n  has_many :sections\n  has_many :paragraphs, through: :sections\nend\n\nclass Section < ApplicationRecord\n  belongs_to :document\n  has_many :paragraphs\nend\n\nclass Paragraph < ApplicationRecord\n  belongs_to :section\nend\n\nclass Document < ApplicationRecord\n  has_many :sections\n  has_many :paragraphs, through: :sections\nend\n\nclass Section < ApplicationRecord\n  belongs_to :document\n  has_many :paragraphs\nend\n\nclass Paragraph < ApplicationRecord\n  belongs_to :section\nend\n\nCopy\n","\n@document.paragraphs\n\n@document.paragraphs\n\nCopy\n"],"body":"A has_many :through association is often used to set up a many-to-many connection with another model. This association indicates that the declaring model can be matched with zero or more instances of another model by proceeding through a third model. For example, consider a medical practice where patients make appointments to see physicians. The relevant association declarations could look like this:The corresponding migration might look like this:The collection of join models can be managed via the has_many association methods.\nFor example, if you assign:Then new join models are automatically created for the newly associated objects.\nIf some that existed previously are now missing, then their join rows are automatically deleted.The has_many :through association is also useful for setting up \"shortcuts\" through nested has_many associations. For example, if a document has many sections, and a section has many paragraphs, you may sometimes want to get a simple collection of all paragraphs in the document. You could set that up this way:With through: :sections specified, Rails will now understand:","title":"2.4 The has_many :through Association","anchor":"#the-has-many-through-association"},{"code":["\nclass Supplier < ApplicationRecord\n  has_one :account\n  has_one :account_history, through: :account\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\n  has_one :account_history\nend\n\nclass AccountHistory < ApplicationRecord\n  belongs_to :account\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account\n  has_one :account_history, through: :account\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\n  has_one :account_history\nend\n\nclass AccountHistory < ApplicationRecord\n  belongs_to :account\nend\n\nCopy\n","\nclass CreateAccountHistories < ActiveRecord::Migration[6.0]\n  def change\n    create_table :suppliers do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :accounts do |t|\n      t.belongs_to :supplier\n      t.string :account_number\n      t.timestamps\n    end\n\n    create_table :account_histories do |t|\n      t.belongs_to :account\n      t.integer :credit_rating\n      t.timestamps\n    end\n  end\nend\n\nclass CreateAccountHistories < ActiveRecord::Migration[6.0]\n  def change\n    create_table :suppliers do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :accounts do |t|\n      t.belongs_to :supplier\n      t.string :account_number\n      t.timestamps\n    end\n\n    create_table :account_histories do |t|\n      t.belongs_to :account\n      t.integer :credit_rating\n      t.timestamps\n    end\n  end\nend\n\nCopy\n"],"body":"A has_one :through association sets up a one-to-one connection with another model. This association indicates\nthat the declaring model can be matched with one instance of another model by proceeding through a third model.\nFor example, if each supplier has one account, and each account is associated with one account history, then the\nsupplier model could look like this:The corresponding migration might look like this:","title":"2.5 The has_one :through Association","anchor":"#the-has-one-through-association"},{"code":["\nclass Assembly < ApplicationRecord\n  has_and_belongs_to_many :parts\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nclass Assembly < ApplicationRecord\n  has_and_belongs_to_many :parts\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nCopy\n","\nclass CreateAssembliesAndParts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :assemblies do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :parts do |t|\n      t.string :part_number\n      t.timestamps\n    end\n\n    create_table :assemblies_parts, id: false do |t|\n      t.belongs_to :assembly\n      t.belongs_to :part\n    end\n  end\nend\n\nclass CreateAssembliesAndParts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :assemblies do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :parts do |t|\n      t.string :part_number\n      t.timestamps\n    end\n\n    create_table :assemblies_parts, id: false do |t|\n      t.belongs_to :assembly\n      t.belongs_to :part\n    end\n  end\nend\n\nCopy\n"],"body":"A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model.\nThis association indicates that each instance of the declaring model refers to zero or more instances of another model.\nFor example, if your application includes assemblies and parts, with each assembly having many parts and each part appearing in many assemblies, you could declare the models this way:The corresponding migration might look like this:","title":"2.6 The has_and_belongs_to_many Association","anchor":"#the-has-and-belongs-to-many-association"},{"code":["\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\nend\n\nCopy\n","\nclass CreateSuppliers < ActiveRecord::Migration[6.0]\n  def change\n    create_table :suppliers do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :accounts do |t|\n      t.bigint  :supplier_id\n      t.string  :account_number\n      t.timestamps\n    end\n\n    add_index :accounts, :supplier_id\n  end\nend\n\nclass CreateSuppliers < ActiveRecord::Migration[6.0]\n  def change\n    create_table :suppliers do |t|\n      t.string :name\n      t.timestamps\n    end\n\n    create_table :accounts do |t|\n      t.bigint  :supplier_id\n      t.string  :account_number\n      t.timestamps\n    end\n\n    add_index :accounts, :supplier_id\n  end\nend\n\nCopy\n"],"body":"If you want to set up a one-to-one relationship between two models, you'll need to add belongs_to to one, and has_one to the other. How do you know which is which?The distinction is in where you place the foreign key (it goes on the table for the class declaring the belongs_to association), but you should give some thought to the actual meaning of the data as well. The has_one relationship says that one of something is yours - that is, that something points back to you. For example, it makes more sense to say that a supplier owns an account than that an account owns a supplier. This suggests that the correct relationships are like this:The corresponding migration might look like this:","title":"2.7 Choosing Between belongs_to and has_one","anchor":"#choosing-between-belongs-to-and-has-one"},{"title":"2.8 Choosing Between has_many :through and has_and_belongs_to_many","anchor":"#choosing-between-has-many-through-and-has-and-belongs-to-many","code":["\nclass Assembly < ApplicationRecord\n  has_and_belongs_to_many :parts\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nclass Assembly < ApplicationRecord\n  has_and_belongs_to_many :parts\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nCopy\n","\nclass Assembly < ApplicationRecord\n  has_many :manifests\n  has_many :parts, through: :manifests\nend\n\nclass Manifest < ApplicationRecord\n  belongs_to :assembly\n  belongs_to :part\nend\n\nclass Part < ApplicationRecord\n  has_many :manifests\n  has_many :assemblies, through: :manifests\nend\n\nclass Assembly < ApplicationRecord\n  has_many :manifests\n  has_many :parts, through: :manifests\nend\n\nclass Manifest < ApplicationRecord\n  belongs_to :assembly\n  belongs_to :part\nend\n\nclass Part < ApplicationRecord\n  has_many :manifests\n  has_many :assemblies, through: :manifests\nend\n\nCopy\n"],"body":"Rails offers two different ways to declare a many-to-many relationship between models. The first way is to use has_and_belongs_to_many, which allows you to make the association directly:The second way to declare a many-to-many relationship is to use has_many :through. This makes the association indirectly, through a join model:The simplest rule of thumb is that you should set up a has_many :through relationship if you need to work with the relationship model as an independent entity. If you don't need to do anything with the relationship model, it may be simpler to set up a has_and_belongs_to_many relationship (though you'll need to remember to create the joining table in the database).You should use has_many :through if you need validations, callbacks, or extra attributes on the join model."},{"title":"2.9 Polymorphic Associations","anchor":"#polymorphic-associations","code":["\nclass Picture < ApplicationRecord\n  belongs_to :imageable, polymorphic: true\nend\n\nclass Employee < ApplicationRecord\n  has_many :pictures, as: :imageable\nend\n\nclass Product < ApplicationRecord\n  has_many :pictures, as: :imageable\nend\n\nclass Picture < ApplicationRecord\n  belongs_to :imageable, polymorphic: true\nend\n\nclass Employee < ApplicationRecord\n  has_many :pictures, as: :imageable\nend\n\nclass Product < ApplicationRecord\n  has_many :pictures, as: :imageable\nend\n\nCopy\n","\nclass CreatePictures < ActiveRecord::Migration[6.0]\n  def change\n    create_table :pictures do |t|\n      t.string  :name\n      t.bigint  :imageable_id\n      t.string  :imageable_type\n      t.timestamps\n    end\n\n    add_index :pictures, [:imageable_type, :imageable_id]\n  end\nend\n\nclass CreatePictures < ActiveRecord::Migration[6.0]\n  def change\n    create_table :pictures do |t|\n      t.string  :name\n      t.bigint  :imageable_id\n      t.string  :imageable_type\n      t.timestamps\n    end\n\n    add_index :pictures, [:imageable_type, :imageable_id]\n  end\nend\n\nCopy\n","\nclass CreatePictures < ActiveRecord::Migration[6.0]\n  def change\n    create_table :pictures do |t|\n      t.string :name\n      t.references :imageable, polymorphic: true\n      t.timestamps\n    end\n  end\nend\n\nclass CreatePictures < ActiveRecord::Migration[6.0]\n  def change\n    create_table :pictures do |t|\n      t.string :name\n      t.references :imageable, polymorphic: true\n      t.timestamps\n    end\n  end\nend\n\nCopy\n"],"body":"A slightly more advanced twist on associations is the polymorphic association. With polymorphic associations, a model can belong to more than one other model, on a single association. For example, you might have a picture model that belongs to either an employee model or a product model. Here's how this could be declared:You can think of a polymorphic belongs_to declaration as setting up an interface that any other model can use. From an instance of the Employee model, you can retrieve a collection of pictures: @employee.pictures.Similarly, you can retrieve @product.pictures.If you have an instance of the Picture model, you can get to its parent via @picture.imageable. To make this work, you need to declare both a foreign key column and a type column in the model that declares the polymorphic interface:This migration can be simplified by using the t.references form:"},{"title":"2.10 Self Joins","anchor":"#self-joins","code":["\nclass Employee < ApplicationRecord\n  has_many :subordinates, class_name: \"Employee\",\n                          foreign_key: \"manager_id\"\n\n  belongs_to :manager, class_name: \"Employee\", optional: true\nend\n\nclass Employee < ApplicationRecord\n  has_many :subordinates, class_name: \"Employee\",\n                          foreign_key: \"manager_id\"\n\n  belongs_to :manager, class_name: \"Employee\", optional: true\nend\n\nCopy\n","\nclass CreateEmployees < ActiveRecord::Migration[6.0]\n  def change\n    create_table :employees do |t|\n      t.references :manager, foreign_key: { to_table: :employees }\n      t.timestamps\n    end\n  end\nend\n\nclass CreateEmployees < ActiveRecord::Migration[6.0]\n  def change\n    create_table :employees do |t|\n      t.references :manager, foreign_key: { to_table: :employees }\n      t.timestamps\n    end\n  end\nend\n\nCopy\n"],"body":"In designing a data model, you will sometimes find a model that should have a relation to itself. For example, you may want to store all employees in a single database model, but be able to trace relationships such as between manager and subordinates. This situation can be modeled with self-joining associations:With this setup, you can retrieve @employee.subordinates and @employee.manager.In your migrations/schema, you will add a references column to the model itself."},{"code":[],"body":"Here are a few things you should know to make efficient use of Active Record associations in your Rails applications:","title":"3 Tips, Tricks, and Warnings","anchor":"#tips-tricks-and-warnings"},{"code":["\n# retrieves books from the database\nauthor.books.load\n\n# uses the cached copy of books\nauthor.books.size\n\n# uses the cached copy of books\nauthor.books.empty?\n\n# retrieves books from the database\nauthor.books.load\n\n# uses the cached copy of books\nauthor.books.size\n\n# uses the cached copy of books\nauthor.books.empty?\n\nCopy\n","\n# retrieves books from the database\nauthor.books.load\n\n# uses the cached copy of books\nauthor.books.size\n\n# discards the cached copy of books and goes back to the database\nauthor.books.reload.empty?\n\n# retrieves books from the database\nauthor.books.load\n\n# uses the cached copy of books\nauthor.books.size\n\n# discards the cached copy of books and goes back to the database\nauthor.books.reload.empty?\n\nCopy\n"],"body":"All of the association methods are built around caching, which keeps the result of the most recent query available for further operations. The cache is even shared across methods. For example:But what if you want to reload the cache, because data might have been changed by some other part of the application? Just call reload on the association:","title":"3.1 Controlling Caching","anchor":"#controlling-caching"},{"code":[],"body":"You are not free to use just any name for your associations. Because creating an association adds a method with that name to the model, it is a bad idea to give an association a name that is already used for an instance method of ActiveRecord::Base. The association method would override the base method and break things. For instance, attributes or connection are bad names for associations.","title":"3.2 Avoiding Name Collisions","anchor":"#avoiding-name-collisions"},{"title":"3.3 Updating the Schema","anchor":"#updating-the-schema","code":[],"body":"Associations are extremely useful, but they are not magic. You are responsible for maintaining your database schema to match your associations. In practice, this means two things, depending on what sort of associations you are creating. For belongs_to associations you need to create foreign keys, and for has_and_belongs_to_many associations you need to create the appropriate join table."},{"title":"3.3.1 Creating Foreign Keys for belongs_to Associations","anchor":"#creating-foreign-keys-for-belongs-to-associations","code":["\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nCopy\n","\nclass CreateBooks < ActiveRecord::Migration[6.0]\n  def change\n    create_table :books do |t|\n      t.datetime   :published_at\n      t.string     :book_number\n      t.references :author\n    end\n  end\nend\n\nclass CreateBooks < ActiveRecord::Migration[6.0]\n  def change\n    create_table :books do |t|\n      t.datetime   :published_at\n      t.string     :book_number\n      t.references :author\n    end\n  end\nend\n\nCopy\n","\nclass AddAuthorToBooks < ActiveRecord::Migration[6.0]\n  def change\n    add_reference :books, :author\n  end\nend\n\nclass AddAuthorToBooks < ActiveRecord::Migration[6.0]\n  def change\n    add_reference :books, :author\n  end\nend\n\nCopy\n"],"body":"When you declare a belongs_to association, you need to create foreign keys as appropriate. For example, consider this model:This declaration needs to be backed up by a corresponding foreign key column in the books table. For a brand new table, the migration might look something like this:Whereas for an existing table, it might look like this:"},{"title":"3.3.2 Creating Join Tables for has_and_belongs_to_many Associations","anchor":"#creating-join-tables-for-has-and-belongs-to-many-associations","code":["\nclass Assembly < ApplicationRecord\n  has_and_belongs_to_many :parts\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nclass Assembly < ApplicationRecord\n  has_and_belongs_to_many :parts\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nCopy\n","\nclass CreateAssembliesPartsJoinTable < ActiveRecord::Migration[6.0]\n  def change\n    create_table :assemblies_parts, id: false do |t|\n      t.bigint :assembly_id\n      t.bigint :part_id\n    end\n\n    add_index :assemblies_parts, :assembly_id\n    add_index :assemblies_parts, :part_id\n  end\nend\n\nclass CreateAssembliesPartsJoinTable < ActiveRecord::Migration[6.0]\n  def change\n    create_table :assemblies_parts, id: false do |t|\n      t.bigint :assembly_id\n      t.bigint :part_id\n    end\n\n    add_index :assemblies_parts, :assembly_id\n    add_index :assemblies_parts, :part_id\n  end\nend\n\nCopy\n","\nclass CreateAssembliesPartsJoinTable < ActiveRecord::Migration[6.0]\n  def change\n    create_join_table :assemblies, :parts do |t|\n      t.index :assembly_id\n      t.index :part_id\n    end\n  end\nend\n\nclass CreateAssembliesPartsJoinTable < ActiveRecord::Migration[6.0]\n  def change\n    create_join_table :assemblies, :parts do |t|\n      t.index :assembly_id\n      t.index :part_id\n    end\n  end\nend\n\nCopy\n"],"body":"If you create a has_and_belongs_to_many association, you need to explicitly create the joining table. Unless the name of the join table is explicitly specified by using the :join_table option, Active Record creates the name by using the lexical order of the class names. So a join between author and book models will give the default join table name of \"authors_books\" because \"a\" outranks \"b\" in lexical ordering.Whatever the name, you must manually generate the join table with an appropriate migration. For example, consider these associations:These need to be backed up by a migration to create the assemblies_parts table. This table should be created without a primary key:We pass id: false to create_table because that table does not represent a model. That's required for the association to work properly. If you observe any strange behavior in a has_and_belongs_to_many association like mangled model IDs, or exceptions about conflicting IDs, chances are you forgot that bit.You can also use the method create_join_table"},{"code":["\nmodule MyApplication\n  module Business\n    class Supplier < ApplicationRecord\n      has_one :account\n    end\n\n    class Account < ApplicationRecord\n      belongs_to :supplier\n    end\n  end\nend\n\nmodule MyApplication\n  module Business\n    class Supplier < ApplicationRecord\n      has_one :account\n    end\n\n    class Account < ApplicationRecord\n      belongs_to :supplier\n    end\n  end\nend\n\nCopy\n","\nmodule MyApplication\n  module Business\n    class Supplier < ApplicationRecord\n      has_one :account\n    end\n  end\n\n  module Billing\n    class Account < ApplicationRecord\n      belongs_to :supplier\n    end\n  end\nend\n\nmodule MyApplication\n  module Business\n    class Supplier < ApplicationRecord\n      has_one :account\n    end\n  end\n\n  module Billing\n    class Account < ApplicationRecord\n      belongs_to :supplier\n    end\n  end\nend\n\nCopy\n","\nmodule MyApplication\n  module Business\n    class Supplier < ApplicationRecord\n      has_one :account,\n        class_name: \"MyApplication::Billing::Account\"\n    end\n  end\n\n  module Billing\n    class Account < ApplicationRecord\n      belongs_to :supplier,\n        class_name: \"MyApplication::Business::Supplier\"\n    end\n  end\nend\n\nmodule MyApplication\n  module Business\n    class Supplier < ApplicationRecord\n      has_one :account,\n        class_name: \"MyApplication::Billing::Account\"\n    end\n  end\n\n  module Billing\n    class Account < ApplicationRecord\n      belongs_to :supplier,\n        class_name: \"MyApplication::Business::Supplier\"\n    end\n  end\nend\n\nCopy\n"],"body":"By default, associations look for objects only within the current module's scope. This can be important when you declare Active Record models within a module. For example:This will work fine, because both the Supplier and the Account class are defined within the same scope. But the following will not work, because Supplier and Account are defined in different scopes:To associate a model with a model in a different namespace, you must specify the complete class name in your association declaration:","title":"3.4 Controlling Association Scope","anchor":"#controlling-association-scope"},{"code":["\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nCopy\n","\nirb> a = Author.first\nirb> b = a.books.first\nirb> a.first_name == b.author.first_name\n=> true\nirb> a.first_name = 'David'\nirb> a.first_name == b.author.first_name\n=> true\n\na = Author.first\nb = a.books.first\na.first_name == b.author.first_name\na.first_name = 'David'\na.first_name == b.author.first_name\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'\nend\n\nCopy\n","\nirb> a = Author.first\nirb> b = a.books.first\nirb> a.first_name == b.writer.first_name\n=> true\nirb> a.first_name = 'David'\nirb> a.first_name == b.writer.first_name\n=> false\n\na = Author.first\nb = a.books.first\na.first_name == b.writer.first_name\na.first_name = 'David'\na.first_name == b.writer.first_name\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, inverse_of: 'writer'\nend\n\nclass Book < ApplicationRecord\n  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'\nend\n\nclass Author < ApplicationRecord\n  has_many :books, inverse_of: 'writer'\nend\n\nclass Book < ApplicationRecord\n  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'\nend\n\nCopy\n","\nirb> a = Author.first\nirb> b = a.books.first\nirb> a.first_name == b.writer.first_name\n=> true\nirb> a.first_name = 'David'\nirb> a.first_name == b.writer.first_name\n=> true\n\na = Author.first\nb = a.books.first\na.first_name == b.writer.first_name\na.first_name = 'David'\na.first_name == b.writer.first_name\n\nCopy\n"],"body":"It's normal for associations to work in two directions, requiring declaration on two different models:Active Record will attempt to automatically identify that these two models share a bi-directional association based on the association name. In this way, Active Record will only load one copy of the Author object, making your application more efficient and preventing inconsistent data:Active Record supports automatic identification for most associations with standard names. However, Active Record will not automatically identify bi-directional associations that contain a scope or any of the following options:For example, consider the following model declarations:Active Record will no longer automatically recognize the bi-directional association:Active Record provides the :inverse_of option so you can explicitly declare bi-directional associations:By including the :inverse_of option in the has_many association declaration, Active Record will now recognize the bi-directional association:","title":"3.5 Bi-directional Associations","anchor":"#bi-directional-associations"},{"code":[],"body":"The following sections give the details of each type of association, including the methods that they add and the options that you can use when declaring an association.","title":"4 Detailed Association Reference","anchor":"#detailed-association-reference"},{"title":"4.1 belongs_to Association Reference","anchor":"#belongs-to-association-reference","code":[],"body":"In database terms, the belongs_to association says that this model's table contains a column which represents a reference to another table.\nThis can be used to set up one-to-one or one-to-many relations, depending on the setup.\nIf the table of the other class contains the reference in a one-to-one relation, then you should use has_one instead."},{"title":"4.1.1 Methods Added by belongs_to","anchor":"#methods-added-by-belongs-to","code":["\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nCopy\n","\nauthor\nauthor=\nbuild_author\ncreate_author\ncreate_author!\nreload_author\n\nauthor\nauthor=\nbuild_author\ncreate_author\ncreate_author!\nreload_author\n\nCopy\n","\n@author = @book.author\n\n@author = @book.author\n\nCopy\n","\n@author = @book.reload_author\n\n@author = @book.reload_author\n\nCopy\n","\n@book.author = @author\n\n@book.author = @author\n\nCopy\n","\n@author = @book.build_author(author_number: 123,\n                             author_name: \"John Doe\")\n\n@author = @book.build_author(author_number: 123,\n                             author_name: \"John Doe\")\n\nCopy\n","\n@author = @book.create_author(author_number: 123,\n                              author_name: \"John Doe\")\n\n@author = @book.create_author(author_number: 123,\n                              author_name: \"John Doe\")\n\nCopy\n"],"body":"When you declare a belongs_to association, the declaring class automatically gains 6 methods related to the association:In all of these methods, association is replaced with the symbol passed as the first argument to belongs_to. For example, given the declaration:Each instance of the Book model will have these methods:The association method returns the associated object, if any. If no associated object is found, it returns nil.If the associated object has already been retrieved from the database for this object, the cached version will be returned. To override this behavior (and force a database read), call #reload_association on the parent object.The association= method assigns an associated object to this object. Behind the scenes, this means extracting the primary key from the associated object and setting this object's foreign key to the same value.The build_association method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through this object's foreign key will be set, but the associated object will not yet be saved.The create_association method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through this object's foreign key will be set, and, once it passes all of the validations specified on the associated model, the associated object will be saved.Does the same as create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid."},{"title":"4.1.2 Options for belongs_to","anchor":"#options-for-belongs-to","code":["\nclass Book < ApplicationRecord\n  belongs_to :author, touch: :books_updated_at,\n    counter_cache: true\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, touch: :books_updated_at,\n    counter_cache: true\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author, class_name: \"Patron\"\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, class_name: \"Patron\"\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author, counter_cache: true\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, counter_cache: true\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author, counter_cache: :count_of_books\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, counter_cache: :count_of_books\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author, class_name: \"Patron\",\n                      foreign_key: \"patron_id\"\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, class_name: \"Patron\",\n                      foreign_key: \"patron_id\"\nend\n\nCopy\n","\nclass User < ApplicationRecord\n  self.primary_key = 'guid' # primary key is guid and not id\nend\n\nclass Todo < ApplicationRecord\n  belongs_to :user, primary_key: 'guid'\nend\n\nclass User < ApplicationRecord\n  self.primary_key = 'guid' # primary key is guid and not id\nend\n\nclass Todo < ApplicationRecord\n  belongs_to :user, primary_key: 'guid'\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, inverse_of: :author\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, inverse_of: :books\nend\n\nclass Author < ApplicationRecord\n  has_many :books, inverse_of: :author\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, inverse_of: :books\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author, touch: true\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, touch: true\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author, touch: :books_updated_at\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, touch: :books_updated_at\nend\n\nCopy\n"],"body":"While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the belongs_to association reference. Such customizations can easily be accomplished by passing options and scope blocks when you create the association. For example, this association uses two such options:The belongs_to association supports these options:If you set the :autosave option to true, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. Setting :autosave to false is not the same as not setting the :autosave option. If the :autosave option is not present, then new associated objects will be saved, but updated associated objects will not be saved.If the name of the other model cannot be derived from the association name, you can use the :class_name option to supply the model name. For example, if a book belongs to an author, but the actual name of the model containing authors is Patron, you'd set things up this way:The :counter_cache option can be used to make finding the number of belonging objects more efficient. Consider these models:With these declarations, asking for the value of @author.books.size requires making a call to the database to perform a COUNT(*) query. To avoid this call, you can add a counter cache to the belonging model:With this declaration, Rails will keep the cache value up to date, and then return that value in response to the size method.Although the :counter_cache option is specified on the model that includes\nthe belongs_to declaration, the actual column must be added to the\nassociated (has_many) model. In the case above, you would need to add a\ncolumn named books_count to the Author model.You can override the default column name by specifying a custom column name in\nthe counter_cache declaration instead of true. For example, to use\ncount_of_books instead of books_count:Counter cache columns are added to the containing model's list of read-only attributes through attr_readonly.If you set the :dependent option to:By convention, Rails assumes that the column used to hold the foreign key on this model is the name of the association with the suffix _id added. The :foreign_key option lets you set the name of the foreign key directly:By convention, Rails assumes that the id column is used to hold the primary key\nof its tables. The :primary_key option allows you to specify a different column.For example, given we have a users table with guid as the primary key. If we want a separate todos table to hold the foreign key user_id in the guid column, then we can use primary_key to achieve this like so:When we execute @user.todos.create then the @todo record will have its\nuser_id value as the guid value of @user.The :inverse_of option specifies the name of the has_many or has_one association that is the inverse of this association.Passing true to the :polymorphic option indicates that this is a polymorphic association. Polymorphic associations were discussed in detail earlier in this guide.If you set the :touch option to true, then the updated_at or updated_on timestamp on the associated object will be set to the current time whenever this object is saved or destroyed:In this case, saving or destroying a book will update the timestamp on the associated author. You can also specify a particular timestamp attribute to update:If you set the :validate option to true, then associated objects will be validated whenever you save this object. By default, this is false: associated objects will not be validated when this object is saved.If you set the :optional option to true, then the presence of the associated\nobject won't be validated. By default, this option is set to false."},{"title":"4.1.3 Scopes for belongs_to","anchor":"#scopes-for-belongs-to","code":["\nclass Book < ApplicationRecord\n  belongs_to :author, -> { where active: true }\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, -> { where active: true }\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :author, -> { where active: true }\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, -> { where active: true }\nend\n\nCopy\n","\nclass Chapter < ApplicationRecord\n  belongs_to :book\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Chapter < ApplicationRecord\n  belongs_to :book\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n","\nclass Chapter < ApplicationRecord\n  belongs_to :book, -> { includes :author }\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Chapter < ApplicationRecord\n  belongs_to :book, -> { includes :author }\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n"],"body":"There may be times when you wish to customize the query used by belongs_to. Such customizations can be achieved via a scope block. For example:You can use any of the standard querying methods inside the scope block. The following ones are discussed below:The where method lets you specify the conditions that the associated object must meet.You can use the includes method to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:If you frequently retrieve authors directly from chapters (@chapter.book.author), then you can make your code somewhat more efficient by including authors in the association from chapters to books:If you use readonly, then the associated object will be read-only when retrieved via the association.The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns."},{"title":"4.1.4 Do Any Associated Objects Exist?","anchor":"#belongs-to-association-reference-do-any-associated-objects-exist-questionmark","code":["\nif @book.author.nil?\n  @msg = \"No author found for this book\"\nend\n\nif @book.author.nil?\n  @msg = \"No author found for this book\"\nend\n\nCopy\n"],"body":"You can see if any associated objects exist by using the association.nil? method:"},{"code":[],"body":"Assigning an object to a belongs_to association does not automatically save the object. It does not save the associated object either.","title":"4.1.5 When are Objects Saved?","anchor":"#belongs-to-association-reference-when-are-objects-saved-questionmark"},{"title":"4.2 has_one Association Reference","anchor":"#has-one-association-reference","code":[],"body":"The has_one association creates a one-to-one match with another model. In database terms, this association says that the other class contains the foreign key. If this class contains the foreign key, then you should use belongs_to instead."},{"title":"4.2.1 Methods Added by has_one","anchor":"#methods-added-by-has-one","code":["\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nCopy\n","\naccount\naccount=\nbuild_account\ncreate_account\ncreate_account!\nreload_account\n\naccount\naccount=\nbuild_account\ncreate_account\ncreate_account!\nreload_account\n\nCopy\n","\n@account = @supplier.account\n\n@account = @supplier.account\n\nCopy\n","\n@account = @supplier.reload_account\n\n@account = @supplier.reload_account\n\nCopy\n","\n@supplier.account = @account\n\n@supplier.account = @account\n\nCopy\n","\n@account = @supplier.build_account(terms: \"Net 30\")\n\n@account = @supplier.build_account(terms: \"Net 30\")\n\nCopy\n","\n@account = @supplier.create_account(terms: \"Net 30\")\n\n@account = @supplier.create_account(terms: \"Net 30\")\n\nCopy\n"],"body":"When you declare a has_one association, the declaring class automatically gains 6 methods related to the association:In all of these methods, association is replaced with the symbol passed as the first argument to has_one. For example, given the declaration:Each instance of the Supplier model will have these methods:The association method returns the associated object, if any. If no associated object is found, it returns nil.If the associated object has already been retrieved from the database for this object, the cached version will be returned. To override this behavior (and force a database read), call #reload_association on the parent object.The association= method assigns an associated object to this object. Behind the scenes, this means extracting the primary key from this object and setting the associated object's foreign key to the same value.The build_association method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through its foreign key will be set, but the associated object will not yet be saved.The create_association method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through its foreign key will be set, and, once it passes all of the validations specified on the associated model, the associated object will be saved.Does the same as create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid."},{"title":"4.2.2 Options for has_one","anchor":"#options-for-has-one","code":["\nclass Supplier < ApplicationRecord\n  has_one :account, class_name: \"Billing\", dependent: :nullify\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, class_name: \"Billing\", dependent: :nullify\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account, class_name: \"Billing\"\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, class_name: \"Billing\"\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account, foreign_key: \"supp_id\"\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, foreign_key: \"supp_id\"\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account, inverse_of: :supplier\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier, inverse_of: :account\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, inverse_of: :supplier\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier, inverse_of: :account\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_one :book\n  has_one :hardback, through: :book, source: :format, source_type: \"Hardback\"\n  has_one :dust_jacket, through: :hardback\nend\n\nclass Book < ApplicationRecord\n  belongs_to :format, polymorphic: true\nend\n\nclass Paperback < ApplicationRecord; end\n\nclass Hardback < ApplicationRecord\n  has_one :dust_jacket\nend\n\nclass DustJacket < ApplicationRecord; end\n\nclass Author < ApplicationRecord\n  has_one :book\n  has_one :hardback, through: :book, source: :format, source_type: \"Hardback\"\n  has_one :dust_jacket, through: :hardback\nend\n\nclass Book < ApplicationRecord\n  belongs_to :format, polymorphic: true\nend\n\nclass Paperback < ApplicationRecord; end\n\nclass Hardback < ApplicationRecord\n  has_one :dust_jacket\nend\n\nclass DustJacket < ApplicationRecord; end\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account, touch: true\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, touch: true\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account, touch: :suppliers_updated_at\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, touch: :suppliers_updated_at\nend\n\nCopy\n"],"body":"While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the has_one association reference. Such customizations can easily be accomplished by passing options when you create the association. For example, this association uses two such options:The has_one association supports these options:Setting the :as option indicates that this is a polymorphic association. Polymorphic associations were discussed in detail earlier in this guide.If you set the :autosave option to true, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. Setting :autosave to false is not the same as not setting the :autosave option. If the :autosave option is not present, then new associated objects will be saved, but updated associated objects will not be saved.If the name of the other model cannot be derived from the association name, you can use the :class_name option to supply the model name. For example, if a supplier has an account, but the actual name of the model containing accounts is Billing, you'd set things up this way:Controls what happens to the associated object when its owner is destroyed:It's necessary not to set or leave :nullify option for those associations\nthat have NOT NULL database constraints. If you don't set dependent to\ndestroy such associations you won't be able to change the associated object\nbecause the initial associated object's foreign key will be set to the\nunallowed NULL value.By convention, Rails assumes that the column used to hold the foreign key on the other model is the name of this model with the suffix _id added. The :foreign_key option lets you set the name of the foreign key directly:The :inverse_of option specifies the name of the belongs_to association that is the inverse of this association.By convention, Rails assumes that the column used to hold the primary key of this model is id. You can override this and explicitly specify the primary key with the :primary_key option.The :source option specifies the source association name for a has_one :through association.The :source_type option specifies the source association type for a has_one :through association that proceeds through a polymorphic association.The :through option specifies a join model through which to perform the query. has_one :through associations were discussed in detail earlier in this guide.If you set the :touch option to true, then the updated_at or updated_on timestamp on the associated object will be set to the current time whenever this object is saved or destroyed:In this case, saving or destroying a supplier will update the timestamp on the associated account. You can also specify a particular timestamp attribute to update:If you set the :validate option to true, then associated objects will be validated whenever you save this object. By default, this is false: associated objects will not be validated when this object is saved."},{"title":"4.2.3 Scopes for has_one","anchor":"#scopes-for-has-one","code":["\nclass Supplier < ApplicationRecord\n  has_one :account, -> { where active: true }\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, -> { where active: true }\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account, -> { where \"confirmed = 1\" }\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, -> { where \"confirmed = 1\" }\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\n  belongs_to :representative\nend\n\nclass Representative < ApplicationRecord\n  has_many :accounts\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\n  belongs_to :representative\nend\n\nclass Representative < ApplicationRecord\n  has_many :accounts\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_one :account, -> { includes :representative }\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\n  belongs_to :representative\nend\n\nclass Representative < ApplicationRecord\n  has_many :accounts\nend\n\nclass Supplier < ApplicationRecord\n  has_one :account, -> { includes :representative }\nend\n\nclass Account < ApplicationRecord\n  belongs_to :supplier\n  belongs_to :representative\nend\n\nclass Representative < ApplicationRecord\n  has_many :accounts\nend\n\nCopy\n"],"body":"There may be times when you wish to customize the query used by has_one. Such customizations can be achieved via a scope block. For example:You can use any of the standard querying methods inside the scope block. The following ones are discussed below:The where method lets you specify the conditions that the associated object must meet.You can use the includes method to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:If you frequently retrieve representatives directly from suppliers (@supplier.account.representative), then you can make your code somewhat more efficient by including representatives in the association from suppliers to accounts:If you use the readonly method, then the associated object will be read-only when retrieved via the association.The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns."},{"title":"4.2.4 Do Any Associated Objects Exist?","anchor":"#has-one-association-reference-do-any-associated-objects-exist-questionmark","code":["\nif @supplier.account.nil?\n  @msg = \"No account found for this supplier\"\nend\n\nif @supplier.account.nil?\n  @msg = \"No account found for this supplier\"\nend\n\nCopy\n"],"body":"You can see if any associated objects exist by using the association.nil? method:"},{"code":[],"body":"When you assign an object to a has_one association, that object is automatically saved (in order to update its foreign key). In addition, any object being replaced is also automatically saved, because its foreign key will change too.If either of these saves fails due to validation errors, then the assignment statement returns false and the assignment itself is cancelled.If the parent object (the one declaring the has_one association) is unsaved (that is, new_record? returns true) then the child objects are not saved. They will automatically when the parent object is saved.If you want to assign an object to a has_one association without saving the object, use the build_association method.","title":"4.2.5 When are Objects Saved?","anchor":"#has-one-association-reference-when-are-objects-saved-questionmark"},{"title":"4.3 has_many Association Reference","anchor":"#has-many-association-reference","code":[],"body":"The has_many association creates a one-to-many relationship with another model. In database terms, this association says that the other class will have a foreign key that refers to instances of this class."},{"title":"4.3.1 Methods Added by has_many","anchor":"#methods-added-by-has-many","code":["\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nCopy\n","\nbooks\nbooks<<(object, ...)\nbooks.delete(object, ...)\nbooks.destroy(object, ...)\nbooks=(objects)\nbook_ids\nbook_ids=(ids)\nbooks.clear\nbooks.empty?\nbooks.size\nbooks.find(...)\nbooks.where(...)\nbooks.exists?(...)\nbooks.build(attributes = {}, ...)\nbooks.create(attributes = {})\nbooks.create!(attributes = {})\nbooks.reload\n\nbooks\nbooks<<(object, ...)\nbooks.delete(object, ...)\nbooks.destroy(object, ...)\nbooks=(objects)\nbook_ids\nbook_ids=(ids)\nbooks.clear\nbooks.empty?\nbooks.size\nbooks.find(...)\nbooks.where(...)\nbooks.exists?(...)\nbooks.build(attributes = {}, ...)\nbooks.create(attributes = {})\nbooks.create!(attributes = {})\nbooks.reload\n\nCopy\n","\n@books = @author.books\n\n@books = @author.books\n\nCopy\n","\n@author.books << @book1\n\n@author.books << @book1\n\nCopy\n","\n@author.books.delete(@book1)\n\n@author.books.delete(@book1)\n\nCopy\n","\n@author.books.destroy(@book1)\n\n@author.books.destroy(@book1)\n\nCopy\n","\n@book_ids = @author.book_ids\n\n@book_ids = @author.book_ids\n\nCopy\n","\n@author.books.clear\n\n@author.books.clear\n\nCopy\n","\n<% if @author.books.empty? %>\n  No Books Found\n<% end %>\n\n<% if @author.books.empty? %>\n  No Books Found\n<% end %>\n\nCopy\n","\n@book_count = @author.books.size\n\n@book_count = @author.books.size\n\nCopy\n","\n@available_book = @author.books.find(1)\n\n@available_book = @author.books.find(1)\n\nCopy\n","\n@available_books = @author.books.where(available: true) # No query yet\n@available_book = @available_books.first # Now the database will be queried\n\n@available_books = @author.books.where(available: true) # No query yet\n@available_book = @available_books.first # Now the database will be queried\n\nCopy\n","\n@book = @author.books.build(published_at: Time.now,\n                            book_number: \"A12345\")\n\n@books = @author.books.build([\n  { published_at: Time.now, book_number: \"A12346\" },\n  { published_at: Time.now, book_number: \"A12347\" }\n])\n\n@book = @author.books.build(published_at: Time.now,\n                            book_number: \"A12345\")\n\n@books = @author.books.build([\n  { published_at: Time.now, book_number: \"A12346\" },\n  { published_at: Time.now, book_number: \"A12347\" }\n])\n\nCopy\n","\n@book = @author.books.create(published_at: Time.now,\n                             book_number: \"A12345\")\n\n@books = @author.books.create([\n  { published_at: Time.now, book_number: \"A12346\" },\n  { published_at: Time.now, book_number: \"A12347\" }\n])\n\n@book = @author.books.create(published_at: Time.now,\n                             book_number: \"A12345\")\n\n@books = @author.books.create([\n  { published_at: Time.now, book_number: \"A12346\" },\n  { published_at: Time.now, book_number: \"A12347\" }\n])\n\nCopy\n","\n@books = @author.books.reload\n\n@books = @author.books.reload\n\nCopy\n"],"body":"When you declare a has_many association, the declaring class automatically gains 17 methods related to the association:In all of these methods, collection is replaced with the symbol passed as the first argument to has_many, and collection_singular is replaced with the singularized version of that symbol. For example, given the declaration:Each instance of the Author model will have these methods:The collection method returns a Relation of all of the associated objects. If there are no associated objects, it returns an empty Relation.The collection<< method adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model.The collection.delete method removes one or more objects from the collection by setting their foreign keys to NULL.The collection.destroy method removes one or more objects from the collection by running destroy on each object.The collection= method makes the collection contain only the supplied objects, by adding and deleting as appropriate. The changes are persisted to the database.The collection_singular_ids method returns an array of the ids of the objects in the collection.The collection_singular_ids= method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate. The changes are persisted to the database.The collection.clear method removes all objects from the collection according to the strategy specified by the dependent option. If no option is given, it follows the default strategy. The default strategy for has_many :through associations is delete_all, and for has_many associations is to set the foreign keys to NULL.The collection.empty? method returns true if the collection does not contain any associated objects.The collection.size method returns the number of objects in the collection.The collection.find method finds objects within the collection's table.The collection.where method finds objects within the collection based on the conditions supplied but the objects are loaded lazily meaning that the database is queried only when the object(s) are accessed.The collection.exists? method checks whether an object meeting the supplied\nconditions exists in the collection's table.The collection.build method returns a single or array of new objects of the associated type. The object(s) will be instantiated from the passed attributes, and the link through their foreign key will be created, but the associated objects will not yet be saved.The collection.create method returns a single or array of new objects of the associated type. The object(s) will be instantiated from the passed attributes, the link through its foreign key will be created, and, once it passes all of the validations specified on the associated model, the associated object will be saved.Does the same as collection.create above, but raises ActiveRecord::RecordInvalid if the record is invalid.The collection.reload method returns a Relation of all of the associated objects, forcing a database read. If there are no associated objects, it returns an empty Relation."},{"code":["\nclass Author < ApplicationRecord\n  has_many :books, dependent: :delete_all, validate: false\nend\n\nclass Author < ApplicationRecord\n  has_many :books, dependent: :delete_all, validate: false\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, class_name: \"Transaction\"\nend\n\nclass Author < ApplicationRecord\n  has_many :books, class_name: \"Transaction\"\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, foreign_key: \"cust_id\"\nend\n\nclass Author < ApplicationRecord\n  has_many :books, foreign_key: \"cust_id\"\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, inverse_of: :author\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, inverse_of: :books\nend\n\nclass Author < ApplicationRecord\n  has_many :books, inverse_of: :author\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author, inverse_of: :books\nend\n\nCopy\n","\nclass User < ApplicationRecord\n  has_many :todos, primary_key: :guid\nend\n\nclass User < ApplicationRecord\n  has_many :todos, primary_key: :guid\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books\n  has_many :paperbacks, through: :books, source: :format, source_type: \"Paperback\"\nend\n\nclass Book < ApplicationRecord\n  belongs_to :format, polymorphic: true\nend\n\nclass Hardback < ApplicationRecord; end\nclass Paperback < ApplicationRecord; end\n\nclass Author < ApplicationRecord\n  has_many :books\n  has_many :paperbacks, through: :books, source: :format, source_type: \"Paperback\"\nend\n\nclass Book < ApplicationRecord\n  belongs_to :format, polymorphic: true\nend\n\nclass Hardback < ApplicationRecord; end\nclass Paperback < ApplicationRecord; end\n\nCopy\n"],"body":"While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the has_many association reference. Such customizations can easily be accomplished by passing options when you create the association. For example, this association uses two such options:The has_many association supports these options:Setting the :as option indicates that this is a polymorphic association, as discussed earlier in this guide.If you set the :autosave option to true, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. Setting :autosave to false is not the same as not setting the :autosave option. If the :autosave option is not present, then new associated objects will be saved, but updated associated objects will not be saved.If the name of the other model cannot be derived from the association name, you can use the :class_name option to supply the model name. For example, if an author has many books, but the actual name of the model containing books is Transaction, you'd set things up this way:This option can be used to configure a custom named :counter_cache. You only need this option when you customized the name of your :counter_cache on the belongs_to association.Controls what happens to the associated objects when their owner is destroyed:The :destroy and :delete_all options also affect the semantics of the collection.delete and collection= methods by causing them to destroy associated objects when they are removed from the collection.By convention, Rails assumes that the column used to hold the foreign key on the other model is the name of this model with the suffix _id added. The :foreign_key option lets you set the name of the foreign key directly:The :inverse_of option specifies the name of the belongs_to association that is the inverse of this association.By convention, Rails assumes that the column used to hold the primary key of the association is id. You can override this and explicitly specify the primary key with the :primary_key option.Let's say the users table has id as the primary_key but it also\nhas a guid column. The requirement is that the todos table should\nhold the guid column value as the foreign key and not id\nvalue. This can be achieved like this:Now if we execute @todo = @user.todos.create then the @todo\nrecord's user_id value will be the guid value of @user.The :source option specifies the source association name for a has_many :through association. You only need to use this option if the name of the source association cannot be automatically inferred from the association name.The :source_type option specifies the source association type for a has_many :through association that proceeds through a polymorphic association.The :through option specifies a join model through which to perform the query. has_many :through associations provide a way to implement many-to-many relationships, as discussed earlier in this guide.If you set the :validate option to false, then associated objects will not be validated whenever you save this object. By default, this is true: associated objects will be validated when this object is saved.","title":"4.3.2 Options for has_many","anchor":"#options-for-has-many"},{"title":"4.3.3 Scopes for has_many","anchor":"#scopes-for-has-many","code":["\nclass Author < ApplicationRecord\n  has_many :books, -> { where processed: true }\nend\n\nclass Author < ApplicationRecord\n  has_many :books, -> { where processed: true }\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :confirmed_books, -> { where \"confirmed = 1\" },\n    class_name: \"Book\"\nend\n\nclass Author < ApplicationRecord\n  has_many :confirmed_books, -> { where \"confirmed = 1\" },\n    class_name: \"Book\"\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :confirmed_books, -> { where confirmed: true },\n    class_name: \"Book\"\nend\n\nclass Author < ApplicationRecord\n  has_many :confirmed_books, -> { where confirmed: true },\n    class_name: \"Book\"\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :chapters, -> { group 'books.id' },\n                      through: :books\nend\n\nclass Author < ApplicationRecord\n  has_many :chapters, -> { group 'books.id' },\n                      through: :books\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Chapter < ApplicationRecord\n  belongs_to :book\nend\n\nclass Author < ApplicationRecord\n  has_many :books\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Chapter < ApplicationRecord\n  belongs_to :book\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, -> { includes :chapters }\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Chapter < ApplicationRecord\n  belongs_to :book\nend\n\nclass Author < ApplicationRecord\n  has_many :books, -> { includes :chapters }\nend\n\nclass Book < ApplicationRecord\n  belongs_to :author\n  has_many :chapters\nend\n\nclass Chapter < ApplicationRecord\n  belongs_to :book\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :recent_books,\n    -> { order('published_at desc').limit(100) },\n    class_name: \"Book\"\nend\n\nclass Author < ApplicationRecord\n  has_many :recent_books,\n    -> { order('published_at desc').limit(100) },\n    class_name: \"Book\"\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books, -> { order \"date_confirmed DESC\" }\nend\n\nclass Author < ApplicationRecord\n  has_many :books, -> { order \"date_confirmed DESC\" }\nend\n\nCopy\n","\nclass Person < ApplicationRecord\n  has_many :readings\n  has_many :articles, through: :readings\nend\n\nclass Person < ApplicationRecord\n  has_many :readings\n  has_many :articles, through: :readings\nend\n\nCopy\n","\nirb> person = Person.create(name: 'John')\nirb> article = Article.create(name: 'a1')\nirb> person.articles << article\nirb> person.articles << article\nirb> person.articles.to_a\n=> [#<Article id: 5, name: \"a1\">, #<Article id: 5, name: \"a1\">]\nirb> Reading.all.to_a\n=> [#<Reading id: 12, person_id: 5, article_id: 5>, #<Reading id: 13, person_id: 5, article_id: 5>]\n\nperson = Person.create(name: 'John')\narticle = Article.create(name: 'a1')\nperson.articles << article\nperson.articles << article\nperson.articles.to_a\nReading.all.to_a\n\nCopy\n","\nclass Person\n  has_many :readings\n  has_many :articles, -> { distinct }, through: :readings\nend\n\nclass Person\n  has_many :readings\n  has_many :articles, -> { distinct }, through: :readings\nend\n\nCopy\n","\nirb> person = Person.create(name: 'Honda')\nirb> article = Article.create(name: 'a1')\nirb> person.articles << article\nirb> person.articles << article\nirb> person.articles.to_a\n=> [#<Article id: 7, name: \"a1\">]\nirb> Reading.all.to_a\n=> [#<Reading id: 16, person_id: 7, article_id: 7>, #<Reading id: 17, person_id: 7, article_id: 7>]\n\nperson = Person.create(name: 'Honda')\narticle = Article.create(name: 'a1')\nperson.articles << article\nperson.articles << article\nperson.articles.to_a\nReading.all.to_a\n\nCopy\n","\nadd_index :readings, [:person_id, :article_id], unique: true\n\nadd_index :readings, [:person_id, :article_id], unique: true\n\nCopy\n","\nirb> person = Person.create(name: 'Honda')\nirb> article = Article.create(name: 'a1')\nirb> person.articles << article\nirb> person.articles << article\nActiveRecord::RecordNotUnique\n\nperson = Person.create(name: 'Honda')\narticle = Article.create(name: 'a1')\nperson.articles << article\nperson.articles << article\n\nCopy\n","\nperson.articles << article unless person.articles.include?(article)\n\nperson.articles << article unless person.articles.include?(article)\n\nCopy\n"],"body":"There may be times when you wish to customize the query used by has_many. Such customizations can be achieved via a scope block. For example:You can use any of the standard querying methods inside the scope block. The following ones are discussed below:The where method lets you specify the conditions that the associated object must meet.You can also set conditions via a hash:If you use a hash-style where option, then record creation via this association will be automatically scoped using the hash. In this case, using @author.confirmed_books.create or @author.confirmed_books.build will create books where the confirmed column has the value true.The extending method specifies a named module to extend the association proxy. Association extensions are discussed in detail later in this guide.The group method supplies an attribute name to group the result set by, using a GROUP BY clause in the finder SQL.You can use the includes method to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:If you frequently retrieve chapters directly from authors (@author.books.chapters), then you can make your code somewhat more efficient by including chapters in the association from authors to books:The limit method lets you restrict the total number of objects that will be fetched through an association.The offset method lets you specify the starting offset for fetching objects via an association. For example, -> { offset(11) } will skip the first 11 records.The order method dictates the order in which associated objects will be received (in the syntax used by an SQL ORDER BY clause).If you use the readonly method, then the associated objects will be read-only when retrieved via the association.The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated objects. By default, Rails retrieves all columns.Use the distinct method to keep the collection free of duplicates. This is\nmostly useful together with the :through option.In the above case there are two readings and person.articles brings out both of\nthem even though these records are pointing to the same article.Now let's set distinct:In the above case there are still two readings. However person.articles shows\nonly one article because the collection loads only unique records.If you want to make sure that, upon insertion, all of the records in the\npersisted association are distinct (so that you can be sure that when you\ninspect the association that you will never find duplicate records), you should\nadd a unique index on the table itself. For example, if you have a table named\nreadings and you want to make sure the articles can only be added to a person once,\nyou could add the following in a migration:Once you have this unique index, attempting to add the article to a person twice\nwill raise an ActiveRecord::RecordNotUnique error:Note that checking for uniqueness using something like include? is subject\nto race conditions. Do not attempt to use include? to enforce distinctness\nin an association. For instance, using the article example from above, the\nfollowing code would be racy because multiple users could be attempting this\nat the same time:"},{"code":[],"body":"When you assign an object to a has_many association, that object is automatically saved (in order to update its foreign key). If you assign multiple objects in one statement, then they are all saved.If any of these saves fails due to validation errors, then the assignment statement returns false and the assignment itself is cancelled.If the parent object (the one declaring the has_many association) is unsaved (that is, new_record? returns true) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.If you want to assign an object to a has_many association without saving the object, use the collection.build method.","title":"4.3.4 When are Objects Saved?","anchor":"#has-many-association-reference-when-are-objects-saved-questionmark"},{"title":"4.4 has_and_belongs_to_many Association Reference","anchor":"#has-and-belongs-to-many-association-reference","code":[],"body":"The has_and_belongs_to_many association creates a many-to-many relationship with another model. In database terms, this associates two classes via an intermediate join table that includes foreign keys referring to each of the classes."},{"title":"4.4.1 Methods Added by has_and_belongs_to_many","anchor":"#methods-added-by-has-and-belongs-to-many","code":["\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nclass Part < ApplicationRecord\n  has_and_belongs_to_many :assemblies\nend\n\nCopy\n","\nassemblies\nassemblies<<(object, ...)\nassemblies.delete(object, ...)\nassemblies.destroy(object, ...)\nassemblies=(objects)\nassembly_ids\nassembly_ids=(ids)\nassemblies.clear\nassemblies.empty?\nassemblies.size\nassemblies.find(...)\nassemblies.where(...)\nassemblies.exists?(...)\nassemblies.build(attributes = {}, ...)\nassemblies.create(attributes = {})\nassemblies.create!(attributes = {})\nassemblies.reload\n\nassemblies\nassemblies<<(object, ...)\nassemblies.delete(object, ...)\nassemblies.destroy(object, ...)\nassemblies=(objects)\nassembly_ids\nassembly_ids=(ids)\nassemblies.clear\nassemblies.empty?\nassemblies.size\nassemblies.find(...)\nassemblies.where(...)\nassemblies.exists?(...)\nassemblies.build(attributes = {}, ...)\nassemblies.create(attributes = {})\nassemblies.create!(attributes = {})\nassemblies.reload\n\nCopy\n","\n@assemblies = @part.assemblies\n\n@assemblies = @part.assemblies\n\nCopy\n","\n@part.assemblies << @assembly1\n\n@part.assemblies << @assembly1\n\nCopy\n","\n@part.assemblies.delete(@assembly1)\n\n@part.assemblies.delete(@assembly1)\n\nCopy\n","\n@part.assemblies.destroy(@assembly1)\n\n@part.assemblies.destroy(@assembly1)\n\nCopy\n","\n@assembly_ids = @part.assembly_ids\n\n@assembly_ids = @part.assembly_ids\n\nCopy\n","\n<% if @part.assemblies.empty? %>\n  This part is not used in any assemblies\n<% end %>\n\n<% if @part.assemblies.empty? %>\n  This part is not used in any assemblies\n<% end %>\n\nCopy\n","\n@assembly_count = @part.assemblies.size\n\n@assembly_count = @part.assemblies.size\n\nCopy\n","\n@assembly = @part.assemblies.find(1)\n\n@assembly = @part.assemblies.find(1)\n\nCopy\n","\n@new_assemblies = @part.assemblies.where(\"created_at > ?\", 2.days.ago)\n\n@new_assemblies = @part.assemblies.where(\"created_at > ?\", 2.days.ago)\n\nCopy\n","\n@assembly = @part.assemblies.build({assembly_name: \"Transmission housing\"})\n\n@assembly = @part.assemblies.build({assembly_name: \"Transmission housing\"})\n\nCopy\n","\n@assembly = @part.assemblies.create({assembly_name: \"Transmission housing\"})\n\n@assembly = @part.assemblies.create({assembly_name: \"Transmission housing\"})\n\nCopy\n","\n@assemblies = @part.assemblies.reload\n\n@assemblies = @part.assemblies.reload\n\nCopy\n"],"body":"When you declare a has_and_belongs_to_many association, the declaring class automatically gains several methods related to the association:In all of these methods, collection is replaced with the symbol passed as the first argument to has_and_belongs_to_many, and collection_singular is replaced with the singularized version of that symbol. For example, given the declaration:Each instance of the Part model will have these methods:If the join table for a has_and_belongs_to_many association has additional columns beyond the two foreign keys, these columns will be added as attributes to records retrieved via that association. Records returned with additional attributes will always be read-only, because Rails cannot save changes to those attributes.The collection method returns a Relation of all of the associated objects. If there are no associated objects, it returns an empty Relation.The collection<< method adds one or more objects to the collection by creating records in the join table.The collection.delete method removes one or more objects from the collection by deleting records in the join table. This does not destroy the objects.The collection.destroy method removes one or more objects from the collection by deleting records in the join table. This does not destroy the objects.The collection= method makes the collection contain only the supplied objects, by adding and deleting as appropriate. The changes are persisted to the database.The collection_singular_ids method returns an array of the ids of the objects in the collection.The collection_singular_ids= method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate. The changes are persisted to the database.The collection.clear method removes every object from the collection by deleting the rows from the joining table. This does not destroy the associated objects.The collection.empty? method returns true if the collection does not contain any associated objects.The collection.size method returns the number of objects in the collection.The collection.find method finds objects within the collection's table.The collection.where method finds objects within the collection based on the conditions supplied but the objects are loaded lazily meaning that the database is queried only when the object(s) are accessed.The collection.exists? method checks whether an object meeting the supplied\nconditions exists in the collection's table.The collection.build method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through the join table will be created, but the associated object will not yet be saved.The collection.create method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through the join table will be created, and, once it passes all of the validations specified on the associated model, the associated object will be saved.Does the same as collection.create, but raises ActiveRecord::RecordInvalid if the record is invalid.The collection.reload method returns a Relation of all of the associated objects, forcing a database read. If there are no associated objects, it returns an empty Relation."},{"code":["\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, -> { readonly },\n                                       autosave: true\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, -> { readonly },\n                                       autosave: true\nend\n\nCopy\n","\nclass User < ApplicationRecord\n  has_and_belongs_to_many :friends,\n      class_name: \"User\",\n      foreign_key: \"this_user_id\",\n      association_foreign_key: \"other_user_id\"\nend\n\nclass User < ApplicationRecord\n  has_and_belongs_to_many :friends,\n      class_name: \"User\",\n      foreign_key: \"this_user_id\",\n      association_foreign_key: \"other_user_id\"\nend\n\nCopy\n","\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, class_name: \"Gadget\"\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, class_name: \"Gadget\"\nend\n\nCopy\n","\nclass User < ApplicationRecord\n  has_and_belongs_to_many :friends,\n      class_name: \"User\",\n      foreign_key: \"this_user_id\",\n      association_foreign_key: \"other_user_id\"\nend\n\nclass User < ApplicationRecord\n  has_and_belongs_to_many :friends,\n      class_name: \"User\",\n      foreign_key: \"this_user_id\",\n      association_foreign_key: \"other_user_id\"\nend\n\nCopy\n"],"body":"While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the has_and_belongs_to_many association reference. Such customizations can easily be accomplished by passing options when you create the association. For example, this association uses two such options:The has_and_belongs_to_many association supports these options:By convention, Rails assumes that the column in the join table used to hold the foreign key pointing to the other model is the name of that model with the suffix _id added. The :association_foreign_key option lets you set the name of the foreign key directly:If you set the :autosave option to true, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. Setting :autosave to false is not the same as not setting the :autosave option. If the :autosave option is not present, then new associated objects will be saved, but updated associated objects will not be saved.If the name of the other model cannot be derived from the association name, you can use the :class_name option to supply the model name. For example, if a part has many assemblies, but the actual name of the model containing assemblies is Gadget, you'd set things up this way:By convention, Rails assumes that the column in the join table used to hold the foreign key pointing to this model is the name of this model with the suffix _id added. The :foreign_key option lets you set the name of the foreign key directly:If the default name of the join table, based on lexical ordering, is not what you want, you can use the :join_table option to override the default.If you set the :validate option to false, then associated objects will not be validated whenever you save this object. By default, this is true: associated objects will be validated when this object is saved.","title":"4.4.2 Options for has_and_belongs_to_many","anchor":"#options-for-has-and-belongs-to-many"},{"title":"4.4.3 Scopes for has_and_belongs_to_many","anchor":"#scopes-for-has-and-belongs-to-many","code":["\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, -> { where active: true }\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, -> { where active: true }\nend\n\nCopy\n","\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { where \"factory = 'Seattle'\" }\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { where \"factory = 'Seattle'\" }\nend\n\nCopy\n","\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { where factory: 'Seattle' }\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { where factory: 'Seattle' }\nend\n\nCopy\n","\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, -> { group \"factory\" }\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies, -> { group \"factory\" }\nend\n\nCopy\n","\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { order(\"created_at DESC\").limit(50) }\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { order(\"created_at DESC\").limit(50) }\nend\n\nCopy\n","\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { order \"assembly_name ASC\" }\nend\n\nclass Parts < ApplicationRecord\n  has_and_belongs_to_many :assemblies,\n    -> { order \"assembly_name ASC\" }\nend\n\nCopy\n"],"body":"There may be times when you wish to customize the query used by has_and_belongs_to_many. Such customizations can be achieved via a scope block. For example:You can use any of the standard querying methods inside the scope block. The following ones are discussed below:The where method lets you specify the conditions that the associated object must meet.You can also set conditions via a hash:If you use a hash-style where, then record creation via this association will be automatically scoped using the hash. In this case, using @parts.assemblies.create or @parts.assemblies.build will create orders where the factory column has the value \"Seattle\".The extending method specifies a named module to extend the association proxy. Association extensions are discussed in detail later in this guide.The group method supplies an attribute name to group the result set by, using a GROUP BY clause in the finder SQL.You can use the includes method to specify second-order associations that should be eager-loaded when this association is used.The limit method lets you restrict the total number of objects that will be fetched through an association.The offset method lets you specify the starting offset for fetching objects via an association. For example, if you set offset(11), it will skip the first 11 records.The order method dictates the order in which associated objects will be received (in the syntax used by an SQL ORDER BY clause).If you use the readonly method, then the associated objects will be read-only when retrieved via the association.The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated objects. By default, Rails retrieves all columns.Use the distinct method to remove duplicates from the collection."},{"title":"4.4.4 When are Objects Saved?","anchor":"#has-and-belongs-to-many-association-reference-when-are-objects-saved-questionmark","code":[],"body":"When you assign an object to a has_and_belongs_to_many association, that object is automatically saved (in order to update the join table). If you assign multiple objects in one statement, then they are all saved.If any of these saves fails due to validation errors, then the assignment statement returns false and the assignment itself is cancelled.If the parent object (the one declaring the has_and_belongs_to_many association) is unsaved (that is, new_record? returns true) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.If you want to assign an object to a has_and_belongs_to_many association without saving the object, use the collection.build method."},{"title":"4.5 Association Callbacks","anchor":"#association-callbacks","code":["\nclass Author < ApplicationRecord\n  has_many :books, before_add: :check_credit_limit\n\n  def check_credit_limit(book)\n    # ...\n  end\nend\n\nclass Author < ApplicationRecord\n  has_many :books, before_add: :check_credit_limit\n\n  def check_credit_limit(book)\n    # ...\n  end\nend\n\nCopy\n","\nclass Author < ApplicationRecord\n  has_many :books,\n    before_add: [:check_credit_limit, :calculate_shipping_charges]\n\n  def check_credit_limit(book)\n    # ...\n  end\n\n  def calculate_shipping_charges(book)\n    # ...\n  end\nend\n\nclass Author < ApplicationRecord\n  has_many :books,\n    before_add: [:check_credit_limit, :calculate_shipping_charges]\n\n  def check_credit_limit(book)\n    # ...\n  end\n\n  def calculate_shipping_charges(book)\n    # ...\n  end\nend\n\nCopy\n","\n# book won't be added if the limit has been reached\ndef check_credit_limit(book)\n  throw(:abort) if limit_reached?\nend\n\n# book won't be added if the limit has been reached\ndef check_credit_limit(book)\n  throw(:abort) if limit_reached?\nend\n\nCopy\n","\n# Triggers `before_add` callback\nauthor.books << book\nauthor.books = [book, book2]\n\n# Does not trigger the `before_add` callback\nbook.update(author_id: 1)\n\n# Triggers `before_add` callback\nauthor.books << book\nauthor.books = [book, book2]\n\n# Does not trigger the `before_add` callback\nbook.update(author_id: 1)\n\nCopy\n"],"body":"Normal callbacks hook into the life cycle of Active Record objects, allowing you to work with those objects at various points. For example, you can use a :before_save callback to cause something to happen just before an object is saved.Association callbacks are similar to normal callbacks, but they are triggered by events in the life cycle of a collection. There are four available association callbacks:You define association callbacks by adding options to the association declaration. For example:Rails passes the object being added or removed to the callback.You can stack callbacks on a single event by passing them as an array:If a before_add callback throws :abort, the object does not get added to\nthe collection. Similarly, if a before_remove callback throws :abort, the\nobject does not get removed from the collection:"},{"code":["\nclass Author < ApplicationRecord\n  has_many :books do\n    def find_by_book_prefix(book_number)\n      find_by(category_id: book_number[0..2])\n    end\n  end\nend\n\nclass Author < ApplicationRecord\n  has_many :books do\n    def find_by_book_prefix(book_number)\n      find_by(category_id: book_number[0..2])\n    end\n  end\nend\n\nCopy\n","\nmodule FindRecentExtension\n  def find_recent\n    where(\"created_at > ?\", 5.days.ago)\n  end\nend\n\nclass Author < ApplicationRecord\n  has_many :books, -> { extending FindRecentExtension }\nend\n\nclass Supplier < ApplicationRecord\n  has_many :deliveries, -> { extending FindRecentExtension }\nend\n\nmodule FindRecentExtension\n  def find_recent\n    where(\"created_at > ?\", 5.days.ago)\n  end\nend\n\nclass Author < ApplicationRecord\n  has_many :books, -> { extending FindRecentExtension }\nend\n\nclass Supplier < ApplicationRecord\n  has_many :deliveries, -> { extending FindRecentExtension }\nend\n\nCopy\n"],"body":"You're not limited to the functionality that Rails automatically builds into association proxy objects. You can also extend these objects through anonymous modules, adding new finders, creators, or other methods. For example:If you have an extension that should be shared by many associations, you can use a named extension module. For example:Extensions can refer to the internals of the association proxy using these three attributes of the proxy_association accessor:","title":"4.6 Association Extensions","anchor":"#association-extensions"},{"code":["\n$ bin/rails generate model vehicle type:string color:string price:decimal{10.2}\n\nbin/rails generate model vehicle type:string color:string price:decimal{10.2}\n\nCopy\n","\n$ bin/rails generate model car --parent=Vehicle\n\nbin/rails generate model car --parent=Vehicle\n\nCopy\n","\nclass Car < Vehicle\nend\n\nclass Car < Vehicle\nend\n\nCopy\n","\nCar.create(color: 'Red', price: 10000)\n\nCar.create(color: 'Red', price: 10000)\n\nCopy\n","\nINSERT INTO \"vehicles\" (\"type\", \"color\", \"price\") VALUES ('Car', 'Red', 10000)\n\nINSERT INTO \"vehicles\" (\"type\", \"color\", \"price\") VALUES ('Car', 'Red', 10000)\n\nCopy\n","\nCar.all\n\nCar.all\n\nCopy\n","\nSELECT \"vehicles\".* FROM \"vehicles\" WHERE \"vehicles\".\"type\" IN ('Car')\n\nSELECT \"vehicles\".* FROM \"vehicles\" WHERE \"vehicles\".\"type\" IN ('Car')\n\nCopy\n"],"body":"Sometimes, you may want to share fields and behavior between different models.\nLet's say we have Car, Motorcycle, and Bicycle models. We will want to share\nthe color and price fields and some methods for all of them, but having some\nspecific behavior for each, and separated controllers too.First, let's generate the base Vehicle model:Did you note we are adding a \"type\" field? Since all models will be saved in a\nsingle database table, Rails will save in this column the name of the model that\nis being saved. In our example, this can be \"Car\", \"Motorcycle\" or \"Bicycle.\"\nSTI won't work without a \"type\" field in the table.Next, we will generate the Car model that inherits from Vehicle. For this,\nwe can use the --parent=PARENT option, which will generate a model that\ninherits from the specified parent and without equivalent migration (since the\ntable already exists).For example, to generate the Car model:The generated model will look like this:This means that all behavior added to Vehicle is available for Car too, as\nassociations, public methods, etc.Creating a car will save it in the vehicles table with \"Car\" as the type field:will generate the following SQL:Querying car records will search only for vehicles that are cars:will run a query like:","title":"5 Single Table Inheritance (STI)","anchor":"#single-table-inheritance-sti"}]