[{"code":[],"body":"Rails makes it super easy to write your tests. It starts by producing skeleton test code while you are creating your models and controllers.By running your Rails tests you can ensure your code adheres to the desired functionality even after some major code refactoring.Rails tests can also simulate browser requests and thus you can test your application's response without having to test it through your browser.","title":"1 Why Write Tests for your Rails Applications?","anchor":"#why-write-tests-for-your-rails-applications-questionmark"},{"title":"2 Introduction to Testing","anchor":"#introduction-to-testing","code":[],"body":"Testing support was woven into the Rails fabric from the beginning. It wasn't an \"oh! let's bolt on support for running tests because they're new and cool\" epiphany."},{"title":"2.1 Rails Sets up for Testing from the Word Go","anchor":"#rails-sets-up-for-testing-from-the-word-go","code":["\n$ ls -F test\napplication_system_test_case.rb  controllers/                     helpers/                         mailers/                         system/\nchannels/                        fixtures/                        integration/                     models/                          test_helper.rb\n\nls -F test\n\nCopy\n"],"body":"Rails creates a test directory for you as soon as you create a Rails project using rails new application_name. If you list the contents of this directory then you shall see:The helpers, mailers, and models directories are meant to hold tests for view helpers, mailers, and models, respectively. The channels directory is meant to hold tests for Action Cable connection and channels. The controllers directory is meant to hold tests for controllers, routes, and views. The integration directory is meant to hold tests for interactions between controllers.The system test directory holds system tests, which are used for full browser\ntesting of your application. System tests allow you to test your application\nthe way your users experience it and help you test your JavaScript as well.\nSystem tests inherit from Capybara and perform in browser tests for your\napplication.Fixtures are a way of organizing test data; they reside in the fixtures directory.A jobs directory will also be created when an associated test is first generated.The test_helper.rb file holds the default configuration for your tests.The application_system_test_case.rb holds the default configuration for your system\ntests."},{"title":"2.2 The Test Environment","anchor":"#the-test-environment","code":[],"body":"By default, every Rails application has three environments: development, test, and production.Each environment's configuration can be modified similarly. In this case, we can modify our test environment by changing the options found in config/environments/test.rb."},{"title":"2.3 Rails meets Minitest","anchor":"#rails-meets-minitest","code":["\n$ bin/rails generate model article title:string body:text\n...\ncreate  app/models/article.rb\ncreate  test/models/article_test.rb\ncreate  test/fixtures/articles.yml\n...\n\nbin/rails generate model article title:string body:text\n\nCopy\n","\nrequire \"test_helper\"\n\nclass ArticleTest < ActiveSupport::TestCase\n  # test \"the truth\" do\n  #   assert true\n  # end\nend\n\nrequire \"test_helper\"\n\nclass ArticleTest < ActiveSupport::TestCase\n  # test \"the truth\" do\n  #   assert true\n  # end\nend\n\nCopy\n","\nrequire \"test_helper\"\n\nrequire \"test_helper\"\n\nCopy\n","\nclass ArticleTest < ActiveSupport::TestCase\n\nclass ArticleTest < ActiveSupport::TestCase\n\nCopy\n","\ntest \"the truth\" do\n  assert true\nend\n\ntest \"the truth\" do\n  assert true\nend\n\nCopy\n","\ndef test_the_truth\n  assert true\nend\n\ndef test_the_truth\n  assert true\nend\n\nCopy\n","\nassert true\n\nassert true\n\nCopy\n"],"body":"If you remember, we used the bin/rails generate model command in the\nGetting Started with Rails guide. We created our first\nmodel, and among other things it created test stubs in the test directory:The default test stub in test/models/article_test.rb looks like this:A line by line examination of this file will help get you oriented to Rails testing code and terminology.By requiring this file, test_helper.rb the default configuration to run our tests is loaded. We will include this with all the tests we write, so any methods added to this file are available to all our tests.The ArticleTest class defines a test case because it inherits from ActiveSupport::TestCase. ArticleTest thus has all the methods available from ActiveSupport::TestCase. Later in this guide, we'll see some of the methods it gives us.Any method defined within a class inherited from Minitest::Test\n(which is the superclass of ActiveSupport::TestCase) that begins with test_ is simply called a test. So, methods defined as test_password and test_valid_password are legal test names and are run automatically when the test case is run.Rails also adds a test method that takes a test name and a block. It generates a normal Minitest::Unit test with method names prefixed with test_. So you don't have to worry about naming the methods, and you can write something like:Which is approximately the same as writing this:Although you can still use regular method definitions, using the test macro allows for a more readable test name.Next, let's look at our first assertion:An assertion is a line of code that evaluates an object (or expression) for expected results. For example, an assertion can check:Every test may contain one or more assertions, with no restriction as to how many assertions are allowed. Only when all the assertions are successful will the test pass."},{"title":"2.3.1 Your first failing test","anchor":"#your-first-failing-test","code":["\ntest \"should not save article without title\" do\n  article = Article.new\n  assert_not article.save\nend\n\ntest \"should not save article without title\" do\n  article = Article.new\n  assert_not article.save\nend\n\nCopy\n","\n$ bin/rails test test/models/article_test.rb:6\nRun options: --seed 44656\n\n# Running:\n\nF\n\nFailure:\nArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:\nExpected true to be nil or false\n\n\nrails test test/models/article_test.rb:6\n\n\n\nFinished in 0.023918s, 41.8090 runs/s, 41.8090 assertions/s.\n\n1 runs, 1 assertions, 1 failures, 0 errors, 0 skips\n\nbin/rails test test/models/article_test.rb:6\n\nCopy\n","\ntest \"should not save article without title\" do\n  article = Article.new\n  assert_not article.save, \"Saved the article without a title\"\nend\n\ntest \"should not save article without title\" do\n  article = Article.new\n  assert_not article.save, \"Saved the article without a title\"\nend\n\nCopy\n","\nFailure:\nArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:\nSaved the article without a title\n\nFailure:\nArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:\nSaved the article without a title\n\nCopy\n","\nclass Article < ApplicationRecord\n  validates :title, presence: true\nend\n\nclass Article < ApplicationRecord\n  validates :title, presence: true\nend\n\nCopy\n","\n$ bin/rails test test/models/article_test.rb:6\nRun options: --seed 31252\n\n# Running:\n\n.\n\nFinished in 0.027476s, 36.3952 runs/s, 36.3952 assertions/s.\n\n1 runs, 1 assertions, 0 failures, 0 errors, 0 skips\n\nbin/rails test test/models/article_test.rb:6\n\nCopy\n"],"body":"To see how a test failure is reported, you can add a failing test to the article_test.rb test case.Let us run this newly added test (where 6 is the number of line where the test is defined).In the output, F denotes a failure. You can see the corresponding trace shown under Failure along with the name of the failing test. The next few lines contain the stack trace followed by a message that mentions the actual value and the expected value by the assertion. The default assertion messages provide just enough information to help pinpoint the error. To make the assertion failure message more readable, every assertion provides an optional message parameter, as shown here:Running this test shows the friendlier assertion message:Now to get this test to pass we can add a model level validation for the title field.Now the test should pass. Let us verify by running the test again:Now, if you noticed, we first wrote a test which fails for a desired\nfunctionality, then we wrote some code which adds the functionality and finally\nwe ensured that our test passes. This approach to software development is\nreferred to as\nTest-Driven Development (TDD)."},{"title":"2.3.2 What an Error Looks Like","anchor":"#what-an-error-looks-like","code":["\ntest \"should report error\" do\n  # some_undefined_variable is not defined elsewhere in the test case\n  some_undefined_variable\n  assert true\nend\n\ntest \"should report error\" do\n  # some_undefined_variable is not defined elsewhere in the test case\n  some_undefined_variable\n  assert true\nend\n\nCopy\n","\n$ bin/rails test test/models/article_test.rb\nRun options: --seed 1808\n\n# Running:\n\n.E\n\nError:\nArticleTest#test_should_report_error:\nNameError: undefined local variable or method 'some_undefined_variable' for #<ArticleTest:0x007fee3aa71798>\n    test/models/article_test.rb:11:in 'block in <class:ArticleTest>'\n\n\nrails test test/models/article_test.rb:9\n\n\n\nFinished in 0.040609s, 49.2500 runs/s, 24.6250 assertions/s.\n\n2 runs, 1 assertions, 0 failures, 1 errors, 0 skips\n\nbin/rails test test/models/article_test.rb\n\nCopy\n","\n$ bin/rails test -b test/models/article_test.rb\n\nbin/rails test -b test/models/article_test.rb\n\nCopy\n","\ntest \"should report error\" do\n  # some_undefined_variable is not defined elsewhere in the test case\n  assert_raises(NameError) do\n    some_undefined_variable\n  end\nend\n\ntest \"should report error\" do\n  # some_undefined_variable is not defined elsewhere in the test case\n  assert_raises(NameError) do\n    some_undefined_variable\n  end\nend\n\nCopy\n"],"body":"To see how an error gets reported, here's a test containing an error:Now you can see even more output in the console from running the tests:Notice the 'E' in the output. It denotes a test with error.When a test fails you are presented with the corresponding backtrace. By default\nRails filters that backtrace and will only print lines relevant to your\napplication. This eliminates the framework noise and helps to focus on your\ncode. However there are situations when you want to see the full\nbacktrace. Set the -b (or --backtrace) argument to enable this behavior:If we want this test to pass we can modify it to use assert_raises like so:This test should now pass."},{"title":"2.4 Available Assertions","anchor":"#available-assertions","code":[],"body":"By now you've caught a glimpse of some of the assertions that are available. Assertions are the worker bees of testing. They are the ones that actually perform the checks to ensure that things are going as planned.Here's an extract of the assertions you can use with\nMinitest, the default testing library\nused by Rails. The [msg] parameter is an optional string message you can\nspecify to make your test failure messages clearer.The above are a subset of assertions that minitest supports. For an exhaustive &\nmore up-to-date list, please check\nMinitest API documentation, specifically\nMinitest::Assertions.Because of the modular nature of the testing framework, it is possible to create your own assertions. In fact, that's exactly what Rails does. It includes some specialized assertions to make your life easier."},{"title":"2.5 Rails Specific Assertions","anchor":"#rails-specific-assertions","code":[],"body":"Rails adds some custom assertions of its own to the minitest framework:You'll see the usage of some of these assertions in the next chapter."},{"title":"2.6 A Brief Note About Test Cases","anchor":"#a-brief-note-about-test-cases","code":[],"body":"All the basic assertions such as assert_equal defined in Minitest::Assertions are also available in the classes we use in our own test cases. In fact, Rails provides the following classes for you to inherit from:Each of these classes include Minitest::Assertions, allowing us to use all of the basic assertions in our tests."},{"title":"2.7 The Rails Test Runner","anchor":"#the-rails-test-runner","code":["\n$ bin/rails test test/models/article_test.rb\nRun options: --seed 1559\n\n# Running:\n\n..\n\nFinished in 0.027034s, 73.9810 runs/s, 110.9715 assertions/s.\n\n2 runs, 3 assertions, 0 failures, 0 errors, 0 skips\n\nbin/rails test test/models/article_test.rb\n\nCopy\n","\n$ bin/rails test test/models/article_test.rb -n test_the_truth\nRun options: -n test_the_truth --seed 43583\n\n# Running:\n\n.\n\nFinished tests in 0.009064s, 110.3266 tests/s, 110.3266 assertions/s.\n\n1 tests, 1 assertions, 0 failures, 0 errors, 0 skips\n\nbin/rails test test/models/article_test.rb -n test_the_truth\n\nCopy\n","\n$ bin/rails test test/models/article_test.rb:6 # run specific test and line\n\nbin/rails test test/models/article_test.rb:6 # run specific test and line\n\nCopy\n","\n$ bin/rails test test/controllers # run all tests from specific directory\n\nbin/rails test test/controllers # run all tests from specific directory\n\nCopy\n","\n$ bin/rails test -h\nUsage: rails test [options] [files or directories]\n\nYou can run a single test by appending a line number to a filename:\n\n    bin/rails test test/models/user_test.rb:27\n\nYou can run multiple files and directories at the same time:\n\n    bin/rails test test/controllers test/integration/login_test.rb\n\nBy default test failures and errors are reported inline during a run.\n\nminitest options:\n    -h, --help                       Display this help.\n        --no-plugins                 Bypass minitest plugin auto-loading (or set $MT_NO_PLUGINS).\n    -s, --seed SEED                  Sets random seed. Also via env. Eg: SEED=n rake\n    -v, --verbose                    Verbose. Show progress processing files.\n    -n, --name PATTERN               Filter run on /regexp/ or string.\n        --exclude PATTERN            Exclude /regexp/ or string from run.\n\nKnown extensions: rails, pride\n    -w, --warnings                   Run with Ruby warnings enabled\n    -e, --environment ENV            Run tests in the ENV environment\n    -b, --backtrace                  Show the complete backtrace\n    -d, --defer-output               Output test failures and errors after the test run\n    -f, --fail-fast                  Abort test run on first failure or error\n    -c, --[no-]color                 Enable color in the output\n    -p, --pride                      Pride. Show your testing pride!\n\nbin/rails test -h\n\nCopy\n"],"body":"We can run all of our tests at once by using the bin/rails test command.Or we can run a single test file by passing the bin/rails test command the filename containing the test cases.This will run all test methods from the test case.You can also run a particular test method from the test case by providing the\n-n or --name flag and the test's method name.You can also run a test at a specific line by providing the line number.You can also run an entire directory of tests by providing the path to the directory.The test runner also provides a lot of other features like failing fast, deferring test output\nat the end of the test run and so on. Check the documentation of the test runner as follows:"},{"code":[],"body":"Parallel testing allows you to parallelize your test suite. While forking processes is the\ndefault method, threading is supported as well. Running tests in parallel reduces the time it\ntakes your entire test suite to run.","title":"3 Parallel Testing","anchor":"#parallel-testing"},{"title":"3.1 Parallel Testing with Processes","anchor":"#parallel-testing-with-processes","code":["\nclass ActiveSupport::TestCase\n  parallelize(workers: 2)\nend\n\nclass ActiveSupport::TestCase\n  parallelize(workers: 2)\nend\n\nCopy\n","\n$ PARALLEL_WORKERS=15 bin/rails test\n\nPARALLEL_WORKERS=15 bin/rails test\n\nCopy\n","\nclass ActiveSupport::TestCase\n  parallelize_setup do |worker|\n    # setup databases\n  end\n\n  parallelize_teardown do |worker|\n    # cleanup databases\n  end\n\n  parallelize(workers: :number_of_processors)\nend\n\nclass ActiveSupport::TestCase\n  parallelize_setup do |worker|\n    # setup databases\n  end\n\n  parallelize_teardown do |worker|\n    # cleanup databases\n  end\n\n  parallelize(workers: :number_of_processors)\nend\n\nCopy\n"],"body":"The default parallelization method is to fork processes using Ruby's DRb system. The processes\nare forked based on the number of workers provided. The default number is the actual core count\non the machine you are on, but can be changed by the number passed to the parallelize method.To enable parallelization add the following to your test_helper.rb:The number of workers passed is the number of times the process will be forked. You may want to\nparallelize your local test suite differently from your CI, so an environment variable is provided\nto be able to easily change the number of workers a test run should use:When parallelizing tests, Active Record automatically handles creating a database and loading the schema into the database for each\nprocess. The databases will be suffixed with the number corresponding to the worker. For example, if you\nhave 2 workers the tests will create test-database-0 and test-database-1 respectively.If the number of workers passed is 1 or fewer the processes will not be forked and the tests will not\nbe parallelized and the tests will use the original test-database database.Two hooks are provided, one runs when the process is forked, and one runs before the forked process is closed.\nThese can be useful if your app uses multiple databases or perform other tasks that depend on the number of\nworkers.The parallelize_setup method is called right after the processes are forked. The parallelize_teardown method\nis called right before the processes are closed.These methods are not needed or available when using parallel testing with threads."},{"title":"3.2 Parallel Testing with Threads","anchor":"#parallel-testing-with-threads","code":["\nclass ActiveSupport::TestCase\n  parallelize(workers: :number_of_processors, with: :threads)\nend\n\nclass ActiveSupport::TestCase\n  parallelize(workers: :number_of_processors, with: :threads)\nend\n\nCopy\n","\n$ PARALLEL_WORKERS=15 bin/rails test\n\nPARALLEL_WORKERS=15 bin/rails test\n\nCopy\n"],"body":"If you prefer using threads or are using JRuby, a threaded parallelization option is provided. The threaded\nparallelizer is backed by Minitest's Parallel::Executor.To change the parallelization method to use threads over forks put the following in your test_helper.rbRails applications generated from JRuby or TruffleRuby will automatically include the with: :threads option.The number of workers passed to parallelize determines the number of threads the tests will use. You may\nwant to parallelize your local test suite differently from your CI, so an environment variable is provided\nto be able to easily change the number of workers a test run should use:"},{"code":["\nclass WorkerTest < ActiveSupport::TestCase\n  self.use_transactional_tests = false\n\n  test \"parallel transactions\" do\n    # start some threads that create transactions\n  end\nend\n\nclass WorkerTest < ActiveSupport::TestCase\n  self.use_transactional_tests = false\n\n  test \"parallel transactions\" do\n    # start some threads that create transactions\n  end\nend\n\nCopy\n"],"body":"Rails automatically wraps any test case in a database transaction that is rolled\nback after the test completes.  This makes test cases independent of each other\nand changes to the database are only visible within a single test.When you want to test code that runs parallel transactions in threads,\ntransactions can block each other because they are already nested under the test\ntransaction.You can disable transactions in a test case class by setting\nself.use_transactional_tests = false:","title":"3.3 Testing Parallel Transactions","anchor":"#testing-parallel-transactions"},{"title":"4 The Test Database","anchor":"#the-test-database","code":[],"body":"Just about every Rails application interacts heavily with a database and, as a result, your tests will need a database to interact with as well. To write efficient tests, you'll need to understand how to set up this database and populate it with sample data.By default, every Rails application has three environments: development, test, and production. The database for each one of them is configured in config/database.yml.A dedicated test database allows you to set up and interact with test data in isolation. This way your tests can mangle test data with confidence, without worrying about the data in the development or production databases."},{"title":"4.1 Maintaining the test database schema","anchor":"#maintaining-the-test-database-schema","code":[],"body":"In order to run your tests, your test database will need to have the current\nstructure. The test helper checks whether your test database has any pending\nmigrations. It will try to load your db/schema.rb or db/structure.sql\ninto the test database. If migrations are still pending, an error will be\nraised. Usually this indicates that your schema is not fully migrated. Running\nthe migrations against the development database (bin/rails db:migrate) will\nbring the schema up to date."},{"title":"4.2 The Low-Down on Fixtures","anchor":"#the-low-down-on-fixtures","code":[],"body":"For good tests, you'll need to give some thought to setting up test data.\nIn Rails, you can handle this by defining and customizing fixtures.\nYou can find comprehensive documentation in the Fixtures API documentation."},{"title":"4.2.1 What are Fixtures?","anchor":"#what-are-fixtures-questionmark","code":[],"body":"Fixtures is a fancy word for sample data. Fixtures allow you to populate your testing database with predefined data before your tests run. Fixtures are database independent and written in YAML. There is one file per model.You'll find fixtures under your test/fixtures directory. When you run bin/rails generate model to create a new model, Rails automatically creates fixture stubs in this directory."},{"title":"4.2.2 YAML","anchor":"#yaml","code":["\n# lo & behold! I am a YAML comment!\ndavid:\n  name: David Heinemeier Hansson\n  birthday: 1979-10-15\n  profession: Systems development\n\nsteve:\n  name: Steve Ross Kellock\n  birthday: 1974-09-27\n  profession: guy with keyboard\n\n# lo & behold! I am a YAML comment!\ndavid:\n  name: David Heinemeier Hansson\n  birthday: 1979-10-15\n  profession: Systems development\n\nsteve:\n  name: Steve Ross Kellock\n  birthday: 1974-09-27\n  profession: guy with keyboard\n\nCopy\n","\n# fixtures/categories.yml\nabout:\n  name: About\n\n# fixtures/categories.yml\nabout:\n  name: About\n\nCopy\n","\n# fixtures/articles.yml\nfirst:\n  title: Welcome to Rails!\n  body: Hello world!\n  category: about\n\n# fixtures/articles.yml\nfirst:\n  title: Welcome to Rails!\n  body: Hello world!\n  category: about\n\nCopy\n"],"body":"YAML-formatted fixtures are a human-friendly way to describe your sample data. These types of fixtures have the .yml file extension (as in users.yml).Here's a sample YAML fixture file:Each fixture is given a name followed by an indented list of colon-separated key/value pairs. Records are typically separated by a blank line. You can place comments in a fixture file by using the # character in the first column.If you are working with associations, you can\ndefine a reference node between two different fixtures. Here's an example with\na belongs_to/has_many association:Notice the category key of the first article found in fixtures/articles.yml has a value of about. This tells Rails to load the category about found in fixtures/categories.yml."},{"title":"4.2.3 ERB'in It Up","anchor":"#erb-in-it-up","code":["\n<% 1000.times do |n| %>\nuser_<%= n %>:\n  username: <%= \"user#{n}\" %>\n  email: <%= \"user#{n}@example.com\" %>\n<% end %>\n\n<% 1000.times do |n| %>\nuser_<%= n %>:\n  username: <%= \"user#{n}\" %>\n  email: <%= \"user#{n}@example.com\" %>\n<% end %>\n\nCopy\n"],"body":"ERB allows you to embed Ruby code within templates. The YAML fixture format is pre-processed with ERB when Rails loads fixtures. This allows you to use Ruby to help you generate some sample data. For example, the following code generates a thousand users:"},{"code":[],"body":"Rails automatically loads all fixtures from the test/fixtures directory by\ndefault. Loading involves three steps:","title":"4.2.4 Fixtures in Action","anchor":"#fixtures-in-action"},{"title":"4.2.5 Fixtures are Active Record objects","anchor":"#fixtures-are-active-record-objects","code":["\n# this will return the User object for the fixture named david\nusers(:david)\n\n# this will return the property for david called id\nusers(:david).id\n\n# one can also access methods available on the User class\ndavid = users(:david)\ndavid.call(david.partner)\n\n# this will return the User object for the fixture named david\nusers(:david)\n\n# this will return the property for david called id\nusers(:david).id\n\n# one can also access methods available on the User class\ndavid = users(:david)\ndavid.call(david.partner)\n\nCopy\n","\n# this will return an array containing the fixtures david and steve\nusers(:david, :steve)\n\n# this will return an array containing the fixtures david and steve\nusers(:david, :steve)\n\nCopy\n"],"body":"Fixtures are instances of Active Record. As mentioned in point #3 above, you can access the object directly because it is automatically available as a method whose scope is local of the test case. For example:To get multiple fixtures at once, you can pass in a list of fixture names. For example:"},{"code":["\n$ bin/rails generate test_unit:model article title:string body:text\ncreate  test/models/article_test.rb\ncreate  test/fixtures/articles.yml\n\nbin/rails generate test_unit:model article title:string body:text\n\nCopy\n"],"body":"Model tests are used to test the various models of your application.Rails model tests are stored under the test/models directory. Rails provides\na generator to create a model test skeleton for you.Model tests don't have their own superclass like ActionMailer::TestCase. Instead, they inherit from ActiveSupport::TestCase.","title":"5 Model Testing","anchor":"#model-testing"},{"title":"6 System Testing","anchor":"#system-testing","code":["\n$ bin/rails generate system_test users\n      invoke test_unit\n      create test/system/users_test.rb\n\nbin/rails generate system_test users\n\nCopy\n","\nrequire \"application_system_test_case\"\n\nclass UsersTest < ApplicationSystemTestCase\n  # test \"visiting the index\" do\n  #   visit users_url\n  #\n  #   assert_selector \"h1\", text: \"Users\"\n  # end\nend\n\nrequire \"application_system_test_case\"\n\nclass UsersTest < ApplicationSystemTestCase\n  # test \"visiting the index\" do\n  #   visit users_url\n  #\n  #   assert_selector \"h1\", text: \"Users\"\n  # end\nend\n\nCopy\n"],"body":"System tests allow you to test user interactions with your application, running tests\nin either a real or a headless browser. System tests use Capybara under the hood.For creating Rails system tests, you use the test/system directory in your\napplication. Rails provides a generator to create a system test skeleton for you.Here's what a freshly generated system test looks like:By default, system tests are run with the Selenium driver, using the Chrome\nbrowser, and a screen size of 1400x1400. The next section explains how to\nchange the default settings."},{"title":"6.1 Changing the default settings","anchor":"#changing-the-default-settings","code":["\nrequire \"test_helper\"\nrequire \"capybara/poltergeist\"\n\nclass ApplicationSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :poltergeist\nend\n\nrequire \"test_helper\"\nrequire \"capybara/poltergeist\"\n\nclass ApplicationSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :poltergeist\nend\n\nCopy\n","\nrequire \"test_helper\"\n\nclass ApplicationSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :firefox\nend\n\nrequire \"test_helper\"\n\nclass ApplicationSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :firefox\nend\n\nCopy\n","\nrequire \"test_helper\"\n\nclass ApplicationSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :headless_chrome\nend\n\nrequire \"test_helper\"\n\nclass ApplicationSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :headless_chrome\nend\n\nCopy\n"],"body":"Rails makes changing the default settings for system tests very simple. All\nthe setup is abstracted away so you can focus on writing your tests.When you generate a new application or scaffold, an application_system_test_case.rb file\nis created in the test directory. This is where all the configuration for your\nsystem tests should live.If you want to change the default settings you can change what the system\ntests are \"driven by\". Say you want to change the driver from Selenium to\nPoltergeist. First add the poltergeist gem to your Gemfile. Then in your\napplication_system_test_case.rb file do the following:The driver name is a required argument for driven_by. The optional arguments\nthat can be passed to driven_by are :using for the browser (this will only\nbe used by Selenium), :screen_size to change the size of the screen for\nscreenshots, and :options which can be used to set options supported by the\ndriver.If you want to use a headless browser, you could use Headless Chrome or Headless Firefox by adding\nheadless_chrome or headless_firefox in the :using argument.If your Capybara configuration requires more setup than provided by Rails, this\nadditional configuration could be added into the application_system_test_case.rb\nfile.Please see Capybara's documentation\nfor additional settings."},{"title":"6.2 Screenshot Helper","anchor":"#screenshot-helper","code":[],"body":"The ScreenshotHelper is a helper designed to capture screenshots of your tests.\nThis can be helpful for viewing the browser at the point a test failed, or\nto view screenshots later for debugging.Two methods are provided: take_screenshot and take_failed_screenshot.\ntake_failed_screenshot is automatically included in before_teardown inside\nRails.The take_screenshot helper method can be included anywhere in your tests to\ntake a screenshot of the browser."},{"title":"6.3 Implementing a System Test","anchor":"#implementing-a-system-test","code":["\n$ bin/rails generate system_test articles\n\nbin/rails generate system_test articles\n\nCopy\n","\n      invoke  test_unit\n      create    test/system/articles_test.rb\n\n      invoke  test_unit\n      create    test/system/articles_test.rb\n\nCopy\n","\nrequire \"application_system_test_case\"\n\nclass ArticlesTest < ApplicationSystemTestCase\n  test \"viewing the index\" do\n    visit articles_path\n    assert_selector \"h1\", text: \"Articles\"\n  end\nend\n\nrequire \"application_system_test_case\"\n\nclass ArticlesTest < ApplicationSystemTestCase\n  test \"viewing the index\" do\n    visit articles_path\n    assert_selector \"h1\", text: \"Articles\"\n  end\nend\n\nCopy\n","\n$ bin/rails test:system\n\nbin/rails test:system\n\nCopy\n"],"body":"Now we're going to add a system test to our blog application. We'll demonstrate\nwriting a system test by visiting the index page and creating a new blog article.If you used the scaffold generator, a system test skeleton was automatically\ncreated for you. If you didn't use the scaffold generator, start by creating a\nsystem test skeleton.It should have created a test file placeholder for us. With the output of the\nprevious command you should see:Now let's open that file and write our first assertion:The test should see that there is an h1 on the articles index page and pass.Run the system tests."},{"title":"6.3.1 Creating Articles System Test","anchor":"#creating-articles-system-test","code":["\ntest \"creating an article\" do\n  visit articles_path\n\n  click_on \"New Article\"\n\n  fill_in \"Title\", with: \"Creating an Article\"\n  fill_in \"Body\", with: \"Created this article successfully!\"\n\n  click_on \"Create Article\"\n\n  assert_text \"Creating an Article\"\nend\n\ntest \"creating an article\" do\n  visit articles_path\n\n  click_on \"New Article\"\n\n  fill_in \"Title\", with: \"Creating an Article\"\n  fill_in \"Body\", with: \"Created this article successfully!\"\n\n  click_on \"Create Article\"\n\n  assert_text \"Creating an Article\"\nend\n\nCopy\n"],"body":"Now let's test the flow for creating a new article in our blog.The first step is to call visit articles_path. This will take the test to the\narticles index page.Then the click_on \"New Article\" will find the \"New Article\" button on the\nindex page. This will redirect the browser to /articles/new.Then the test will fill in the title and body of the article with the specified\ntext. Once the fields are filled in, \"Create Article\" is clicked on which will\nsend a POST request to create the new article in the database.We will be redirected back to the articles index page and there we assert\nthat the text from the new article's title is on the articles index page."},{"title":"6.3.2 Testing for multiple screen sizes","anchor":"#testing-for-multiple-screen-sizes","code":["\nrequire \"test_helper\"\n\nclass MobileSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :chrome, screen_size: [375, 667]\nend\n\nrequire \"test_helper\"\n\nclass MobileSystemTestCase < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :chrome, screen_size: [375, 667]\nend\n\nCopy\n","\nrequire \"mobile_system_test_case\"\n\nclass PostsTest < MobileSystemTestCase\n\n  test \"visiting the index\" do\n    visit posts_url\n    assert_selector \"h1\", text: \"Posts\"\n  end\nend\n\nrequire \"mobile_system_test_case\"\n\nclass PostsTest < MobileSystemTestCase\n\n  test \"visiting the index\" do\n    visit posts_url\n    assert_selector \"h1\", text: \"Posts\"\n  end\nend\n\nCopy\n"],"body":"If you want to test for mobile sizes on top of testing for desktop,\nyou can create another class that inherits from SystemTestCase and use in your\ntest suite. In this example a file called mobile_system_test_case.rb is created\nin the /test directory with the following configuration.To use this configuration, create a test inside test/system that inherits from MobileSystemTestCase.\nNow you can test your app using multiple different configurations."},{"code":[],"body":"The beauty of system testing is that it is similar to integration testing in\nthat it tests the user's interaction with your controller, model, and view, but\nsystem testing is much more robust and actually tests your application as if\na real user were using it. Going forward, you can test anything that the user\nthemselves would do in your application such as commenting, deleting articles,\npublishing draft articles, etc.","title":"6.3.3 Taking it further","anchor":"#implementing-a-system-test-taking-it-further"},{"title":"7 Integration Testing","anchor":"#integration-testing","code":["\n$ bin/rails generate integration_test user_flows\n      exists  test/integration/\n      create  test/integration/user_flows_test.rb\n\nbin/rails generate integration_test user_flows\n\nCopy\n","\nrequire \"test_helper\"\n\nclass UserFlowsTest < ActionDispatch::IntegrationTest\n  # test \"the truth\" do\n  #   assert true\n  # end\nend\n\nrequire \"test_helper\"\n\nclass UserFlowsTest < ActionDispatch::IntegrationTest\n  # test \"the truth\" do\n  #   assert true\n  # end\nend\n\nCopy\n"],"body":"Integration tests are used to test how various parts of our application interact. They are generally used to test important workflows within our application.For creating Rails integration tests, we use the test/integration directory for our application. Rails provides a generator to create an integration test skeleton for us.Here's what a freshly generated integration test looks like:Here the test is inheriting from ActionDispatch::IntegrationTest. This makes some additional helpers available for us to use in our integration tests."},{"title":"7.1 Helpers Available for Integration Tests","anchor":"#helpers-available-for-integration-tests","code":[],"body":"In addition to the standard testing helpers, inheriting from ActionDispatch::IntegrationTest comes with some additional helpers available when writing integration tests. Let's get briefly introduced to the three categories of helpers we get to choose from.For dealing with the integration test runner, see ActionDispatch::Integration::Runner.When performing requests, we will have ActionDispatch::Integration::RequestHelpers available for our use.If we need to modify the session, or state of our integration test, take a look at ActionDispatch::Integration::Session to help."},{"title":"7.2 Implementing an integration test","anchor":"#implementing-an-integration-test","code":["\n$ bin/rails generate integration_test blog_flow\n\nbin/rails generate integration_test blog_flow\n\nCopy\n","\n      invoke  test_unit\n      create    test/integration/blog_flow_test.rb\n\n      invoke  test_unit\n      create    test/integration/blog_flow_test.rb\n\nCopy\n","\nrequire \"test_helper\"\n\nclass BlogFlowTest < ActionDispatch::IntegrationTest\n  test \"can see the welcome page\" do\n    get \"/\"\n    assert_select \"h1\", \"Welcome#index\"\n  end\nend\n\nrequire \"test_helper\"\n\nclass BlogFlowTest < ActionDispatch::IntegrationTest\n  test \"can see the welcome page\" do\n    get \"/\"\n    assert_select \"h1\", \"Welcome#index\"\n  end\nend\n\nCopy\n"],"body":"Let's add an integration test to our blog application. We'll start with a basic workflow of creating a new blog article, to verify that everything is working properly.We'll start by generating our integration test skeleton:It should have created a test file placeholder for us. With the output of the\nprevious command we should see:Now let's open that file and write our first assertion:We will take a look at assert_select to query the resulting HTML of a request in the \"Testing Views\" section below. It is used for testing the response of our request by asserting the presence of key HTML elements and their content.When we visit our root path, we should see welcome/index.html.erb rendered for the view. So this assertion should pass."},{"title":"7.2.1 Creating articles integration","anchor":"#creating-articles-integration","code":["\ntest \"can create an article\" do\n  get \"/articles/new\"\n  assert_response :success\n\n  post \"/articles\",\n    params: { article: { title: \"can create\", body: \"article successfully.\" } }\n  assert_response :redirect\n  follow_redirect!\n  assert_response :success\n  assert_select \"p\", \"Title:\\n  can create\"\nend\n\ntest \"can create an article\" do\n  get \"/articles/new\"\n  assert_response :success\n\n  post \"/articles\",\n    params: { article: { title: \"can create\", body: \"article successfully.\" } }\n  assert_response :redirect\n  follow_redirect!\n  assert_response :success\n  assert_select \"p\", \"Title:\\n  can create\"\nend\n\nCopy\n","\npost \"/articles\",\n  params: { article: { title: \"can create\", body: \"article successfully.\" } }\nassert_response :redirect\nfollow_redirect!\n\npost \"/articles\",\n  params: { article: { title: \"can create\", body: \"article successfully.\" } }\nassert_response :redirect\nfollow_redirect!\n\nCopy\n"],"body":"How about testing our ability to create a new article in our blog and see the resulting article.Let's break this test down so we can understand it.We start by calling the :new action on our Articles controller. This response should be successful.After this we make a post request to the :create action of our Articles controller:The two lines following the request are to handle the redirect we setup when creating a new article.Finally we can assert that our response was successful and our new article is readable on the page."},{"title":"7.2.2 Taking it further","anchor":"#implementing-an-integration-test-taking-it-further","code":[],"body":"We were able to successfully test a very small workflow for visiting our blog and creating a new article. If we wanted to take this further we could add tests for commenting, removing articles, or editing comments. Integration tests are a great place to experiment with all kinds of use cases for our applications."},{"title":"8 Functional Tests for Your Controllers","anchor":"#functional-tests-for-your-controllers","code":[],"body":"In Rails, testing the various actions of a controller is a form of writing functional tests. Remember your controllers handle the incoming web requests to your application and eventually respond with a rendered view. When writing functional tests, you are testing how your actions handle the requests and the expected result or response, in some cases an HTML view."},{"title":"8.1 What to include in your Functional Tests","anchor":"#what-to-include-in-your-functional-tests","code":["\n$ bin/rails generate scaffold_controller article title:string body:text\n...\ncreate  app/controllers/articles_controller.rb\n...\ninvoke  test_unit\ncreate    test/controllers/articles_controller_test.rb\n...\n\nbin/rails generate scaffold_controller article title:string body:text\n\nCopy\n","\n$ bin/rails generate test_unit:scaffold article\n...\ninvoke  test_unit\ncreate    test/controllers/articles_controller_test.rb\n...\n\nbin/rails generate test_unit:scaffold article\n\nCopy\n","\n# articles_controller_test.rb\nclass ArticlesControllerTest < ActionDispatch::IntegrationTest\n  test \"should get index\" do\n    get articles_url\n    assert_response :success\n  end\nend\n\n# articles_controller_test.rb\nclass ArticlesControllerTest < ActionDispatch::IntegrationTest\n  test \"should get index\" do\n    get articles_url\n    assert_response :success\n  end\nend\n\nCopy\n","\nget article_url(Article.first), headers: { \"HTTP_REFERER\" => \"http://example.com/home\" }\n\nget article_url(Article.first), headers: { \"HTTP_REFERER\" => \"http://example.com/home\" }\n\nCopy\n","\npatch article_url(Article.last), params: { article: { title: \"updated\" } }, xhr: true\n\npatch article_url(Article.last), params: { article: { title: \"updated\" } }, xhr: true\n\nCopy\n","\npost articles_path, params: { article: { title: \"Ahoy!\" } }, as: :json\n\npost articles_path, params: { article: { title: \"Ahoy!\" } }, as: :json\n\nCopy\n","\ntest \"should create article\" do\n  assert_difference(\"Article.count\") do\n    post articles_url, params: { article: { body: \"Rails is awesome!\", title: \"Hello Rails\" } }\n  end\n\n  assert_redirected_to article_path(Article.last)\nend\n\ntest \"should create article\" do\n  assert_difference(\"Article.count\") do\n    post articles_url, params: { article: { body: \"Rails is awesome!\", title: \"Hello Rails\" } }\n  end\n\n  assert_redirected_to article_path(Article.last)\nend\n\nCopy\n","\npost articles_url, params: { article: { body: \"Rails is awesome!\", title: \"Hello Rails\" } }, headers: { Authorization: ActionController::HttpAuthentication::Basic.encode_credentials(\"dhh\", \"secret\") }\n\npost articles_url, params: { article: { body: \"Rails is awesome!\", title: \"Hello Rails\" } }, headers: { Authorization: ActionController::HttpAuthentication::Basic.encode_credentials(\"dhh\", \"secret\") }\n\nCopy\n"],"body":"You should test for things such as:The easiest way to see functional tests in action is to generate a controller using the scaffold generator:This will generate the controller code and tests for an Article resource.\nYou can take a look at the file articles_controller_test.rb in the test/controllers directory.If you already have a controller and just want to generate the test scaffold code for\neach of the seven default actions, you can use the following command:Let's take a look at one such test, test_should_get_index from the file articles_controller_test.rb.In the test_should_get_index test, Rails simulates a request on the action called index, making sure the request was successful\nand also ensuring that the right response body has been generated.The get method kicks off the web request and populates the results into the @response. It can accept up to 6 arguments:All of these keyword arguments are optional.Example: Calling the :show action for the first Article, passing in an HTTP_REFERER header:Another example: Calling the :update action for the last Article, passing in new text for the title in params, as an Ajax request:One more example: Calling the :create action to create a new article, passing in\ntext for the title in params, as JSON request:Let us modify test_should_create_article test in articles_controller_test.rb so that all our test pass:Now you can try running all the tests and they should pass."},{"code":[],"body":"If you're familiar with the HTTP protocol, you'll know that get is a type of request. There are 6 request types supported in Rails functional tests:All of request types have equivalent methods that you can use. In a typical C.R.U.D. application you'll be using get, post, put, and delete more often.","title":"8.2 Available Request Types for Functional Tests","anchor":"#available-request-types-for-functional-tests"},{"title":"8.3 Testing XHR (AJAX) requests","anchor":"#testing-xhr-ajax-requests","code":["\ntest \"ajax request\" do\n  article = articles(:one)\n  get article_url(article), xhr: true\n\n  assert_equal \"hello world\", @response.body\n  assert_equal \"text/javascript\", @response.media_type\nend\n\ntest \"ajax request\" do\n  article = articles(:one)\n  get article_url(article), xhr: true\n\n  assert_equal \"hello world\", @response.body\n  assert_equal \"text/javascript\", @response.media_type\nend\n\nCopy\n"],"body":"To test AJAX requests, you can specify the xhr: true option to get, post,\npatch, put, and delete methods. For example:"},{"code":["\nflash[\"gordon\"]               flash[:gordon]\nsession[\"shmession\"]          session[:shmession]\ncookies[\"are_good_for_u\"]     cookies[:are_good_for_u]\n\nflash[\"gordon\"]               flash[:gordon]\nsession[\"shmession\"]          session[:shmession]\ncookies[\"are_good_for_u\"]     cookies[:are_good_for_u]\n\nCopy\n"],"body":"After a request has been made and processed, you will have 3 Hash objects ready for use:As is the case with normal Hash objects, you can access the values by referencing the keys by string. You can also reference them by symbol name. For example:","title":"8.4 The Three Hashes of the Apocalypse","anchor":"#the-three-hashes-of-the-apocalypse"},{"code":["\nclass ArticlesControllerTest < ActionDispatch::IntegrationTest\n  test \"should get index\" do\n    get articles_url\n\n    assert_equal \"index\", @controller.action_name\n    assert_equal \"application/x-www-form-urlencoded\", @request.media_type\n    assert_match \"Articles\", @response.body\n  end\nend\n\nclass ArticlesControllerTest < ActionDispatch::IntegrationTest\n  test \"should get index\" do\n    get articles_url\n\n    assert_equal \"index\", @controller.action_name\n    assert_equal \"application/x-www-form-urlencoded\", @request.media_type\n    assert_match \"Articles\", @response.body\n  end\nend\n\nCopy\n"],"body":"You also have access to three instance variables in your functional tests, after a request is made:","title":"8.5 Instance Variables Available","anchor":"#instance-variables-available"},{"code":["\n# setting an HTTP Header\nget articles_url, headers: { \"Content-Type\": \"text/plain\" } # simulate the request with custom header\n\n# setting a CGI variable\nget articles_url, headers: { \"HTTP_REFERER\": \"http://example.com/home\" } # simulate the request with custom env variable\n\n# setting an HTTP Header\nget articles_url, headers: { \"Content-Type\": \"text/plain\" } # simulate the request with custom header\n\n# setting a CGI variable\nget articles_url, headers: { \"HTTP_REFERER\": \"http://example.com/home\" } # simulate the request with custom env variable\n\nCopy\n"],"body":"HTTP headers\nand\nCGI variables\ncan be passed as headers:","title":"8.6 Setting Headers and CGI variables","anchor":"#setting-headers-and-cgi-variables"},{"code":["\ntest \"should create article\" do\n  assert_difference(\"Article.count\") do\n    post articles_url, params: { article: { title: \"Some title\" } }\n  end\n\n  assert_redirected_to article_path(Article.last)\n  assert_equal \"Article was successfully created.\", flash[:notice]\nend\n\ntest \"should create article\" do\n  assert_difference(\"Article.count\") do\n    post articles_url, params: { article: { title: \"Some title\" } }\n  end\n\n  assert_redirected_to article_path(Article.last)\n  assert_equal \"Article was successfully created.\", flash[:notice]\nend\n\nCopy\n","\n$ bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article\nRun options: -n test_should_create_article --seed 32266\n\n# Running:\n\nF\n\nFinished in 0.114870s, 8.7055 runs/s, 34.8220 assertions/s.\n\n  1) Failure:\nArticlesControllerTest#test_should_create_article [/test/controllers/articles_controller_test.rb:16]:\n--- expected\n+++ actual\n@@ -1 +1 @@\n-\"Article was successfully created.\"\n+nil\n\n1 runs, 4 assertions, 1 failures, 0 errors, 0 skips\n\nbin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article\n\nCopy\n","\ndef create\n  @article = Article.new(article_params)\n\n  if @article.save\n    flash[:notice] = \"Article was successfully created.\"\n    redirect_to @article\n  else\n    render \"new\"\n  end\nend\n\ndef create\n  @article = Article.new(article_params)\n\n  if @article.save\n    flash[:notice] = \"Article was successfully created.\"\n    redirect_to @article\n  else\n    render \"new\"\n  end\nend\n\nCopy\n","\n$ bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article\nRun options: -n test_should_create_article --seed 18981\n\n# Running:\n\n.\n\nFinished in 0.081972s, 12.1993 runs/s, 48.7972 assertions/s.\n\n1 runs, 4 assertions, 0 failures, 0 errors, 0 skips\n\nbin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article\n\nCopy\n"],"body":"If you remember from earlier, one of the Three Hashes of the Apocalypse was flash.We want to add a flash message to our blog application whenever someone\nsuccessfully creates a new Article.Let's start by adding this assertion to our test_should_create_article test:If we run our test now, we should see a failure:Let's implement the flash message now in our controller. Our :create action should now look like this:Now if we run our tests, we should see it pass:","title":"8.7 Testing flash notices","anchor":"#testing-flash-notices"},{"code":["\ntest \"should show article\" do\n  article = articles(:one)\n  get article_url(article)\n  assert_response :success\nend\n\ntest \"should show article\" do\n  article = articles(:one)\n  get article_url(article)\n  assert_response :success\nend\n\nCopy\n","\ntest \"should destroy article\" do\n  article = articles(:one)\n  assert_difference(\"Article.count\", -1) do\n    delete article_url(article)\n  end\n\n  assert_redirected_to articles_path\nend\n\ntest \"should destroy article\" do\n  article = articles(:one)\n  assert_difference(\"Article.count\", -1) do\n    delete article_url(article)\n  end\n\n  assert_redirected_to articles_path\nend\n\nCopy\n","\ntest \"should update article\" do\n  article = articles(:one)\n\n  patch article_url(article), params: { article: { title: \"updated\" } }\n\n  assert_redirected_to article_path(article)\n  # Reload association to fetch updated data and assert that title is updated.\n  article.reload\n  assert_equal \"updated\", article.title\nend\n\ntest \"should update article\" do\n  article = articles(:one)\n\n  patch article_url(article), params: { article: { title: \"updated\" } }\n\n  assert_redirected_to article_path(article)\n  # Reload association to fetch updated data and assert that title is updated.\n  article.reload\n  assert_equal \"updated\", article.title\nend\n\nCopy\n","\nrequire \"test_helper\"\n\nclass ArticlesControllerTest < ActionDispatch::IntegrationTest\n  # called before every single test\n  setup do\n    @article = articles(:one)\n  end\n\n  # called after every single test\n  teardown do\n    # when controller is using cache it may be a good idea to reset it afterwards\n    Rails.cache.clear\n  end\n\n  test \"should show article\" do\n    # Reuse the @article instance variable from setup\n    get article_url(@article)\n    assert_response :success\n  end\n\n  test \"should destroy article\" do\n    assert_difference(\"Article.count\", -1) do\n      delete article_url(@article)\n    end\n\n    assert_redirected_to articles_path\n  end\n\n  test \"should update article\" do\n    patch article_url(@article), params: { article: { title: \"updated\" } }\n\n    assert_redirected_to article_path(@article)\n    # Reload association to fetch updated data and assert that title is updated.\n    @article.reload\n    assert_equal \"updated\", @article.title\n  end\nend\n\nrequire \"test_helper\"\n\nclass ArticlesControllerTest < ActionDispatch::IntegrationTest\n  # called before every single test\n  setup do\n    @article = articles(:one)\n  end\n\n  # called after every single test\n  teardown do\n    # when controller is using cache it may be a good idea to reset it afterwards\n    Rails.cache.clear\n  end\n\n  test \"should show article\" do\n    # Reuse the @article instance variable from setup\n    get article_url(@article)\n    assert_response :success\n  end\n\n  test \"should destroy article\" do\n    assert_difference(\"Article.count\", -1) do\n      delete article_url(@article)\n    end\n\n    assert_redirected_to articles_path\n  end\n\n  test \"should update article\" do\n    patch article_url(@article), params: { article: { title: \"updated\" } }\n\n    assert_redirected_to article_path(@article)\n    # Reload association to fetch updated data and assert that title is updated.\n    @article.reload\n    assert_equal \"updated\", @article.title\n  end\nend\n\nCopy\n"],"body":"At this point our Articles controller tests the :index as well as :new and :create actions. What about dealing with existing data?Let's write a test for the :show action:Remember from our discussion earlier on fixtures, the articles() method will give us access to our Articles fixtures.How about deleting an existing Article?We can also add a test for updating an existing Article.Notice we're starting to see some duplication in these three tests, they both access the same Article fixture data. We can D.R.Y. this up by using the setup and teardown methods provided by ActiveSupport::Callbacks.Our test should now look something as what follows. Disregard the other tests for now, we're leaving them out for brevity.Similar to other callbacks in Rails, the setup and teardown methods can also be used by passing a block, lambda, or method name as a symbol to call.","title":"8.8 Putting it together","anchor":"#putting-it-together"},{"title":"8.9 Test helpers","anchor":"#test-helpers","code":["\n# test/test_helper.rb\n\nmodule SignInHelper\n  def sign_in_as(user)\n    post sign_in_url(email: user.email, password: user.password)\n  end\nend\n\nclass ActionDispatch::IntegrationTest\n  include SignInHelper\nend\n\n# test/test_helper.rb\n\nmodule SignInHelper\n  def sign_in_as(user)\n    post sign_in_url(email: user.email, password: user.password)\n  end\nend\n\nclass ActionDispatch::IntegrationTest\n  include SignInHelper\nend\n\nCopy\n","\nrequire \"test_helper\"\n\nclass ProfileControllerTest < ActionDispatch::IntegrationTest\n\n  test \"should show profile\" do\n    # helper is now reusable from any controller test case\n    sign_in_as users(:david)\n\n    get profile_url\n    assert_response :success\n  end\nend\n\nrequire \"test_helper\"\n\nclass ProfileControllerTest < ActionDispatch::IntegrationTest\n\n  test \"should show profile\" do\n    # helper is now reusable from any controller test case\n    sign_in_as users(:david)\n\n    get profile_url\n    assert_response :success\n  end\nend\n\nCopy\n"],"body":"To avoid code duplication, you can add your own test helpers.\nSign in helper can be a good example:"},{"code":["\n# test/test_helpers/multiple_assertions.rb\nmodule MultipleAssertions\n  def assert_multiple_of_forty_two(number)\n    assert (number % 42 == 0), 'expected #{number} to be a multiple of 42'\n  end\nend\n\n# test/test_helpers/multiple_assertions.rb\nmodule MultipleAssertions\n  def assert_multiple_of_forty_two(number)\n    assert (number % 42 == 0), 'expected #{number} to be a multiple of 42'\n  end\nend\n\nCopy\n","\nrequire \"test_helper\"\nrequire \"test_helpers/multiple_assertions\"\n\nclass NumberTest < ActiveSupport::TestCase\n  include MultipleAssertions\n\n  test \"420 is a multiple of forty two\" do\n    assert_multiple_of_forty_two 420\n  end\nend\n\nrequire \"test_helper\"\nrequire \"test_helpers/multiple_assertions\"\n\nclass NumberTest < ActiveSupport::TestCase\n  include MultipleAssertions\n\n  test \"420 is a multiple of forty two\" do\n    assert_multiple_of_forty_two 420\n  end\nend\n\nCopy\n","\n# test/test_helper.rb\nrequire \"test_helpers/sign_in_helper\"\n\nclass ActionDispatch::IntegrationTest\n  include SignInHelper\nend\n\n# test/test_helper.rb\nrequire \"test_helpers/sign_in_helper\"\n\nclass ActionDispatch::IntegrationTest\n  include SignInHelper\nend\n\nCopy\n"],"body":"If you find your helpers are cluttering test_helper.rb, you can extract them into separate files.\nOne good place to store them is test/lib or test/test_helpers.These helpers can then be explicitly required as needed and included as neededor they can continue to be included directly into the relevant parent classes","title":"8.9.1 Using Separate Files","anchor":"#using-separate-files"},{"code":["\n# test/test_helper.rb\nDir[Rails.root.join(\"test\", \"test_helpers\", \"**\", \"*.rb\")].each { |file| require file }\n\n# test/test_helper.rb\nDir[Rails.root.join(\"test\", \"test_helpers\", \"**\", \"*.rb\")].each { |file| require file }\n\nCopy\n"],"body":"You may find it convenient to eagerly require helpers in test_helper.rb so your test files have implicit access to them. This can be accomplished using globbing, as followsThis has the downside of increasing the boot-up time, as opposed to manually requiring only the necessary files in your individual tests.","title":"8.9.2 Eagerly Requiring Helpers","anchor":"#eagerly-requiring-helpers"},{"title":"9 Testing Routes","anchor":"#testing-routes","code":[],"body":"Like everything else in your Rails application, you can test your routes. Route tests reside in test/controllers/ or are part of controller tests.For more information on routing assertions available in Rails, see the API documentation for ActionDispatch::Assertions::RoutingAssertions."},{"title":"10 Testing Views","anchor":"#testing-views","code":["\nassert_select \"title\", \"Welcome to Rails Testing Guide\"\n\nassert_select \"title\", \"Welcome to Rails Testing Guide\"\n\nCopy\n","\nassert_select \"ul.navigation\" do\n  assert_select \"li.menu_item\"\nend\n\nassert_select \"ul.navigation\" do\n  assert_select \"li.menu_item\"\nend\n\nCopy\n","\nassert_select \"ol\" do |elements|\n  elements.each do |element|\n    assert_select element, \"li\", 4\n  end\nend\n\nassert_select \"ol\" do\n  assert_select \"li\", 8\nend\n\nassert_select \"ol\" do |elements|\n  elements.each do |element|\n    assert_select element, \"li\", 4\n  end\nend\n\nassert_select \"ol\" do\n  assert_select \"li\", 8\nend\n\nCopy\n"],"body":"Testing the response to your request by asserting the presence of key HTML elements and their content is a common way to test the views of your application. Like route tests, view tests reside in test/controllers/ or are part of controller tests. The assert_select method allows you to query HTML elements of the response by using a simple yet powerful syntax.There are two forms of assert_select:assert_select(selector, [equality], [message]) ensures that the equality condition is met on the selected elements through the selector. The selector may be a CSS selector expression (String) or an expression with substitution values.assert_select(element, selector, [equality], [message]) ensures that the equality condition is met on all the selected elements through the selector starting from the element (instance of Nokogiri::XML::Node or Nokogiri::XML::NodeSet) and its descendants.For example, you could verify the contents on the title element in your response with:You can also use nested assert_select blocks for deeper investigation.In the following example, the inner assert_select for li.menu_item runs\nwithin the collection of elements selected by the outer block:A collection of selected elements may be iterated through so that assert_select may be called separately for each element.For example if the response contains two ordered lists, each with four nested list elements then the following tests will both pass.This assertion is quite powerful. For more advanced usage, refer to its documentation."},{"title":"10.1 Additional View-Based Assertions","anchor":"#additional-view-based-assertions","code":["\nassert_select_email do\n  assert_select \"small\", \"Please click the 'Unsubscribe' link if you want to opt-out.\"\nend\n\nassert_select_email do\n  assert_select \"small\", \"Please click the 'Unsubscribe' link if you want to opt-out.\"\nend\n\nCopy\n"],"body":"There are more assertions that are primarily used in testing views:Here's an example of using assert_select_email:"},{"code":["\nmodule UsersHelper\n  def link_to_user(user)\n    link_to \"#{user.first_name} #{user.last_name}\", user\n  end\nend\n\nmodule UsersHelper\n  def link_to_user(user)\n    link_to \"#{user.first_name} #{user.last_name}\", user\n  end\nend\n\nCopy\n","\nclass UsersHelperTest < ActionView::TestCase\n  test \"should return the user's full name\" do\n    user = users(:david)\n\n    assert_dom_equal %{<a href=\"/user/#{user.id}\">David Heinemeier Hansson</a>}, link_to_user(user)\n  end\nend\n\nclass UsersHelperTest < ActionView::TestCase\n  test \"should return the user's full name\" do\n    user = users(:david)\n\n    assert_dom_equal %{<a href=\"/user/#{user.id}\">David Heinemeier Hansson</a>}, link_to_user(user)\n  end\nend\n\nCopy\n"],"body":"A helper is just a simple module where you can define methods which are\navailable in your views.In order to test helpers, all you need to do is check that the output of the\nhelper method matches what you'd expect. Tests related to the helpers are\nlocated under the test/helpers directory.Given we have the following helper:We can test the output of this method like this:Moreover, since the test class extends from ActionView::TestCase, you have\naccess to Rails' helper methods such as link_to or pluralize.","title":"11 Testing Helpers","anchor":"#testing-helpers"},{"title":"12 Testing Your Mailers","anchor":"#testing-your-mailers","code":[],"body":"Testing mailer classes requires some specific tools to do a thorough job."},{"title":"12.1 Keeping the Postman in Check","anchor":"#keeping-the-postman-in-check","code":[],"body":"Your mailer classes - like every other part of your Rails application - should be tested to ensure that they are working as expected.The goals of testing your mailer classes are to ensure that:"},{"code":[],"body":"There are two aspects of testing your mailer, the unit tests and the functional tests. In the unit tests, you run the mailer in isolation with tightly controlled inputs and compare the output to a known value (a fixture). In the functional tests you don't so much test the minute details produced by the mailer; instead, we test that our controllers and models are using the mailer in the right way. You test to prove that the right email was sent at the right time.","title":"12.1.1 From All Sides","anchor":"#from-all-sides"},{"title":"12.2 Unit Testing","anchor":"#unit-testing","code":[],"body":"In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced."},{"title":"12.2.1 Revenge of the Fixtures","anchor":"#revenge-of-the-fixtures","code":[],"body":"For the purposes of unit testing a mailer, fixtures are used to provide an example of how the output should look. Because these are example emails, and not Active Record data like the other fixtures, they are kept in their own subdirectory apart from the other fixtures. The name of the directory within test/fixtures directly corresponds to the name of the mailer. So, for a mailer named UserMailer, the fixtures should reside in test/fixtures/user_mailer directory.If you generated your mailer, the generator does not create stub fixtures for the mailers actions. You'll have to create those files yourself as described above."},{"title":"12.2.2 The Basic Test Case","anchor":"#the-basic-test-case","code":["\nrequire \"test_helper\"\n\nclass UserMailerTest < ActionMailer::TestCase\n  test \"invite\" do\n    # Create the email and store it for further assertions\n    email = UserMailer.create_invite(\"me@example.com\",\n                                     \"friend@example.com\", Time.now)\n\n    # Send the email, then test that it got queued\n    assert_emails 1 do\n      email.deliver_now\n    end\n\n    # Test the body of the sent email contains what we expect it to\n    assert_equal [\"me@example.com\"], email.from\n    assert_equal [\"friend@example.com\"], email.to\n    assert_equal \"You have been invited by me@example.com\", email.subject\n    assert_equal read_fixture(\"invite\").join, email.body.to_s\n  end\nend\n\nrequire \"test_helper\"\n\nclass UserMailerTest < ActionMailer::TestCase\n  test \"invite\" do\n    # Create the email and store it for further assertions\n    email = UserMailer.create_invite(\"me@example.com\",\n                                     \"friend@example.com\", Time.now)\n\n    # Send the email, then test that it got queued\n    assert_emails 1 do\n      email.deliver_now\n    end\n\n    # Test the body of the sent email contains what we expect it to\n    assert_equal [\"me@example.com\"], email.from\n    assert_equal [\"friend@example.com\"], email.to\n    assert_equal \"You have been invited by me@example.com\", email.subject\n    assert_equal read_fixture(\"invite\").join, email.body.to_s\n  end\nend\n\nCopy\n","\nHi friend@example.com,\n\nYou have been invited.\n\nCheers!\n\nHi friend@example.com,\n\nYou have been invited.\n\nCheers!\n\nCopy\n"],"body":"Here's a unit test to test a mailer named UserMailer whose action invite is used to send an invitation to a friend. It is an adapted version of the base test created by the generator for an invite action.In the test we create the email and store the returned object in the email\nvariable. We then ensure that it was sent (the first assert), then, in the\nsecond batch of assertions, we ensure that the email does indeed contain what we\nexpect. The helper read_fixture is used to read in the content from this file.Here's the content of the invite fixture:This is the right time to understand a little more about writing tests for your\nmailers. The line ActionMailer::Base.delivery_method = :test in\nconfig/environments/test.rb sets the delivery method to test mode so that\nemail will not actually be delivered (useful to avoid spamming your users while\ntesting) but instead it will be appended to an array\n(ActionMailer::Base.deliveries)."},{"title":"12.3 Functional and System Testing","anchor":"#functional-and-system-testing","code":["\n# Integration Test\nrequire \"test_helper\"\n\nclass UsersControllerTest < ActionDispatch::IntegrationTest\n  test \"invite friend\" do\n    # Asserts the difference in the ActionMailer::Base.deliveries\n    assert_emails 1 do\n      post invite_friend_url, params: { email: \"friend@example.com\" }\n    end\n  end\nend\n\n# Integration Test\nrequire \"test_helper\"\n\nclass UsersControllerTest < ActionDispatch::IntegrationTest\n  test \"invite friend\" do\n    # Asserts the difference in the ActionMailer::Base.deliveries\n    assert_emails 1 do\n      post invite_friend_url, params: { email: \"friend@example.com\" }\n    end\n  end\nend\n\nCopy\n","\n# System Test\nrequire \"test_helper\"\n\nclass UsersTest < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :headless_chrome\n\n  test \"inviting a friend\" do\n    visit invite_users_url\n    fill_in \"Email\", with: \"friend@example.com\"\n    assert_emails 1 do\n      click_on \"Invite\"\n    end\n  end\nend\n\n# System Test\nrequire \"test_helper\"\n\nclass UsersTest < ActionDispatch::SystemTestCase\n  driven_by :selenium, using: :headless_chrome\n\n  test \"inviting a friend\" do\n    visit invite_users_url\n    fill_in \"Email\", with: \"friend@example.com\"\n    assert_emails 1 do\n      click_on \"Invite\"\n    end\n  end\nend\n\nCopy\n"],"body":"Unit testing allows us to test the attributes of the email while functional and system testing allows us to test whether user interactions appropriately trigger the email to be delivered. For example, you can check that the invite friend operation is sending an email appropriately:"},{"title":"13 Testing Jobs","anchor":"#testing-jobs","code":[],"body":"Since your custom jobs can be queued at different levels inside your application,\nyou'll need to test both the jobs themselves (their behavior when they get enqueued)\nand that other entities correctly enqueue them."},{"title":"13.1 A Basic Test Case","anchor":"#a-basic-test-case","code":["\nrequire \"test_helper\"\n\nclass BillingJobTest < ActiveJob::TestCase\n  test \"that account is charged\" do\n    BillingJob.perform_now(account, product)\n    assert account.reload.charged_for?(product)\n  end\nend\n\nrequire \"test_helper\"\n\nclass BillingJobTest < ActiveJob::TestCase\n  test \"that account is charged\" do\n    BillingJob.perform_now(account, product)\n    assert account.reload.charged_for?(product)\n  end\nend\n\nCopy\n"],"body":"By default, when you generate a job, an associated test will be generated as well\nunder the test/jobs directory. Here's an example test with a billing job:This test is pretty simple and only asserts that the job got the work done\nas expected.By default, ActiveJob::TestCase will set the queue adapter to :test so that\nyour jobs are performed inline. It will also ensure that all previously performed\nand enqueued jobs are cleared before any test run so you can safely assume that\nno jobs have already been executed in the scope of each test."},{"title":"13.2 Custom Assertions and Testing Jobs inside Other Components","anchor":"#custom-assertions-and-testing-jobs-inside-other-components","code":["\nrequire \"test_helper\"\n\nclass ProductTest < ActiveSupport::TestCase\n  include ActiveJob::TestHelper\n\n  test \"billing job scheduling\" do\n    assert_enqueued_with(job: BillingJob) do\n      product.charge(account)\n    end\n  end\nend\n\nrequire \"test_helper\"\n\nclass ProductTest < ActiveSupport::TestCase\n  include ActiveJob::TestHelper\n\n  test \"billing job scheduling\" do\n    assert_enqueued_with(job: BillingJob) do\n      product.charge(account)\n    end\n  end\nend\n\nCopy\n"],"body":"Active Job ships with a bunch of custom assertions that can be used to lessen the verbosity of tests. For a full list of available assertions, see the API documentation for ActiveJob::TestHelper.It's a good practice to ensure that your jobs correctly get enqueued or performed\nwherever you invoke them (e.g. inside your controllers). This is precisely where\nthe custom assertions provided by Active Job are pretty useful. For instance,\nwithin a model:"},{"code":[],"body":"Since Action Cable is used at different levels inside your application,\nyou'll need to test both the channels, connection classes themselves, and that other\nentities broadcast correct messages.","title":"14 Testing Action Cable","anchor":"#testing-action-cable"},{"title":"14.1 Connection Test Case","anchor":"#connection-test-case","code":["\nclass ApplicationCable::ConnectionTest < ActionCable::Connection::TestCase\n  test \"connects with params\" do\n    # Simulate a connection opening by calling the `connect` method\n    connect params: { user_id: 42 }\n\n    # You can access the Connection object via `connection` in tests\n    assert_equal connection.user_id, \"42\"\n  end\n\n  test \"rejects connection without params\" do\n    # Use `assert_reject_connection` matcher to verify that\n    # connection is rejected\n    assert_reject_connection { connect }\n  end\nend\n\nclass ApplicationCable::ConnectionTest < ActionCable::Connection::TestCase\n  test \"connects with params\" do\n    # Simulate a connection opening by calling the `connect` method\n    connect params: { user_id: 42 }\n\n    # You can access the Connection object via `connection` in tests\n    assert_equal connection.user_id, \"42\"\n  end\n\n  test \"rejects connection without params\" do\n    # Use `assert_reject_connection` matcher to verify that\n    # connection is rejected\n    assert_reject_connection { connect }\n  end\nend\n\nCopy\n","\ntest \"connects with cookies\" do\n  cookies.signed[:user_id] = \"42\"\n\n  connect\n\n  assert_equal connection.user_id, \"42\"\nend\n\ntest \"connects with cookies\" do\n  cookies.signed[:user_id] = \"42\"\n\n  connect\n\n  assert_equal connection.user_id, \"42\"\nend\n\nCopy\n"],"body":"By default, when you generate new Rails application with Action Cable, a test for the base connection class (ApplicationCable::Connection) is generated as well under test/channels/application_cable directory.Connection tests aim to check whether a connection's identifiers get assigned properly\nor that any improper connection requests are rejected. Here is an example:You can also specify request cookies the same way you do in integration tests:See the API documentation for ActionCable::Connection::TestCase for more information."},{"title":"14.2 Channel Test Case","anchor":"#channel-test-case","code":["\nrequire \"test_helper\"\n\nclass ChatChannelTest < ActionCable::Channel::TestCase\n  test \"subscribes and stream for room\" do\n    # Simulate a subscription creation by calling `subscribe`\n    subscribe room: \"15\"\n\n    # You can access the Channel object via `subscription` in tests\n    assert subscription.confirmed?\n    assert_has_stream \"chat_15\"\n  end\nend\n\nrequire \"test_helper\"\n\nclass ChatChannelTest < ActionCable::Channel::TestCase\n  test \"subscribes and stream for room\" do\n    # Simulate a subscription creation by calling `subscribe`\n    subscribe room: \"15\"\n\n    # You can access the Channel object via `subscription` in tests\n    assert subscription.confirmed?\n    assert_has_stream \"chat_15\"\n  end\nend\n\nCopy\n","\nrequire \"test_helper\"\n\nclass WebNotificationsChannelTest < ActionCable::Channel::TestCase\n  test \"subscribes and stream for user\" do\n    stub_connection current_user: users(:john)\n\n    subscribe\n\n    assert_has_stream_for users(:john)\n  end\nend\n\nrequire \"test_helper\"\n\nclass WebNotificationsChannelTest < ActionCable::Channel::TestCase\n  test \"subscribes and stream for user\" do\n    stub_connection current_user: users(:john)\n\n    subscribe\n\n    assert_has_stream_for users(:john)\n  end\nend\n\nCopy\n"],"body":"By default, when you generate a channel, an associated test will be generated as well\nunder the test/channels directory. Here's an example test with a chat channel:This test is pretty simple and only asserts that the channel subscribes the connection to a particular stream.You can also specify the underlying connection identifiers. Here's an example test with a web notifications channel:See the API documentation for ActionCable::Channel::TestCase for more information."},{"title":"14.3 Custom Assertions And Testing Broadcasts Inside Other Components","anchor":"#custom-assertions-and-testing-broadcasts-inside-other-components","code":["\nrequire \"test_helper\"\n\nclass ProductTest < ActionCable::TestCase\n  test \"broadcast status after charge\" do\n    assert_broadcast_on(\"products:#{product.id}\", type: \"charged\") do\n      product.charge(account)\n    end\n  end\nend\n\nrequire \"test_helper\"\n\nclass ProductTest < ActionCable::TestCase\n  test \"broadcast status after charge\" do\n    assert_broadcast_on(\"products:#{product.id}\", type: \"charged\") do\n      product.charge(account)\n    end\n  end\nend\n\nCopy\n","\n# app/jobs/chat_relay_job.rb\nclass ChatRelayJob < ApplicationJob\n  def perform_later(room, message)\n    ChatChannel.broadcast_to room, text: message\n  end\nend\n\n# app/jobs/chat_relay_job.rb\nclass ChatRelayJob < ApplicationJob\n  def perform_later(room, message)\n    ChatChannel.broadcast_to room, text: message\n  end\nend\n\nCopy\n","\n# test/jobs/chat_relay_job_test.rb\nrequire \"test_helper\"\n\nclass ChatRelayJobTest < ActiveJob::TestCase\n  include ActionCable::TestHelper\n\n  test \"broadcast message to room\" do\n    room = rooms(:all)\n\n    assert_broadcast_on(ChatChannel.broadcasting_for(room), text: \"Hi!\") do\n      ChatRelayJob.perform_now(room, \"Hi!\")\n    end\n  end\nend\n\n# test/jobs/chat_relay_job_test.rb\nrequire \"test_helper\"\n\nclass ChatRelayJobTest < ActiveJob::TestCase\n  include ActionCable::TestHelper\n\n  test \"broadcast message to room\" do\n    room = rooms(:all)\n\n    assert_broadcast_on(ChatChannel.broadcasting_for(room), text: \"Hi!\") do\n      ChatRelayJob.perform_now(room, \"Hi!\")\n    end\n  end\nend\n\nCopy\n"],"body":"Action Cable ships with a bunch of custom assertions that can be used to lessen the verbosity of tests. For a full list of available assertions, see the API documentation for ActionCable::TestHelper.It's a good practice to ensure that the correct message has been broadcasted inside other components (e.g. inside your controllers). This is precisely where\nthe custom assertions provided by Action Cable are pretty useful. For instance,\nwithin a model:If you want to test the broadcasting made with Channel.broadcast_to, you should use\nChannel.broadcasting_for to generate an underlying stream name:"},{"code":[],"body":"","title":"15 Additional Testing Resources","anchor":"#additional-testing-resources"},{"title":"15.1 Testing Time-Dependent Code","anchor":"#testing-time-dependent-code","code":["\n# Lets say that a user is eligible for gifting a month after they register.\nuser = User.create(name: \"Gaurish\", activation_date: Date.new(2004, 10, 24))\nassert_not user.applicable_for_gifting?\ntravel_to Date.new(2004, 11, 24) do\n  assert_equal Date.new(2004, 10, 24), user.activation_date # inside the `travel_to` block `Date.current` is mocked\n  assert user.applicable_for_gifting?\nend\nassert_equal Date.new(2004, 10, 24), user.activation_date # The change was visible only inside the `travel_to` block.\n\n# Lets say that a user is eligible for gifting a month after they register.\nuser = User.create(name: \"Gaurish\", activation_date: Date.new(2004, 10, 24))\nassert_not user.applicable_for_gifting?\ntravel_to Date.new(2004, 11, 24) do\n  assert_equal Date.new(2004, 10, 24), user.activation_date # inside the `travel_to` block `Date.current` is mocked\n  assert user.applicable_for_gifting?\nend\nassert_equal Date.new(2004, 10, 24), user.activation_date # The change was visible only inside the `travel_to` block.\n\nCopy\n"],"body":"Rails provides built-in helper methods that enable you to assert that your time-sensitive code works as expected.Here is an example using the travel_to helper:Please see ActiveSupport::Testing::TimeHelpers API Documentation\nfor in-depth information about the available time helpers."}]