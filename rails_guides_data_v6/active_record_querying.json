[{"code":["\nclass Author < ApplicationRecord\n  has_many :books, -> { order(year_published: :desc) }\nend\n\nclass Author < ApplicationRecord\n  has_many :books, -> { order(year_published: :desc) }\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  belongs_to :supplier\n  belongs_to :author\n  has_many :reviews\n  has_and_belongs_to_many :orders, join_table: 'books_orders'\n\n  scope :in_print, -> { where(out_of_print: false) }\n  scope :out_of_print, -> { where(out_of_print: true) }\n  scope :old, -> { where('year_published < ?', 50.years.ago )}\n  scope :out_of_print_and_expensive, -> { out_of_print.where('price > 500') }\n  scope :costs_more_than, ->(amount) { where('price > ?', amount) }\nend\n\nclass Book < ApplicationRecord\n  belongs_to :supplier\n  belongs_to :author\n  has_many :reviews\n  has_and_belongs_to_many :orders, join_table: 'books_orders'\n\n  scope :in_print, -> { where(out_of_print: false) }\n  scope :out_of_print, -> { where(out_of_print: true) }\n  scope :old, -> { where('year_published < ?', 50.years.ago )}\n  scope :out_of_print_and_expensive, -> { out_of_print.where('price > 500') }\n  scope :costs_more_than, ->(amount) { where('price > ?', amount) }\nend\n\nCopy\n","\nclass Customer < ApplicationRecord\n  has_many :orders\n  has_many :reviews\nend\n\nclass Customer < ApplicationRecord\n  has_many :orders\n  has_many :reviews\nend\n\nCopy\n","\nclass Order < ApplicationRecord\n  belongs_to :customer\n  has_and_belongs_to_many :books, join_table: 'books_orders'\n\n  enum status: [:shipped, :being_packed, :complete, :cancelled]\n\n  scope :created_before, ->(time) { where('created_at < ?', time) }\nend\n\nclass Order < ApplicationRecord\n  belongs_to :customer\n  has_and_belongs_to_many :books, join_table: 'books_orders'\n\n  enum status: [:shipped, :being_packed, :complete, :cancelled]\n\n  scope :created_before, ->(time) { where('created_at < ?', time) }\nend\n\nCopy\n","\nclass Review < ApplicationRecord\n  belongs_to :customer\n  belongs_to :book\n\n  enum state: [:not_reviewed, :published, :hidden]\nend\n\nclass Review < ApplicationRecord\n  belongs_to :customer\n  belongs_to :book\n\n  enum state: [:not_reviewed, :published, :hidden]\nend\n\nCopy\n","\nclass Supplier < ApplicationRecord\n  has_many :books\n  has_many :authors, through: :books\nend\n\nclass Supplier < ApplicationRecord\n  has_many :books\n  has_many :authors, through: :books\nend\n\nCopy\n"],"body":"If you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.Active Record will perform queries on the database for you and is compatible with most database systems, including MySQL, MariaDB, PostgreSQL, and SQLite. Regardless of which database system you're using, the Active Record method format will always be the same.Code examples throughout this guide will refer to one or more of the following models:","title":"1 What is the Active Record Query Interface?","anchor":"#what-is-the-active-record-query-interface-questionmark"},{"title":"2 Retrieving Objects from the Database","anchor":"#retrieving-objects-from-the-database","code":[],"body":"To retrieve objects from the database, Active Record provides several finder methods. Each finder method allows you to pass arguments into it to perform certain queries on your database without writing raw SQL.The methods are:Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation.  Methods that find a single entity, such as find and first, return a single instance of the model.The primary operation of Model.find(options) can be summarized as:"},{"code":[],"body":"Active Record provides several different ways of retrieving a single object.","title":"2.1 Retrieving a Single Object","anchor":"#retrieving-a-single-object"},{"title":"2.1.1 find","anchor":"#find","code":["\n# Find the customer with primary key (id) 10.\nirb> customer = Customer.find(10)\n=> #<Customer id: 10, first_name: \"Ryan\">\n\ncustomer = Customer.find(10)\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.id = 10) LIMIT 1\n\nSELECT * FROM customers WHERE (customers.id = 10) LIMIT 1\n\nCopy\n","\n# Find the customers with primary keys 1 and 10.\nirb> customers = Customer.find([1, 10]) # OR Customer.find(1, 10)\n=> [#<Customer id: 1, first_name: \"Lifo\">, #<Customer id: 10, first_name: \"Ryan\">]\n\ncustomers = Customer.find([1, 10]) # OR Customer.find(1, 10)\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.id IN (1,10))\n\nSELECT * FROM customers WHERE (customers.id IN (1,10))\n\nCopy\n"],"body":"Using the find method, you can retrieve the object corresponding to the specified primary key that matches any supplied options. For example:The SQL equivalent of the above is:The find method will raise an ActiveRecord::RecordNotFound exception if no matching record is found.You can also use this method to query for multiple objects. Call the find method and pass in an array of primary keys. The return will be an array containing all of the matching records for the supplied primary keys. For example:The SQL equivalent of the above is:"},{"title":"2.1.2 take","anchor":"#take","code":["\nirb> customer = Customer.take\n=> #<Customer id: 1, first_name: \"Lifo\">\n\ncustomer = Customer.take\n\nCopy\n","\nSELECT * FROM customers LIMIT 1\n\nSELECT * FROM customers LIMIT 1\n\nCopy\n","\nirb> customers = Customer.take(2)\n=> [#<Customer id: 1, first_name: \"Lifo\">, #<Customer id: 220, first_name: \"Sara\">]\n\ncustomers = Customer.take(2)\n\nCopy\n","\nSELECT * FROM customers LIMIT 2\n\nSELECT * FROM customers LIMIT 2\n\nCopy\n"],"body":"The take method retrieves a record without any implicit ordering. For example:The SQL equivalent of the above is:The take method returns nil if no record is found and no exception will be raised.You can pass in a numerical argument to the take method to return up to that number of results. For exampleThe SQL equivalent of the above is:The take! method behaves exactly like take, except that it will raise ActiveRecord::RecordNotFound if no matching record is found."},{"title":"2.1.3 first","anchor":"#first","code":["\nirb> customer = Customer.first\n=> #<Customer id: 1, first_name: \"Lifo\">\n\ncustomer = Customer.first\n\nCopy\n","\nSELECT * FROM customers ORDER BY customers.id ASC LIMIT 1\n\nSELECT * FROM customers ORDER BY customers.id ASC LIMIT 1\n\nCopy\n","\nirb> customers = Customer.first(3)\n=> [#<Customer id: 1, first_name: \"Lifo\">, #<Customer id: 2, first_name: \"Fifo\">, #<Customer id: 3, first_name: \"Filo\">]\n\ncustomers = Customer.first(3)\n\nCopy\n","\nSELECT * FROM customers ORDER BY customers.id ASC LIMIT 3\n\nSELECT * FROM customers ORDER BY customers.id ASC LIMIT 3\n\nCopy\n","\nirb> customer = Customer.order(:first_name).first\n=> #<Customer id: 2, first_name: \"Fifo\">\n\ncustomer = Customer.order(:first_name).first\n\nCopy\n","\nSELECT * FROM customers ORDER BY customers.first_name ASC LIMIT 1\n\nSELECT * FROM customers ORDER BY customers.first_name ASC LIMIT 1\n\nCopy\n"],"body":"The first method finds the first record ordered by primary key (default). For example:The SQL equivalent of the above is:The first method returns nil if no matching record is found and no exception will be raised.If your default scope contains an order method, first will return the first record according to this ordering.You can pass in a numerical argument to the first method to return up to that number of results. For exampleThe SQL equivalent of the above is:On a collection that is ordered using order, first will return the first record ordered by the specified attribute for order.The SQL equivalent of the above is:The first! method behaves exactly like first, except that it will raise ActiveRecord::RecordNotFound if no matching record is found."},{"title":"2.1.4 last","anchor":"#last","code":["\nirb> customer = Customer.last\n=> #<Customer id: 221, first_name: \"Russel\">\n\ncustomer = Customer.last\n\nCopy\n","\nSELECT * FROM customers ORDER BY customers.id DESC LIMIT 1\n\nSELECT * FROM customers ORDER BY customers.id DESC LIMIT 1\n\nCopy\n","\nirb> customers = Customer.last(3)\n=> [#<Customer id: 219, first_name: \"James\">, #<Customer id: 220, first_name: \"Sara\">, #<Customer id: 221, first_name: \"Russel\">]\n\ncustomers = Customer.last(3)\n\nCopy\n","\nSELECT * FROM customers ORDER BY customers.id DESC LIMIT 3\n\nSELECT * FROM customers ORDER BY customers.id DESC LIMIT 3\n\nCopy\n","\nirb> customer = Customer.order(:first_name).last\n=> #<Customer id: 220, first_name: \"Sara\">\n\ncustomer = Customer.order(:first_name).last\n\nCopy\n","\nSELECT * FROM customers ORDER BY customers.first_name DESC LIMIT 1\n\nSELECT * FROM customers ORDER BY customers.first_name DESC LIMIT 1\n\nCopy\n"],"body":"The last method finds the last record ordered by primary key (default). For example:The SQL equivalent of the above is:The last method returns nil if no matching record is found and no exception will be raised.If your default scope contains an order method, last will return the last record according to this ordering.You can pass in a numerical argument to the last method to return up to that number of results. For exampleThe SQL equivalent of the above is:On a collection that is ordered using order, last will return the last record ordered by the specified attribute for order.The SQL equivalent of the above is:The last! method behaves exactly like last, except that it will raise ActiveRecord::RecordNotFound if no matching record is found."},{"title":"2.1.5 find_by","anchor":"#find-by","code":["\nirb> Customer.find_by first_name: 'Lifo'\n=> #<Customer id: 1, first_name: \"Lifo\">\n\nirb> Customer.find_by first_name: 'Jon'\n=> nil\n\nCustomer.find_by first_name: 'Lifo'\nCustomer.find_by first_name: 'Jon'\n\nCopy\n","\nCustomer.where(first_name: 'Lifo').take\n\nCustomer.where(first_name: 'Lifo').take\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.first_name = 'Lifo') LIMIT 1\n\nSELECT * FROM customers WHERE (customers.first_name = 'Lifo') LIMIT 1\n\nCopy\n","\nirb> Customer.find_by! first_name: 'does not exist'\nActiveRecord::RecordNotFound\n\nCustomer.find_by! first_name: 'does not exist'\n\nCopy\n","\nCustomer.where(first_name: 'does not exist').take!\n\nCustomer.where(first_name: 'does not exist').take!\n\nCopy\n"],"body":"The find_by method finds the first record matching some conditions. For example:It is equivalent to writing:The SQL equivalent of the above is:The find_by! method behaves exactly like find_by, except that it will raise ActiveRecord::RecordNotFound if no matching record is found. For example:This is equivalent to writing:"},{"code":["\n# This may consume too much memory if the table is big.\nCustomer.all.each do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\n# This may consume too much memory if the table is big.\nCustomer.all.each do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCopy\n"],"body":"We often need to iterate over a large set of records, as when we send a newsletter to a large set of customers, or when we export data.This may appear straightforward:But this approach becomes increasingly impractical as the table size increases, since Customer.all.each instructs Active Record to fetch the entire table in a single pass, build a model object per row, and then keep the entire array of model objects in memory. Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.Rails provides two methods that address this problem by dividing records into memory-friendly batches for processing. The first method, find_each, retrieves a batch of records and then yields each record to the block individually as a model. The second method, find_in_batches, retrieves a batch of records and then yields the entire batch to the block as an array of models.","title":"2.2 Retrieving Multiple Objects in Batches","anchor":"#retrieving-multiple-objects-in-batches"},{"title":"2.2.1 find_each","anchor":"#find-each","code":["\nCustomer.find_each do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCustomer.find_each do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCopy\n","\nCustomer.where(weekly_subscriber: true).find_each do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCustomer.where(weekly_subscriber: true).find_each do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCopy\n","\nCustomer.find_each(batch_size: 5000) do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCustomer.find_each(batch_size: 5000) do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCopy\n","\nCustomer.find_each(start: 2000) do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCustomer.find_each(start: 2000) do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCopy\n","\nCustomer.find_each(start: 2000, finish: 10000) do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCustomer.find_each(start: 2000, finish: 10000) do |customer|\n  NewsMailer.weekly(customer).deliver_now\nend\n\nCopy\n"],"body":"The find_each method retrieves records in batches and then yields each one to the block. In the following example, find_each retrieves customers in batches of 1000 and yields them to the block one by one:This process is repeated, fetching more batches as needed, until all of the records have been processed.find_each works on model classes, as seen above, and also on relations:as long as they have no ordering, since the method needs to force an order\ninternally to iterate.If an order is present in the receiver the behaviour depends on the flag\nconfig.active_record.error_on_ignored_order. If true, ArgumentError is\nraised, otherwise the order is ignored and a warning issued, which is the\ndefault. This can be overridden with the option :error_on_ignore, explained\nbelow.:batch_sizeThe :batch_size option allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block. For example, to retrieve records in batches of 5000::startBy default, records are fetched in ascending order of the primary key. The :start option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need. This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.For example, to send newsletters only to customers with the primary key starting from 2000::finishSimilar to the :start option, :finish allows you to configure the last ID of the sequence whenever the highest ID is not the one you need.\nThis would be useful, for example, if you wanted to run a batch process using a subset of records based on :start and :finish.For example, to send newsletters only to customers with the primary key starting from 2000 up to 10000:Another example would be if you wanted multiple workers handling the same\nprocessing queue. You could have each worker handle 10000 records by setting the\nappropriate :start and :finish options on each worker.:error_on_ignoreOverrides the application config to specify if an error should be raised when an\norder is present in the relation."},{"title":"2.2.2 find_in_batches","anchor":"#find-in-batches","code":["\n# Give add_customers an array of 1000 customers at a time.\nCustomer.find_in_batches do |customers|\n  export.add_customers(customers)\nend\n\n# Give add_customers an array of 1000 customers at a time.\nCustomer.find_in_batches do |customers|\n  export.add_customers(customers)\nend\n\nCopy\n","\n# Give add_customers an array of 1000 recently active customers at a time.\nCustomer.recently_active.find_in_batches do |customers|\n  export.add_customers(customers)\nend\n\n# Give add_customers an array of 1000 recently active customers at a time.\nCustomer.recently_active.find_in_batches do |customers|\n  export.add_customers(customers)\nend\n\nCopy\n","\nCustomer.find_in_batches(batch_size: 2500) do |customers|\n  export.add_customers(customers)\nend\n\nCustomer.find_in_batches(batch_size: 2500) do |customers|\n  export.add_customers(customers)\nend\n\nCopy\n","\nCustomer.find_in_batches(batch_size: 2500, start: 5000) do |customers|\n  export.add_customers(customers)\nend\n\nCustomer.find_in_batches(batch_size: 2500, start: 5000) do |customers|\n  export.add_customers(customers)\nend\n\nCopy\n","\nCustomer.find_in_batches(finish: 7000) do |customers|\n  export.add_customers(customers)\nend\n\nCustomer.find_in_batches(finish: 7000) do |customers|\n  export.add_customers(customers)\nend\n\nCopy\n"],"body":"The find_in_batches method is similar to find_each, since both retrieve batches of records. The difference is that find_in_batches yields batches to the block as an array of models, instead of individually. The following example will yield to the supplied block an array of up to 1000 customers at a time, with the final block containing any remaining customers:find_in_batches works on model classes, as seen above, and also on relations:as long as they have no ordering, since the method needs to force an order\ninternally to iterate.The find_in_batches method accepts the same options as find_each::batch_sizeJust like for find_each, batch_size establishes how many records will be retrieved in each group. For example, retrieving batches of 2500 records can be specified as::startThe start option allows specifying the beginning ID from where records will be selected. As mentioned before, by default records are fetched in ascending order of the primary key. For example, to retrieve customers starting on ID: 5000 in batches of 2500 records, the following code can be used::finishThe finish option allows specifying the ending ID of the records to be retrieved. The code below shows the case of retrieving customers in batches, up to the customer with ID: 7000::error_on_ignoreThe error_on_ignore option overrides the application config to specify if an error should be raised when a specific order is present in the relation."},{"title":"3 Conditions","anchor":"#conditions","code":[],"body":"The where method allows you to specify conditions to limit the records returned, representing the WHERE-part of the SQL statement. Conditions can either be specified as a string, array, or hash."},{"title":"3.1 Pure String Conditions","anchor":"#pure-string-conditions","code":[],"body":"If you'd like to add conditions to your find, you could just specify them in there, just like Book.where(\"title = 'Introduction to Algorithms'\"). This will find all books where the title field value is 'Introduction to Algorithms'."},{"title":"3.2 Array Conditions","anchor":"#array-conditions","code":["\nBook.where(\"title = ?\", params[:title])\n\nBook.where(\"title = ?\", params[:title])\n\nCopy\n","\nBook.where(\"title = ? AND out_of_print = ?\", params[:title], false)\n\nBook.where(\"title = ? AND out_of_print = ?\", params[:title], false)\n\nCopy\n","\nBook.where(\"title = ?\", params[:title])\n\nBook.where(\"title = ?\", params[:title])\n\nCopy\n","\nBook.where(\"title = #{params[:title]}\")\n\nBook.where(\"title = #{params[:title]}\")\n\nCopy\n"],"body":"Now what if that title could vary, say as an argument from somewhere? The find would then take the form:Active Record will take the first argument as the conditions string and any additional arguments will replace the question marks (?) in it.If you want to specify multiple conditions:In this example, the first question mark will be replaced with the value in params[:title] and the second will be replaced with the SQL representation of false, which depends on the adapter.This code is highly preferable:to this code:because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database as-is. This means that it will be an unescaped variable directly from a user who may have malicious intent. If you do this, you put your entire database at risk because once a user finds out they can exploit your database they can do just about anything to it. Never ever put your arguments directly inside the conditions string."},{"title":"3.2.1 Placeholder Conditions","anchor":"#placeholder-conditions","code":["\nBook.where(\"created_at >= :start_date AND created_at <= :end_date\",\n  {start_date: params[:start_date], end_date: params[:end_date]})\n\nBook.where(\"created_at >= :start_date AND created_at <= :end_date\",\n  {start_date: params[:start_date], end_date: params[:end_date]})\n\nCopy\n"],"body":"Similar to the (?) replacement style of params, you can also specify keys in your conditions string along with a corresponding keys/values hash:This makes for clearer readability if you have a large number of variable conditions."},{"title":"3.3 Hash Conditions","anchor":"#hash-conditions","code":[],"body":"Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want qualified and the values of how you want to qualify them:"},{"title":"3.3.1 Equality Conditions","anchor":"#equality-conditions","code":["\nBook.where(out_of_print: true)\n\nBook.where(out_of_print: true)\n\nCopy\n","\nSELECT * FROM books WHERE (books.out_of_print = 1)\n\nSELECT * FROM books WHERE (books.out_of_print = 1)\n\nCopy\n","\nBook.where('out_of_print' => true)\n\nBook.where('out_of_print' => true)\n\nCopy\n","\nauthor = Author.first\nBook.where(author: author)\nAuthor.joins(:books).where(books: { author: author })\n\nauthor = Author.first\nBook.where(author: author)\nAuthor.joins(:books).where(books: { author: author })\n\nCopy\n"],"body":"This will generate SQL like this:The field name can also be a string:In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well."},{"code":["\nBook.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)\n\nBook.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)\n\nCopy\n","\nSELECT * FROM books WHERE (books.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')\n\nSELECT * FROM books WHERE (books.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')\n\nCopy\n"],"body":"This will find all books created yesterday by using a BETWEEN SQL statement:This demonstrates a shorter syntax for the examples in Array Conditions","title":"3.3.2 Range Conditions","anchor":"#range-conditions"},{"title":"3.3.3 Subset Conditions","anchor":"#subset-conditions","code":["\nCustomer.where(orders_count: [1,3,5])\n\nCustomer.where(orders_count: [1,3,5])\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.orders_count IN (1,3,5))\n\nSELECT * FROM customers WHERE (customers.orders_count IN (1,3,5))\n\nCopy\n"],"body":"If you want to find records using the IN expression you can pass an array to the conditions hash:This code will generate SQL like this:"},{"code":["\nCustomer.where.not(orders_count: [1,3,5])\n\nCustomer.where.not(orders_count: [1,3,5])\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.orders_count NOT IN (1,3,5))\n\nSELECT * FROM customers WHERE (customers.orders_count NOT IN (1,3,5))\n\nCopy\n"],"body":"NOT SQL queries can be built by where.not:In other words, this query can be generated by calling where with no argument, then immediately chain with not passing where conditions.  This will generate SQL like this:","title":"3.4 NOT Conditions","anchor":"#not-conditions"},{"code":["\nCustomer.where(last_name: 'Smith').or(Customer.where(orders_count: [1,3,5]))\n\nCustomer.where(last_name: 'Smith').or(Customer.where(orders_count: [1,3,5]))\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.last_name = 'Smith' OR customers.orders_count IN (1,3,5))\n\nSELECT * FROM customers WHERE (customers.last_name = 'Smith' OR customers.orders_count IN (1,3,5))\n\nCopy\n"],"body":"OR conditions between two relations can be built by calling or on the first\nrelation, and passing the second one as an argument.","title":"3.5 OR Conditions","anchor":"#or-conditions"},{"code":["\nCustomer.order(:created_at)\n# OR\nCustomer.order(\"created_at\")\n\nCustomer.order(:created_at)\n# OR\nCustomer.order(\"created_at\")\n\nCopy\n","\nCustomer.order(created_at: :desc)\n# OR\nCustomer.order(created_at: :asc)\n# OR\nCustomer.order(\"created_at DESC\")\n# OR\nCustomer.order(\"created_at ASC\")\n\nCustomer.order(created_at: :desc)\n# OR\nCustomer.order(created_at: :asc)\n# OR\nCustomer.order(\"created_at DESC\")\n# OR\nCustomer.order(\"created_at ASC\")\n\nCopy\n","\nCustomer.order(orders_count: :asc, created_at: :desc)\n# OR\nCustomer.order(:orders_count, created_at: :desc)\n# OR\nCustomer.order(\"orders_count ASC, created_at DESC\")\n# OR\nCustomer.order(\"orders_count ASC\", \"created_at DESC\")\n\nCustomer.order(orders_count: :asc, created_at: :desc)\n# OR\nCustomer.order(:orders_count, created_at: :desc)\n# OR\nCustomer.order(\"orders_count ASC, created_at DESC\")\n# OR\nCustomer.order(\"orders_count ASC\", \"created_at DESC\")\n\nCopy\n","\nirb> Customer.order(\"orders_count ASC\").order(\"created_at DESC\")\nSELECT * FROM customers ORDER BY orders_count ASC, created_at DESC\n\nCustomer.order(\"orders_count ASC\").order(\"created_at DESC\")\n\nCopy\n"],"body":"To retrieve records from the database in a specific order, you can use the order method.For example, if you're getting a set of records and want to order them in ascending order by the created_at field in your table:You could specify ASC or DESC as well:Or ordering by multiple fields:If you want to call order multiple times, subsequent orders will be appended to the first:","title":"4 Ordering","anchor":"#ordering"},{"title":"5 Selecting Specific Fields","anchor":"#selecting-specific-fields","code":["\nBook.select(:isbn, :out_of_print)\n# OR\nBook.select(\"isbn, out_of_print\")\n\nBook.select(:isbn, :out_of_print)\n# OR\nBook.select(\"isbn, out_of_print\")\n\nCopy\n","\nSELECT isbn, out_of_print FROM books\n\nSELECT isbn, out_of_print FROM books\n\nCopy\n","\nActiveModel::MissingAttributeError: missing attribute: <attribute>\n\nActiveModel::MissingAttributeError: missing attribute: <attribute>\n\nCopy\n","\nCustomer.select(:last_name).distinct\n\nCustomer.select(:last_name).distinct\n\nCopy\n","\nSELECT DISTINCT last_name FROM customers\n\nSELECT DISTINCT last_name FROM customers\n\nCopy\n","\n# Returns unique last_names\nquery = Customer.select(:last_name).distinct\n\n# Returns all last_names, even if there are duplicates\nquery.distinct(false)\n\n# Returns unique last_names\nquery = Customer.select(:last_name).distinct\n\n# Returns all last_names, even if there are duplicates\nquery.distinct(false)\n\nCopy\n"],"body":"By default, Model.find selects all the fields from the result set using select *.To select only a subset of fields from the result set, you can specify the subset via the select method.For example, to select only isbn and out_of_print columns:The SQL query used by this find call will be somewhat like:Be careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field that is not in the initialized record you'll receive:Where <attribute> is the attribute you asked for. The id method will not raise the ActiveRecord::MissingAttributeError, so just be careful when working with associations because they need the id method to function properly.If you would like to only grab a single record per unique value in a certain field, you can use distinct:This would generate SQL like:You can also remove the uniqueness constraint:"},{"code":["\nCustomer.limit(5)\n\nCustomer.limit(5)\n\nCopy\n","\nSELECT * FROM customers LIMIT 5\n\nSELECT * FROM customers LIMIT 5\n\nCopy\n","\nCustomer.limit(5).offset(30)\n\nCustomer.limit(5).offset(30)\n\nCopy\n","\nSELECT * FROM customers LIMIT 5 OFFSET 30\n\nSELECT * FROM customers LIMIT 5 OFFSET 30\n\nCopy\n"],"body":"To apply LIMIT to the SQL fired by the Model.find, you can specify the LIMIT using limit and offset methods on the relation.You can use limit to specify the number of records to be retrieved, and use offset to specify the number of records to skip before starting to return the records. For examplewill return a maximum of 5 customers and because it specifies no offset it will return the first 5 in the table. The SQL it executes looks like this:Adding offset to thatwill return instead a maximum of 5 customers beginning with the 31st. The SQL looks like:","title":"6 Limit and Offset","anchor":"#limit-and-offset"},{"code":["\nOrder.select(\"created_at\").group(\"created_at\")\n\nOrder.select(\"created_at\").group(\"created_at\")\n\nCopy\n","\nSELECT created_at\nFROM orders\nGROUP BY created_at\n\nSELECT created_at\nFROM orders\nGROUP BY created_at\n\nCopy\n"],"body":"To apply a GROUP BY clause to the SQL fired by the finder, you can use the group method.For example, if you want to find a collection of the dates on which orders were created:And this will give you a single Order object for each date where there are orders in the database.The SQL that would be executed would be something like this:","title":"7 Group","anchor":"#group"},{"code":["\nirb> Order.group(:status).count\n=> {\"being_packed\"=>7, \"shipped\"=>12}\n\nOrder.group(:status).count\n\nCopy\n","\nSELECT COUNT (*) AS count_all, status AS status\nFROM orders\nGROUP BY status\n\nSELECT COUNT (*) AS count_all, status AS status\nFROM orders\nGROUP BY status\n\nCopy\n"],"body":"To get the total of grouped items on a single query, call count after the group.The SQL that would be executed would be something like this:","title":"7.1 Total of grouped items","anchor":"#total-of-grouped-items"},{"code":["\nOrder.select(\"created_at, sum(total) as total_price\").\n  group(\"created_at\").having(\"sum(total) > ?\", 200)\n\nOrder.select(\"created_at, sum(total) as total_price\").\n  group(\"created_at\").having(\"sum(total) > ?\", 200)\n\nCopy\n","\nSELECT created_at as ordered_date, sum(total) as total_price\nFROM orders\nGROUP BY created_at\nHAVING sum(total) > 200\n\nSELECT created_at as ordered_date, sum(total) as total_price\nFROM orders\nGROUP BY created_at\nHAVING sum(total) > 200\n\nCopy\n","\nbig_orders = Order.select(\"created_at, sum(total) as total_price\")\n                  .group(\"created_at\")\n                  .having(\"sum(total) > ?\", 200)\n\nbig_orders[0].total_price\n# Returns the total price for the first Order object\n\nbig_orders = Order.select(\"created_at, sum(total) as total_price\")\n                  .group(\"created_at\")\n                  .having(\"sum(total) > ?\", 200)\n\nbig_orders[0].total_price\n# Returns the total price for the first Order object\n\nCopy\n"],"body":"SQL uses the HAVING clause to specify conditions on the GROUP BY fields. You can add the HAVING clause to the SQL fired by the Model.find by adding the having method to the find.For example:The SQL that would be executed would be something like this:This returns the date and total price for each order object, grouped by the day they were ordered and where the total is more than $200.You would access the total_price for each order object returned like this:","title":"8 Having","anchor":"#having"},{"code":[],"body":"","title":"9 Overriding Conditions","anchor":"#overriding-conditions"},{"title":"9.1 unscope","anchor":"#unscope","code":["\nBook.where('id > 100').limit(20).order('id desc').unscope(:order)\n\nBook.where('id > 100').limit(20).order('id desc').unscope(:order)\n\nCopy\n","\nSELECT * FROM books WHERE id > 100 LIMIT 20\n\n-- Original query without `unscope`\nSELECT * FROM books WHERE id > 100 ORDER BY id desc LIMIT 20\n\nSELECT * FROM books WHERE id > 100 LIMIT 20\n\n-- Original query without `unscope`\nSELECT * FROM books WHERE id > 100 ORDER BY id desc LIMIT 20\n\nCopy\n","\nBook.where(id: 10, out_of_print: false).unscope(where: :id)\n# SELECT books.* FROM books WHERE out_of_print = 0\n\nBook.where(id: 10, out_of_print: false).unscope(where: :id)\n# SELECT books.* FROM books WHERE out_of_print = 0\n\nCopy\n","\nBook.order('id desc').merge(Book.unscope(:order))\n# SELECT books.* FROM books\n\nBook.order('id desc').merge(Book.unscope(:order))\n# SELECT books.* FROM books\n\nCopy\n"],"body":"You can specify certain conditions to be removed using the unscope method. For example:The SQL that would be executed:You can also unscope specific where clauses. For example, this will remove id condition from the where clause:A relation which has used unscope will affect any relation into which it is merged:"},{"code":["\nBook.where('id > 10').limit(20).order('id desc').only(:order, :where)\n\nBook.where('id > 10').limit(20).order('id desc').only(:order, :where)\n\nCopy\n","\nSELECT * FROM books WHERE id > 10 ORDER BY id DESC\n\n-- Original query without `only`\nSELECT * FROM books WHERE id > 10 ORDER BY id DESC LIMIT 20\n\nSELECT * FROM books WHERE id > 10 ORDER BY id DESC\n\n-- Original query without `only`\nSELECT * FROM books WHERE id > 10 ORDER BY id DESC LIMIT 20\n\nCopy\n"],"body":"You can also override conditions using the only method. For example:The SQL that would be executed:","title":"9.2 only","anchor":"#only"},{"code":["\nBook.select(:title, :isbn).reselect(:created_at)\n\nBook.select(:title, :isbn).reselect(:created_at)\n\nCopy\n","\nSELECT `books`.`created_at` FROM `books`\n\nSELECT `books`.`created_at` FROM `books`\n\nCopy\n","\nBook.select(:title, :isbn).select(:created_at)\n\nBook.select(:title, :isbn).select(:created_at)\n\nCopy\n","\nSELECT `books`.`title`, `books`.`isbn`, `books`.`created_at` FROM `books`\n\nSELECT `books`.`title`, `books`.`isbn`, `books`.`created_at` FROM `books`\n\nCopy\n"],"body":"The reselect method overrides an existing select statement. For example:The SQL that would be executed:Compare this to the case where the reselect clause is not used:the SQL executed would be:","title":"9.3 reselect","anchor":"#reselect"},{"code":["\nclass Author < ApplicationRecord\n  has_many :books, -> { order(year_published: :desc) }\nend\n\nclass Author < ApplicationRecord\n  has_many :books, -> { order(year_published: :desc) }\nend\n\nCopy\n","\nAuthor.find(10).books\n\nAuthor.find(10).books\n\nCopy\n","\nSELECT * FROM authors WHERE id = 10 LIMIT 1\nSELECT * FROM books WHERE author_id = 10 ORDER BY year_published DESC\n\nSELECT * FROM authors WHERE id = 10 LIMIT 1\nSELECT * FROM books WHERE author_id = 10 ORDER BY year_published DESC\n\nCopy\n","\nAuthor.find(10).books.reorder('year_published ASC')\n\nAuthor.find(10).books.reorder('year_published ASC')\n\nCopy\n","\nSELECT * FROM authors WHERE id = 10 LIMIT 1\nSELECT * FROM books WHERE author_id = 10 ORDER BY year_published ASC\n\nSELECT * FROM authors WHERE id = 10 LIMIT 1\nSELECT * FROM books WHERE author_id = 10 ORDER BY year_published ASC\n\nCopy\n"],"body":"The reorder method overrides the default scope order. For example if the class definition includes this:And you execute this:The SQL that would be executed:You can using the reorder clause to specify a different way to order the books:The SQL that would be executed:","title":"9.4 reorder","anchor":"#reorder"},{"code":["\nCustomer.where(\"orders_count > 10\").order(:last_name).reverse_order\n\nCustomer.where(\"orders_count > 10\").order(:last_name).reverse_order\n\nCopy\n","\nSELECT * FROM customers WHERE orders_count > 10 ORDER BY last_name DESC\n\nSELECT * FROM customers WHERE orders_count > 10 ORDER BY last_name DESC\n\nCopy\n","\nCustomer.where(\"orders_count > 10\").reverse_order\n\nCustomer.where(\"orders_count > 10\").reverse_order\n\nCopy\n","\nSELECT * FROM customers WHERE orders_count > 10 ORDER BY customers.id DESC\n\nSELECT * FROM customers WHERE orders_count > 10 ORDER BY customers.id DESC\n\nCopy\n"],"body":"The reverse_order method reverses the ordering clause if specified.The SQL that would be executed:If no ordering clause is specified in the query, the reverse_order orders by the primary key in reverse order.The SQL that would be executed:The reverse_order method accepts no arguments.","title":"9.5 reverse_order","anchor":"#reverse-order"},{"title":"9.6 rewhere","anchor":"#rewhere","code":["\nBook.where(out_of_print: true).rewhere(out_of_print: false)\n\nBook.where(out_of_print: true).rewhere(out_of_print: false)\n\nCopy\n","\nSELECT * FROM books WHERE `out_of_print` = 0\n\nSELECT * FROM books WHERE `out_of_print` = 0\n\nCopy\n","\nBook.where(out_of_print: true).where(out_of_print: false)\n\nBook.where(out_of_print: true).where(out_of_print: false)\n\nCopy\n","\nSELECT * FROM books WHERE `out_of_print` = 1 AND `out_of_print` = 0\n\nSELECT * FROM books WHERE `out_of_print` = 1 AND `out_of_print` = 0\n\nCopy\n"],"body":"The rewhere method overrides an existing, named where condition. For example:The SQL that would be executed:If the rewhere clause is not used, the where clauses are ANDed together:the SQL executed would be:"},{"code":["\nOrder.none # returns an empty Relation and fires no queries.\n\nOrder.none # returns an empty Relation and fires no queries.\n\nCopy\n","\n# The highlighted_reviews method below is expected to always return a Relation.\nBook.first.highlighted_reviews.average(:rating)\n# => Returns average rating of a book\n\nclass Book\n  # Returns reviews if there are at least 5,\n  # else consider this as non-reviewed book\n  def highlighted_reviews\n    if reviews.count > 5\n      reviews\n    else\n      Review.none # Does not meet minimum threshold yet\n    end\n  end\nend\n\n# The highlighted_reviews method below is expected to always return a Relation.\nBook.first.highlighted_reviews.average(:rating)\n# => Returns average rating of a book\n\nclass Book\n  # Returns reviews if there are at least 5,\n  # else consider this as non-reviewed book\n  def highlighted_reviews\n    if reviews.count > 5\n      reviews\n    else\n      Review.none # Does not meet minimum threshold yet\n    end\n  end\nend\n\nCopy\n"],"body":"The none method returns a chainable relation with no records. Any subsequent conditions chained to the returned relation will continue generating empty relations. This is useful in scenarios where you need a chainable response to a method or a scope that could return zero results.","title":"10 Null Relation","anchor":"#null-relation"},{"code":["\ncustomer = Customer.readonly.first\ncustomer.visits += 1\ncustomer.save\n\ncustomer = Customer.readonly.first\ncustomer.visits += 1\ncustomer.save\n\nCopy\n"],"body":"Active Record provides the readonly method on a relation to explicitly disallow modification of any of the returned objects. Any attempt to alter a readonly record will not succeed, raising an ActiveRecord::ReadOnlyRecord exception.As customer is explicitly set to be a readonly object, the above code will raise an ActiveRecord::ReadOnlyRecord exception when calling customer.save with an updated value of visits.","title":"11 Readonly Objects","anchor":"#readonly-objects"},{"title":"12 Locking Records for Update","anchor":"#locking-records-for-update","code":[],"body":"Locking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.Active Record provides two locking mechanisms:"},{"code":["\nc1 = Customer.find(1)\nc2 = Customer.find(1)\n\nc1.first_name = \"Sandra\"\nc1.save\n\nc2.first_name = \"Michael\"\nc2.save # Raises an ActiveRecord::StaleObjectError\n\nc1 = Customer.find(1)\nc2 = Customer.find(1)\n\nc1.first_name = \"Sandra\"\nc1.save\n\nc2.first_name = \"Michael\"\nc2.save # Raises an ActiveRecord::StaleObjectError\n\nCopy\n","\nclass Customer < ApplicationRecord\n  self.locking_column = :lock_customer_column\nend\n\nclass Customer < ApplicationRecord\n  self.locking_column = :lock_customer_column\nend\n\nCopy\n"],"body":"Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. It does this by checking whether another process has made changes to a record since it was opened. An ActiveRecord::StaleObjectError exception is thrown if that has occurred and the update is ignored.Optimistic locking columnIn order to use optimistic locking, the table needs to have a column called lock_version of type integer. Each time the record is updated, Active Record increments the lock_version column. If an update request is made with a lower value in the lock_version field than is currently in the lock_version column in the database, the update request will fail with an ActiveRecord::StaleObjectError.For example:You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.This behavior can be turned off by setting ActiveRecord::Base.lock_optimistically = false.To override the name of the lock_version column, ActiveRecord::Base provides a class attribute called locking_column:","title":"12.1 Optimistic Locking","anchor":"#optimistic-locking"},{"code":["\nBook.transaction do\n  book = Book.lock.first\n  book.title = 'Algorithms, second edition'\n  book.save!\nend\n\nBook.transaction do\n  book = Book.lock.first\n  book.title = 'Algorithms, second edition'\n  book.save!\nend\n\nCopy\n","\nSQL (0.2ms)   BEGIN\nBook Load (0.3ms)   SELECT * FROM `books` LIMIT 1 FOR UPDATE\nBook Update (0.4ms)   UPDATE `books` SET `updated_at` = '2009-02-07 18:05:56', `title` = 'Algorithms, second edition' WHERE `id` = 1\nSQL (0.8ms)   COMMIT\n\nSQL (0.2ms)   BEGIN\nBook Load (0.3ms)   SELECT * FROM `books` LIMIT 1 FOR UPDATE\nBook Update (0.4ms)   UPDATE `books` SET `updated_at` = '2009-02-07 18:05:56', `title` = 'Algorithms, second edition' WHERE `id` = 1\nSQL (0.8ms)   COMMIT\n\nCopy\n","\nBook.transaction do\n  book = Book.lock(\"LOCK IN SHARE MODE\").find(1)\n  book.increment!(:views)\nend\n\nBook.transaction do\n  book = Book.lock(\"LOCK IN SHARE MODE\").find(1)\n  book.increment!(:views)\nend\n\nCopy\n","\nbook = Book.first\nbook.with_lock do\n  # This block is called within a transaction,\n  # book is already locked.\n  book.increment!(:views)\nend\n\nbook = Book.first\nbook.with_lock do\n  # This block is called within a transaction,\n  # book is already locked.\n  book.increment!(:views)\nend\n\nCopy\n"],"body":"Pessimistic locking uses a locking mechanism provided by the underlying database. Using lock when building a relation obtains an exclusive lock on the selected rows. Relations using lock are usually wrapped inside a transaction for preventing deadlock conditions.For example:The above session produces the following SQL for a MySQL backend:You can also pass raw SQL to the lock method for allowing different types of locks. For example, MySQL has an expression called LOCK IN SHARE MODE where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:If you already have an instance of your model, you can start a transaction and acquire the lock in one go using the following code:","title":"12.2 Pessimistic Locking","anchor":"#pessimistic-locking"},{"code":[],"body":"Active Record provides two finder methods for specifying JOIN clauses on the\nresulting SQL: joins and left_outer_joins.\nWhile joins should be used for INNER JOIN or custom queries,\nleft_outer_joins is used for queries using LEFT OUTER JOIN.","title":"13 Joining Tables","anchor":"#joining-tables"},{"title":"13.1 joins","anchor":"#joins","code":[],"body":"There are multiple ways to use the joins method."},{"title":"13.1.1 Using a String SQL Fragment","anchor":"#using-a-string-sql-fragment","code":["\nAuthor.joins(\"INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE\")\n\nAuthor.joins(\"INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE\")\n\nCopy\n","\nSELECT authors.* FROM authors INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE\n\nSELECT authors.* FROM authors INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE\n\nCopy\n"],"body":"You can just supply the raw SQL specifying the JOIN clause to joins:This will result in the following SQL:"},{"code":["\nBook.joins(:reviews)\n\nBook.joins(:reviews)\n\nCopy\n","\nSELECT books.* FROM books\n  INNER JOIN reviews ON reviews.book_id = books.id\n\nSELECT books.* FROM books\n  INNER JOIN reviews ON reviews.book_id = books.id\n\nCopy\n"],"body":"Active Record lets you use the names of the associations defined on the model as a shortcut for specifying JOIN clauses for those associations when using the joins method.All of the following will produce the expected join queries using INNER JOIN:This produces:Or, in English: \"return a Book object for all books with reviews\". Note that you will see duplicate books if a book has more than one review.  If you want unique books, you can use Book.joins(:reviews).distinct.","title":"13.1.2 Using Array/Hash of Named Associations","anchor":"#using-array-hash-of-named-associations"},{"title":"13.1.3 Joining Multiple Associations","anchor":"#joining-multiple-associations","code":["\nBook.joins(:author, :reviews)\n\nBook.joins(:author, :reviews)\n\nCopy\n","\nSELECT books.* FROM books\n  INNER JOIN authors ON authors.id = books.author_id\n  INNER JOIN reviews ON reviews.book_id = books.id\n\nSELECT books.* FROM books\n  INNER JOIN authors ON authors.id = books.author_id\n  INNER JOIN reviews ON reviews.book_id = books.id\n\nCopy\n","\nBook.joins(reviews: :customer)\n\nBook.joins(reviews: :customer)\n\nCopy\n","\nSELECT books.* FROM books\n  INNER JOIN reviews ON reviews.book_id = books.id\n  INNER JOIN customers ON customers.id = reviews.customer_id\n\nSELECT books.* FROM books\n  INNER JOIN reviews ON reviews.book_id = books.id\n  INNER JOIN customers ON customers.id = reviews.customer_id\n\nCopy\n","\nAuthor.joins(books: [{reviews: { customer: :orders} }, :supplier] )\n\nAuthor.joins(books: [{reviews: { customer: :orders} }, :supplier] )\n\nCopy\n","\nSELECT * FROM authors\n  INNER JOIN books ON books.author_id = authors.id\n  INNER JOIN reviews ON reviews.book_id = books.id\n  INNER JOIN customers ON customers.id = reviews.customer_id\n  INNER JOIN orders ON orders.customer_id = customers.id\nINNER JOIN suppliers ON suppliers.id = books.supplier_id\n\nSELECT * FROM authors\n  INNER JOIN books ON books.author_id = authors.id\n  INNER JOIN reviews ON reviews.book_id = books.id\n  INNER JOIN customers ON customers.id = reviews.customer_id\n  INNER JOIN orders ON orders.customer_id = customers.id\nINNER JOIN suppliers ON suppliers.id = books.supplier_id\n\nCopy\n"],"body":"This produces:Or, in English: \"return all books with their author that have at least one review\". Note again that books with multiple reviews will show up multiple times.This produces:Or, in English: \"return all books that have a review by a customer.\"This produces:Or, in English: \"return all authors that have books with reviews and have been ordered by a customer, and the suppliers for those books.\""},{"title":"13.1.4 Specifying Conditions on the Joined Tables","anchor":"#specifying-conditions-on-the-joined-tables","code":["\ntime_range = (Time.now.midnight - 1.day)..Time.now.midnight\nCustomer.joins(:orders).where('orders.created_at' => time_range).distinct\n\ntime_range = (Time.now.midnight - 1.day)..Time.now.midnight\nCustomer.joins(:orders).where('orders.created_at' => time_range).distinct\n\nCopy\n","\ntime_range = (Time.now.midnight - 1.day)..Time.now.midnight\nCustomer.joins(:orders).where(orders: { created_at: time_range }).distinct\n\ntime_range = (Time.now.midnight - 1.day)..Time.now.midnight\nCustomer.joins(:orders).where(orders: { created_at: time_range }).distinct\n\nCopy\n","\nclass Order < ApplicationRecord\n  belongs_to :customer\n\n  scope :created_in_time_range, ->(time_range) {\n    where(created_at: time_range)\n  }\nend\n\nclass Order < ApplicationRecord\n  belongs_to :customer\n\n  scope :created_in_time_range, ->(time_range) {\n    where(created_at: time_range)\n  }\nend\n\nCopy\n","\ntime_range = (Time.now.midnight - 1.day)..Time.now.midnight\nCustomer.joins(:orders).merge(Order.created_in_time_range(time_range)).distinct\n\ntime_range = (Time.now.midnight - 1.day)..Time.now.midnight\nCustomer.joins(:orders).merge(Order.created_in_time_range(time_range)).distinct\n\nCopy\n"],"body":"You can specify conditions on the joined tables using the regular Array and String conditions. Hash conditions provide a special syntax for specifying conditions for the joined tables:This will find all customers who have orders that were created yesterday, using a BETWEEN SQL expression to compare created_at.An alternative and cleaner syntax is to nest the hash conditions:For more advanced conditions or to reuse an existing named scope, Relation#merge may be used. First, let's add a new named scope to the Order model:Now we can use Relation#merge to merge in the created_in_time_range scope:This will find all customers who have orders that were created yesterday, again using a BETWEEN SQL expression."},{"title":"13.2 left_outer_joins","anchor":"#left-outer-joins","code":["\nCustomer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')\n\nCustomer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')\n\nCopy\n","\nSELECT DISTINCT customers.*, COUNT(reviews.*) AS reviews_count FROM customers\nLEFT OUTER JOIN reviews ON reviews.customer_id = customers.id GROUP BY customers.id\n\nSELECT DISTINCT customers.*, COUNT(reviews.*) AS reviews_count FROM customers\nLEFT OUTER JOIN reviews ON reviews.customer_id = customers.id GROUP BY customers.id\n\nCopy\n"],"body":"If you want to select a set of records whether or not they have associated\nrecords you can use the left_outer_joins method.Which produces:Which means: \"return all customers with their count of reviews, whether or not they\nhave any reviews at all\""},{"title":"14 Eager Loading Associations","anchor":"#eager-loading-associations","code":["\nbooks = Book.limit(10)\n\nbooks.each do |book|\n  puts book.author.last_name\nend\n\nbooks = Book.limit(10)\n\nbooks.each do |book|\n  puts book.author.last_name\nend\n\nCopy\n","\nbooks = Book.includes(:author).limit(10)\n\nbooks.each do |book|\n  puts book.author.last_name\nend\n\nbooks = Book.includes(:author).limit(10)\n\nbooks.each do |book|\n  puts book.author.last_name\nend\n\nCopy\n","\nSELECT * FROM books LIMIT 10\nSELECT authors.* FROM authors\n  WHERE (authors.id IN (1,2,3,4,5,6,7,8,9,10))\n\nSELECT * FROM books LIMIT 10\nSELECT authors.* FROM authors\n  WHERE (authors.id IN (1,2,3,4,5,6,7,8,9,10))\n\nCopy\n"],"body":"Eager loading is the mechanism for loading the associated records of the objects returned by Model.find using as few queries as possible.N + 1 queries problemConsider the following code, which finds 10 books and prints their authors' last_name:This code looks fine at the first sight. But the problem lies within the total number of queries executed. The above code executes 1 (to find 10 books) + 10 (one per each book to load the author) = 11 queries in total.Solution to N + 1 queries problemActive Record lets you specify in advance all the associations that are going to be loaded. This is possible by specifying the includes method of the Model.find call. With includes, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.Revisiting the above case, we could rewrite Book.limit(10) to eager load authors:The above code will execute just 2 queries, as opposed to 11 queries in the previous case:"},{"code":[],"body":"Active Record lets you eager load any number of associations with a single Model.find call by using an array, hash, or a nested hash of array/hash with the includes method.","title":"14.1 Eager Loading Multiple Associations","anchor":"#eager-loading-multiple-associations"},{"title":"14.1.1 Array of Multiple Associations","anchor":"#array-of-multiple-associations","code":["\nCustomer.includes(:orders, :reviews)\n\nCustomer.includes(:orders, :reviews)\n\nCopy\n"],"body":"This loads all the customers and the associated orders and reviews for each."},{"title":"14.1.2 Nested Associations Hash","anchor":"#nested-associations-hash","code":["\nCustomer.includes(orders: {books: [:supplier, :author]}).find(1)\n\nCustomer.includes(orders: {books: [:supplier, :author]}).find(1)\n\nCopy\n"],"body":"This will find the customer with id 1 and eager load all of the associated orders for it, the books for all of the orders, and the author and supplier for each of the books."},{"title":"14.2 Specifying Conditions on Eager Loaded Associations","anchor":"#specifying-conditions-on-eager-loaded-associations","code":["\nAuthor.includes(:books).where(books: { out_of_print: true })\n\nAuthor.includes(:books).where(books: { out_of_print: true })\n\nCopy\n","\n  SELECT authors.id AS t0_r0, ... books.updated_at AS t1_r5 FROM authors LEFT OUTER JOIN \"books\" ON \"books\".\"author_id\" = \"authors\".\"id\" WHERE (books.out_of_print = 1)\n\n  SELECT authors.id AS t0_r0, ... books.updated_at AS t1_r5 FROM authors LEFT OUTER JOIN \"books\" ON \"books\".\"author_id\" = \"authors\".\"id\" WHERE (books.out_of_print = 1)\n\nCopy\n","\nAuthor.includes(:books).where(\"books.out_of_print = true\").references(:books)\n\nAuthor.includes(:books).where(\"books.out_of_print = true\").references(:books)\n\nCopy\n"],"body":"Even though Active Record lets you specify conditions on the eager loaded associations just like joins, the recommended way is to use joins instead.However if you must do this, you may use where as you would normally.This would generate a query which contains a LEFT OUTER JOIN whereas the\njoins method would generate one using the INNER JOIN function instead.If there was no where condition, this would generate the normal set of two queries.If, in the case of this includes query, there were no books for any\nauthors, all the authors would still be loaded. By using joins (an INNER\nJOIN), the join conditions must match, otherwise no records will be\nreturned."},{"title":"15 Scopes","anchor":"#scopes","code":["\nclass Book < ApplicationRecord\n  scope :out_of_print, -> { where(out_of_print: true) }\nend\n\nclass Book < ApplicationRecord\n  scope :out_of_print, -> { where(out_of_print: true) }\nend\n\nCopy\n","\nirb> Book.out_of_print\n=> #<ActiveRecord::Relation> # all out of print books\n\nBook.out_of_print\n\nCopy\n","\nirb> author = Author.first\nirb> author.books.out_of_print\n=> #<ActiveRecord::Relation> # all out of print books by `author`\n\nauthor = Author.first\nauthor.books.out_of_print\n\nCopy\n","\nclass Book < ApplicationRecord\n  scope :out_of_print, -> { where(out_of_print: true) }\n  scope :out_of_print_and_expensive, -> { out_of_print.where(\"price > 500\") }\nend\n\nclass Book < ApplicationRecord\n  scope :out_of_print, -> { where(out_of_print: true) }\n  scope :out_of_print_and_expensive, -> { out_of_print.where(\"price > 500\") }\nend\n\nCopy\n"],"body":"Scoping allows you to specify commonly-used queries which can be referenced as method calls on the association objects or models. With these scopes, you can use every method previously covered such as where, joins and includes. All scope bodies should return an ActiveRecord::Relation or nil to allow for further methods (such as other scopes) to be called on it.To define a simple scope, we use the scope method inside the class, passing the query that we'd like to run when this scope is called:To call this out_of_print scope we can call it on either the class:Or on an association consisting of Book objects:Scopes are also chainable within scopes:"},{"code":["\nclass Book < ApplicationRecord\n  scope :costs_more_than, ->(amount) { where(\"price > ?\", amount) }\nend\n\nclass Book < ApplicationRecord\n  scope :costs_more_than, ->(amount) { where(\"price > ?\", amount) }\nend\n\nCopy\n","\nirb> Book.costs_more_than(100.10)\n\nBook.costs_more_than(100.10)\n\nCopy\n","\nclass Book < ApplicationRecord\n  def self.costs_more_than(amount)\n    where(\"price > ?\", amount)\n  end\nend\n\nclass Book < ApplicationRecord\n  def self.costs_more_than(amount)\n    where(\"price > ?\", amount)\n  end\nend\n\nCopy\n","\nirb> author.books.costs_more_than(100.10)\n\nauthor.books.costs_more_than(100.10)\n\nCopy\n"],"body":"Your scope can take arguments:Call the scope as if it were a class method:However, this is just duplicating the functionality that would be provided to you by a class method.These methods will still be accessible on the association objects:","title":"15.1 Passing in arguments","anchor":"#passing-in-arguments"},{"code":["\nclass Order < ApplicationRecord\n  scope :created_before, ->(time) { where(\"created_at < ?\", time) if time.present? }\nend\n\nclass Order < ApplicationRecord\n  scope :created_before, ->(time) { where(\"created_at < ?\", time) if time.present? }\nend\n\nCopy\n","\nclass Order < ApplicationRecord\n  def self.created_before(time)\n    where(\"created_at < ?\", time) if time.present?\n  end\nend\n\nclass Order < ApplicationRecord\n  def self.created_before(time)\n    where(\"created_at < ?\", time) if time.present?\n  end\nend\n\nCopy\n"],"body":"Your scope can utilize conditionals:Like the other examples, this will behave similarly to a class method.However, there is one important caveat: A scope will always return an ActiveRecord::Relation object, even if the conditional evaluates to false, whereas a class method, will return nil. This can cause NoMethodError when chaining class methods with conditionals, if any of the conditionals return false.","title":"15.2 Using conditionals","anchor":"#using-conditionals"},{"title":"15.3 Applying a default scope","anchor":"#applying-a-default-scope","code":["\nclass Book < ApplicationRecord\n  default_scope { where(out_of_print: false) }\nend\n\nclass Book < ApplicationRecord\n  default_scope { where(out_of_print: false) }\nend\n\nCopy\n","\nSELECT * FROM books WHERE (out_of_print = false)\n\nSELECT * FROM books WHERE (out_of_print = false)\n\nCopy\n","\nclass Book < ApplicationRecord\n  def self.default_scope\n    # Should return an ActiveRecord::Relation.\n  end\nend\n\nclass Book < ApplicationRecord\n  def self.default_scope\n    # Should return an ActiveRecord::Relation.\n  end\nend\n\nCopy\n","\nclass Book < ApplicationRecord\n  default_scope { where(out_of_print: false) }\nend\n\nclass Book < ApplicationRecord\n  default_scope { where(out_of_print: false) }\nend\n\nCopy\n","\nirb> Book.new\n=> #<Book id: nil, out_of_print: false>\nirb> Book.unscoped.new\n=> #<Book id: nil, out_of_print: nil>\n\nBook.new\nBook.unscoped.new\n\nCopy\n","\nclass Book < ApplicationRecord\n  default_scope { where(\"out_of_print = ?\", false) }\nend\n\nclass Book < ApplicationRecord\n  default_scope { where(\"out_of_print = ?\", false) }\nend\n\nCopy\n","\nirb> Book.new\n=> #<Book id: nil, out_of_print: nil>\n\nBook.new\n\nCopy\n"],"body":"If we wish for a scope to be applied across all queries to the model we can use the\ndefault_scope method within the model itself.When queries are executed on this model, the SQL query will now look something like\nthis:If you need to do more complex things with a default scope, you can alternatively\ndefine it as a class method:Be aware that, when given in the Array format, default_scope query arguments\ncannot be converted to a Hash for default attribute assignment. E.g.:"},{"code":["\nclass Book < ApplicationRecord\n  scope :in_print, -> { where(out_of_print: false) }\n  scope :out_of_print, -> { where(out_of_print: true) }\n\n  scope :recent, -> { where('year_published >= ?', Date.current.year - 50 )}\n  scope :old, -> { where('year_published < ?', Date.current.year - 50 )}\nend\n\nclass Book < ApplicationRecord\n  scope :in_print, -> { where(out_of_print: false) }\n  scope :out_of_print, -> { where(out_of_print: true) }\n\n  scope :recent, -> { where('year_published >= ?', Date.current.year - 50 )}\n  scope :old, -> { where('year_published < ?', Date.current.year - 50 )}\nend\n\nCopy\n","\nirb> Book.out_of_print.old\nSELECT books.* FROM books WHERE books.out_of_print = 'true' AND books.year_published < 1969\n\nBook.out_of_print.old\n\nCopy\n","\nirb> Book.in_print.where('price < 100')\nSELECT books.* FROM books WHERE books.out_of_print = 'false' AND books.price < 100\n\nBook.in_print.where('price < 100')\n\nCopy\n","\nirb> Book.in_print.merge(Book.out_of_print)\nSELECT books.* FROM books WHERE books.out_of_print = true\n\nBook.in_print.merge(Book.out_of_print)\n\nCopy\n","\nclass Book < ApplicationRecord\n  default_scope { where('year_published >= ?', Date.current.year - 50 )}\n\n  scope :in_print, -> { where(out_of_print: false) }\n  scope :out_of_print, -> { where(out_of_print: true) }\nend\n\nclass Book < ApplicationRecord\n  default_scope { where('year_published >= ?', Date.current.year - 50 )}\n\n  scope :in_print, -> { where(out_of_print: false) }\n  scope :out_of_print, -> { where(out_of_print: true) }\nend\n\nCopy\n","\nirb> Book.all\nSELECT books.* FROM books WHERE (year_published >= 1969)\n\nirb> Book.in_print\nSELECT books.* FROM books WHERE (year_published >= 1969) AND books.out_of_print = true\n\nirb> Book.where('price > 50')\nSELECT books.* FROM books WHERE (year_published >= 1969) AND (price > 50)\n\nBook.all\nBook.in_print\nBook.where('price > 50')\n\nCopy\n"],"body":"Just like where clauses, scopes are merged using AND conditions.We can mix and match scope and where conditions and the final SQL\nwill have all conditions joined with AND.If we do want the last where clause to win then merge can\nbe used.One important caveat is that default_scope will be prepended in\nscope and where conditions.As you can see above the default_scope is being merged in both\nscope and where conditions.","title":"15.4 Merging of scopes","anchor":"#merging-of-scopes"},{"title":"15.5 Removing All Scoping","anchor":"#removing-all-scoping","code":["\nBook.unscoped.load\n\nBook.unscoped.load\n\nCopy\n","\nirb> Book.unscoped.all\nSELECT books.* FROM books\n\nirb> Book.where(out_of_print: true).unscoped.all\nSELECT books.* FROM books\n\nBook.unscoped.all\nBook.where(out_of_print: true).unscoped.all\n\nCopy\n","\nirb> Book.unscoped { Book.out_of_print }\nSELECT books.* FROM books WHERE books.out_of_print\n\nBook.unscoped { Book.out_of_print }\n\nCopy\n"],"body":"If we wish to remove scoping for any reason we can use the unscoped method. This is\nespecially useful if a default_scope is specified in the model and should not be\napplied for this particular query.This method removes all scoping and will do a normal query on the table.unscoped can also accept a block:"},{"code":[],"body":"For every field (also known as an attribute) you define in your table,\nActive Record provides a finder method. If you have a field called first_name on your Customer model for example,\nyou get the instance method find_by_first_name for free from Active Record.\nIf you also have a locked field on the Customer model, you also get find_by_locked method.You can specify an exclamation point (!) on the end of the dynamic finders\nto get them to raise an ActiveRecord::RecordNotFound error if they do not return any records, like Customer.find_by_name!(\"Ryan\")If you want to find both by name and orders_count, you can chain these finders together by simply typing \"and\" between the fields.\nFor example, Customer.find_by_first_name_and_orders_count(\"Ryan\", 5).","title":"16 Dynamic Finders","anchor":"#dynamic-finders"},{"title":"17 Enums","anchor":"#enums","code":["\nclass Order < ApplicationRecord\n  enum status: [:shipped, :being_packaged, :complete, :cancelled]\nend\n\nclass Order < ApplicationRecord\n  enum status: [:shipped, :being_packaged, :complete, :cancelled]\nend\n\nCopy\n","\nirb> Order.shipped\n=> #<ActiveRecord::Relation> # all orders with status == :shipped\nirb> Order.not_shipped\n=> #<ActiveRecord::Relation> # all orders with status != :shipped\n\nOrder.shipped\nOrder.not_shipped\n\nCopy\n","\nirb> order = Order.shipped.first\nirb> order.shipped?\n=> true\nirb> order.complete?\n=> false\n\norder = Order.shipped.first\norder.shipped?\norder.complete?\n\nCopy\n","\nirb> order = Order.first\nirb> order.shipped!\nUPDATE \"orders\" SET \"status\" = ?, \"updated_at\" = ? WHERE \"orders\".\"id\" = ?  [[\"status\", 0], [\"updated_at\", \"2019-01-24 07:13:08.524320\"], [\"id\", 1]]\n=> true\n\norder = Order.first\norder.shipped!\n\nCopy\n"],"body":"An enum lets you define an Array of values for an attribute and refer to them by name.  The actual value stored in the database is an integer that has been mapped to one of the values.Declaring an enum will:for all possible values of an enum.For example, given this enum declaration:These scopes are created automatically and can be used to find all objects with or without a particular value for status:These instance methods are created automatically and query whether the model has that value for the status enum:These instance methods are created automatically and will first update the value of status to the named value\nand then query whether or not the status has been successfully set to the value:Full documentation about enums can be found here."},{"title":"18 Understanding Method Chaining","anchor":"#understanding-method-chaining","code":[],"body":"The Active Record pattern implements Method Chaining,\nwhich allow us to use multiple Active Record methods together in a simple and straightforward way.You can chain methods in a statement when the previous method called returns an\nActiveRecord::Relation, like all, where, and joins. Methods that return\na single object (see Retrieving a Single Object Section)\nhave to be at the end of the statement.There are some examples below. This guide won't cover all the possibilities, just a few as examples.\nWhen an Active Record method is called, the query is not immediately generated and sent to the database.\nThe query is sent only when the data is actually needed. So each example below generates a single query."},{"title":"18.1 Retrieving filtered data from multiple tables","anchor":"#retrieving-filtered-data-from-multiple-tables","code":["\nCustomer\n  .select('customers.id, customers.last_name, reviews.body')\n  .joins(:reviews)\n  .where('reviews.created_at > ?', 1.week.ago)\n\nCustomer\n  .select('customers.id, customers.last_name, reviews.body')\n  .joins(:reviews)\n  .where('reviews.created_at > ?', 1.week.ago)\n\nCopy\n","\nSELECT customers.id, customers.last_name, reviews.body\nFROM customers\nINNER JOIN reviews\n  ON reviews.customer_id = customers.id\nWHERE (reviews.created_at > '2019-01-08')\n\nSELECT customers.id, customers.last_name, reviews.body\nFROM customers\nINNER JOIN reviews\n  ON reviews.customer_id = customers.id\nWHERE (reviews.created_at > '2019-01-08')\n\nCopy\n"],"body":"The result should be something like this:"},{"code":["\nBook\n  .select('books.id, books.title, authors.first_name')\n  .joins(:author)\n  .find_by(title: 'Abstraction and Specification in Program Development')\n\nBook\n  .select('books.id, books.title, authors.first_name')\n  .joins(:author)\n  .find_by(title: 'Abstraction and Specification in Program Development')\n\nCopy\n","\nSELECT books.id, books.title, authors.first_name\nFROM books\nINNER JOIN authors\n  ON authors.id = books.author_id\nWHERE books.title = $1 [[\"title\", \"Abstraction and Specification in Program Development\"]]\nLIMIT 1\n\nSELECT books.id, books.title, authors.first_name\nFROM books\nINNER JOIN authors\n  ON authors.id = books.author_id\nWHERE books.title = $1 [[\"title\", \"Abstraction and Specification in Program Development\"]]\nLIMIT 1\n\nCopy\n"],"body":"The above should generate:","title":"18.2 Retrieving specific data from multiple tables","anchor":"#retrieving-specific-data-from-multiple-tables"},{"title":"19 Find or Build a New Object","anchor":"#find-or-build-a-new-object","code":[],"body":"It's common that you need to find a record or create it if it doesn't exist. You can do that with the find_or_create_by and find_or_create_by! methods."},{"title":"19.1 find_or_create_by","anchor":"#find-or-create-by","code":["\nirb> Customer.find_or_create_by(first_name: 'Andy')\n=> #<Customer id: 5, first_name: \"Andy\", last_name: nil, title: nil, visits: 0, orders_count: nil, lock_version: 0, created_at: \"2019-01-17 07:06:45\", updated_at: \"2019-01-17 07:06:45\">\n\nCustomer.find_or_create_by(first_name: 'Andy')\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.first_name = 'Andy') LIMIT 1\nBEGIN\nINSERT INTO customers (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')\nCOMMIT\n\nSELECT * FROM customers WHERE (customers.first_name = 'Andy') LIMIT 1\nBEGIN\nINSERT INTO customers (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')\nCOMMIT\n\nCopy\n","\nCustomer.create_with(locked: false).find_or_create_by(first_name: 'Andy')\n\nCustomer.create_with(locked: false).find_or_create_by(first_name: 'Andy')\n\nCopy\n","\nCustomer.find_or_create_by(first_name: 'Andy') do |c|\n  c.locked = false\nend\n\nCustomer.find_or_create_by(first_name: 'Andy') do |c|\n  c.locked = false\nend\n\nCopy\n"],"body":"The find_or_create_by method checks whether a record with the specified attributes exists. If it doesn't, then create is called. Let's see an example.Suppose you want to find a customer named \"Andy\", and if there's none, create one. You can do so by running:The SQL generated by this method looks like this:find_or_create_by returns either the record that already exists or the new record. In our case, we didn't already have a customer named Andy so the record is created and returned.The new record might not be saved to the database; that depends on whether validations passed or not (just like create).Suppose we want to set the 'locked' attribute to false if we're\ncreating a new record, but we don't want to include it in the query. So\nwe want to find the customer named \"Andy\", or if that customer doesn't\nexist, create a customer named \"Andy\" which is not locked.We can achieve this in two ways. The first is to use create_with:The second way is using a block:The block will only be executed if the customer is being created. The\nsecond time we run this code, the block will be ignored."},{"title":"19.2 find_or_create_by!","anchor":"#find-or-create-by-bang","code":["\nvalidates :orders_count, presence: true\n\nvalidates :orders_count, presence: true\n\nCopy\n","\nirb> Customer.find_or_create_by!(first_name: 'Andy')\nActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank\n\nCustomer.find_or_create_by!(first_name: 'Andy')\n\nCopy\n"],"body":"You can also use find_or_create_by! to raise an exception if the new record is invalid. Validations are not covered on this guide, but let's assume for a moment that you temporarily addto your Customer model. If you try to create a new Customer without passing an orders_count, the record will be invalid and an exception will be raised:"},{"code":["\nirb> nina = Customer.find_or_initialize_by(first_name: 'Nina')\n=> #<Customer id: nil, first_name: \"Nina\", orders_count: 0, locked: true, created_at: \"2011-08-30 06:09:27\", updated_at: \"2011-08-30 06:09:27\">\n\nirb> nina.persisted?\n=> false\n\nirb> nina.new_record?\n=> true\n\nnina = Customer.find_or_initialize_by(first_name: 'Nina')\nnina.persisted?\nnina.new_record?\n\nCopy\n","\nSELECT * FROM customers WHERE (customers.first_name = 'Nina') LIMIT 1\n\nSELECT * FROM customers WHERE (customers.first_name = 'Nina') LIMIT 1\n\nCopy\n","\nirb> nina.save\n=> true\n\nnina.save\n\nCopy\n"],"body":"The find_or_initialize_by method will work just like\nfind_or_create_by but it will call new instead of create. This\nmeans that a new model instance will be created in memory but won't be\nsaved to the database. Continuing with the find_or_create_by example, we\nnow want the customer named 'Nina':Because the object is not yet stored in the database, the SQL generated looks like this:When you want to save it to the database, just call save:","title":"19.3 find_or_initialize_by","anchor":"#find-or-initialize-by"},{"code":["\nirb> Customer.find_by_sql(\"SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc\")\n=> [#<Customer id: 1, first_name: \"Lucas\" ...>, #<Customer id: 2, first_name: \"Jan\" ...>, ...]\n\nCustomer.find_by_sql(\"SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc\")\n\nCopy\n"],"body":"If you'd like to use your own SQL to find records in a table you can use find_by_sql. The find_by_sql method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:find_by_sql provides you with a simple way of making custom calls to the database and retrieving instantiated objects.","title":"20 Finding by SQL","anchor":"#finding-by-sql"},{"title":"20.1 select_all","anchor":"#select-all","code":["\nirb> Customer.connection.select_all(\"SELECT first_name, created_at FROM customers WHERE id = '1'\").to_hash\n=> [{\"first_name\"=>\"Rafael\", \"created_at\"=>\"2012-11-10 23:23:45.281189\"}, {\"first_name\"=>\"Eileen\", \"created_at\"=>\"2013-12-09 11:22:35.221282\"}]\n\nCustomer.connection.select_all(\"SELECT first_name, created_at FROM customers WHERE id = '1'\").to_hash\n\nCopy\n"],"body":"find_by_sql has a close relative called connection.select_all. select_all will retrieve\nobjects from the database using custom SQL just like find_by_sql but will not instantiate them.\nThis method will return an instance of ActiveRecord::Result class and calling to_a on this\nobject would return you an array of hashes where each hash indicates a record."},{"code":["\nirb> Book.where(out_of_print: true).pluck(:id)\nSELECT id FROM books WHERE out_of_print = false\n=> [1, 2, 3]\n\nirb> Order.distinct.pluck(:status)\nSELECT DISTINCT status FROM orders\n=> [\"shipped\", \"being_packed\", \"cancelled\"]\n\nirb> Customer.pluck(:id, :first_name)\nSELECT customers.id, customers.name FROM customers\n=> [[1, \"David\"], [2, \"Fran\"], [3, \"Jose\"]]\n\nBook.where(out_of_print: true).pluck(:id)\nOrder.distinct.pluck(:status)\nCustomer.pluck(:id, :first_name)\n\nCopy\n","\nCustomer.select(:id).map { |c| c.id }\n# or\nCustomer.select(:id).map(&:id)\n# or\nCustomer.select(:id, :name).map { |c| [c.id, c.first_name] }\n\nCustomer.select(:id).map { |c| c.id }\n# or\nCustomer.select(:id).map(&:id)\n# or\nCustomer.select(:id, :name).map { |c| [c.id, c.first_name] }\n\nCopy\n","\nCustomer.pluck(:id)\n# or\nCustomer.pluck(:id, :first_name)\n\nCustomer.pluck(:id)\n# or\nCustomer.pluck(:id, :first_name)\n\nCopy\n","\nclass Customer < ApplicationRecord\n  def name\n    \"I am #{first_name}\"\n  end\nend\n\nclass Customer < ApplicationRecord\n  def name\n    \"I am #{first_name}\"\n  end\nend\n\nCopy\n","\nirb> Customer.select(:first_name).map &:name\n=> [\"I am David\", \"I am Jeremy\", \"I am Jose\"]\n\nirb> Customer.pluck(:first_name)\n=> [\"David\", \"Jeremy\", \"Jose\"]\n\nCustomer.select(:first_name).map &:name\nCustomer.pluck(:first_name)\n\nCopy\n","\nirb> Order.joins(:customer, :books).pluck(\"orders.created_at, customers.email, books.title\")\n\nOrder.joins(:customer, :books).pluck(\"orders.created_at, customers.email, books.title\")\n\nCopy\n","\nirb> Customer.pluck(:first_name).limit(1)\nNoMethodError: undefined method `limit' for #<Array:0x007ff34d3ad6d8>\n\nirb> Customer.limit(1).pluck(:first_name)\n=> [\"David\"]\n\nCustomer.pluck(:first_name).limit(1)\nCustomer.limit(1).pluck(:first_name)\n\nCopy\n","\nirb> assoc = Customer.includes(:reviews)\nirb> assoc.pluck(:id)\nSELECT \"customers\".\"id\" FROM \"customers\" LEFT OUTER JOIN \"reviews\" ON \"reviews\".\"id\" = \"customers\".\"review_id\"\n\nassoc = Customer.includes(:reviews)\nassoc.pluck(:id)\n\nCopy\n","\nirb> assoc.unscope(:includes).pluck(:id)\n\nassoc.unscope(:includes).pluck(:id)\n\nCopy\n"],"body":"pluck can be used to query single or multiple columns from the underlying table of a model. It accepts a list of column names as an argument and returns an array of values of the specified columns with the corresponding data type.pluck makes it possible to replace code like:with:Unlike select, pluck directly converts a database result into a Ruby Array,\nwithout constructing ActiveRecord objects. This can mean better performance for\na large or frequently-run query. However, any model method overrides will\nnot be available. For example:You are not limited to querying fields from a single table, you can query multiple tables as well.Furthermore, unlike select and other Relation scopes, pluck triggers an immediate\nquery, and thus cannot be chained with any further scopes, although it can work with\nscopes already constructed earlier:One way to avoid this is to unscope the includes:","title":"20.2 pluck","anchor":"#pluck"},{"code":["\nirb> Customer.ids\nSELECT id FROM customers\n\nCustomer.ids\n\nCopy\n","\nclass Customer < ApplicationRecord\n  self.primary_key = \"customer_id\"\nend\n\nclass Customer < ApplicationRecord\n  self.primary_key = \"customer_id\"\nend\n\nCopy\n","\nirb> Customer.ids\nSELECT customer_id FROM customers\n\nCustomer.ids\n\nCopy\n"],"body":"ids can be used to pluck all the IDs for the relation using the table's primary key.","title":"20.3 ids","anchor":"#ids"},{"code":["\nCustomer.exists?(1)\n\nCustomer.exists?(1)\n\nCopy\n","\nCustomer.exists?(id: [1,2,3])\n# or\nCustomer.exists?(name: ['Jane', 'Sergei'])\n\nCustomer.exists?(id: [1,2,3])\n# or\nCustomer.exists?(name: ['Jane', 'Sergei'])\n\nCopy\n","\nCustomer.where(first_name: 'Ryan').exists?\n\nCustomer.where(first_name: 'Ryan').exists?\n\nCopy\n","\nCustomer.exists?\n\nCustomer.exists?\n\nCopy\n","\n# via a model\nOrder.any?   # => SELECT 1 AS one FROM orders\nOrder.many?  # => SELECT COUNT(*) FROM orders\n\n# via a named scope\nOrder.shipped.any?   # => SELECT 1 AS one FROM orders WHERE orders.status = 0\nOrder.shipped.many?  # => SELECT COUNT(*) FROM orders WHERE orders.status = 0\n\n# via a relation\nBook.where(out_of_print: true).any?\nBook.where(out_of_print: true).many?\n\n# via an association\nCustomer.first.orders.any?\nCustomer.first.orders.many?\n\n# via a model\nOrder.any?   # => SELECT 1 AS one FROM orders\nOrder.many?  # => SELECT COUNT(*) FROM orders\n\n# via a named scope\nOrder.shipped.any?   # => SELECT 1 AS one FROM orders WHERE orders.status = 0\nOrder.shipped.many?  # => SELECT COUNT(*) FROM orders WHERE orders.status = 0\n\n# via a relation\nBook.where(out_of_print: true).any?\nBook.where(out_of_print: true).many?\n\n# via an association\nCustomer.first.orders.any?\nCustomer.first.orders.many?\n\nCopy\n"],"body":"If you simply want to check for the existence of the object there's a method called exists?.\nThis method will query the database using the same query as find, but instead of returning an\nobject or collection of objects it will return either true or false.The exists? method also takes multiple values, but the catch is that it will return true if any\none of those records exists.It's even possible to use exists? without any arguments on a model or a relation.The above returns true if there is at least one customer with the first_name 'Ryan' and false\notherwise.The above returns false if the customers table is empty and true otherwise.You can also use any? and many? to check for existence on a model or relation.  many? will use SQL count to determine if the item exists.","title":"21 Existence of Objects","anchor":"#existence-of-objects"},{"code":["\nirb> Customer.count\nSELECT COUNT(*) FROM customers\n\nCustomer.count\n\nCopy\n","\nirb> Customer.where(first_name: 'Ryan').count\nSELECT COUNT(*) FROM customers WHERE (first_name = 'Ryan')\n\nCustomer.where(first_name: 'Ryan').count\n\nCopy\n","\nirb> Customer.includes(\"orders\").where(first_name: 'Ryan', orders: { status: 'shipped' }).count\n\nCustomer.includes(\"orders\").where(first_name: 'Ryan', orders: { status: 'shipped' }).count\n\nCopy\n","\nSELECT COUNT(DISTINCT customers.id) FROM customers\n  LEFT OUTER JOIN orders ON orders.customer_id = customers.id\n  WHERE (customers.first_name = 'Ryan' AND orders.status = 0)\n\nSELECT COUNT(DISTINCT customers.id) FROM customers\n  LEFT OUTER JOIN orders ON orders.customer_id = customers.id\n  WHERE (customers.first_name = 'Ryan' AND orders.status = 0)\n\nCopy\n"],"body":"This section uses count as an example method in this preamble, but the options described apply to all sub-sections.All calculation methods work directly on a model:Or on a relation:You can also use various finder methods on a relation for performing complex calculations:Which will execute:assuming that Order has enum status: [ :shipped, :being_packed, :cancelled ].","title":"22 Calculations","anchor":"#calculations"},{"title":"22.1 Count","anchor":"#count","code":[],"body":"If you want to see how many records are in your model's table you could call Customer.count and that will return the number.\nIf you want to be more specific and find all the customers with a title present in the database you can use Customer.count(:title).For options, please see the parent section, Calculations."},{"title":"22.2 Average","anchor":"#average","code":["\nOrder.average(\"subtotal\")\n\nOrder.average(\"subtotal\")\n\nCopy\n"],"body":"If you want to see the average of a certain number in one of your tables you can call the average method on the class that relates to the table. This method call will look something like this:This will return a number (possibly a floating point number such as 3.14159265) representing the average value in the field.For options, please see the parent section, Calculations."},{"title":"22.3 Minimum","anchor":"#minimum","code":["\nOrder.minimum(\"subtotal\")\n\nOrder.minimum(\"subtotal\")\n\nCopy\n"],"body":"If you want to find the minimum value of a field in your table you can call the minimum method on the class that relates to the table. This method call will look something like this:For options, please see the parent section, Calculations."},{"title":"22.4 Maximum","anchor":"#maximum","code":["\nOrder.maximum(\"subtotal\")\n\nOrder.maximum(\"subtotal\")\n\nCopy\n"],"body":"If you want to find the maximum value of a field in your table you can call the maximum method on the class that relates to the table. This method call will look something like this:For options, please see the parent section, Calculations."},{"title":"22.5 Sum","anchor":"#sum","code":["\nOrder.sum(\"subtotal\")\n\nOrder.sum(\"subtotal\")\n\nCopy\n"],"body":"If you want to find the sum of a field for all records in your table you can call the sum method on the class that relates to the table. This method call will look something like this:For options, please see the parent section, Calculations."},{"title":"23 Running EXPLAIN","anchor":"#running-explain","code":["\nCustomer.where(id: 1).joins(:orders).explain\n\nCustomer.where(id: 1).joins(:orders).explain\n\nCopy\n","\nEXPLAIN for: SELECT `customers`.* FROM `customers` INNER JOIN `orders` ON `orders`.`customer_id` = `customers`.`id` WHERE `customers`.`id` = 1\n+----+-------------+------------+-------+---------------+\n| id | select_type | table      | type  | possible_keys |\n+----+-------------+------------+-------+---------------+\n|  1 | SIMPLE      | customers  | const | PRIMARY       |\n|  1 | SIMPLE      | orders     | ALL   | NULL          |\n+----+-------------+------------+-------+---------------+\n+---------+---------+-------+------+-------------+\n| key     | key_len | ref   | rows | Extra       |\n+---------+---------+-------+------+-------------+\n| PRIMARY | 4       | const |    1 |             |\n| NULL    | NULL    | NULL  |    1 | Using where |\n+---------+---------+-------+------+-------------+\n\n2 rows in set (0.00 sec)\n\nEXPLAIN for: SELECT `customers`.* FROM `customers` INNER JOIN `orders` ON `orders`.`customer_id` = `customers`.`id` WHERE `customers`.`id` = 1\n+----+-------------+------------+-------+---------------+\n| id | select_type | table      | type  | possible_keys |\n+----+-------------+------------+-------+---------------+\n|  1 | SIMPLE      | customers  | const | PRIMARY       |\n|  1 | SIMPLE      | orders     | ALL   | NULL          |\n+----+-------------+------------+-------+---------------+\n+---------+---------+-------+------+-------------+\n| key     | key_len | ref   | rows | Extra       |\n+---------+---------+-------+------+-------------+\n| PRIMARY | 4       | const |    1 |             |\n| NULL    | NULL    | NULL  |    1 | Using where |\n+---------+---------+-------+------+-------------+\n\n2 rows in set (0.00 sec)\n\nCopy\n","\nEXPLAIN for: SELECT \"customers\".* FROM \"customers\" INNER JOIN \"orders\" ON \"orders\".\"customer_id\" = \"customers\".\"id\" WHERE \"customers\".\"id\" = $1 [[\"id\", 1]]\n                                  QUERY PLAN\n------------------------------------------------------------------------------\n Nested Loop  (cost=4.33..20.85 rows=4 width=164)\n    ->  Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)\n          Index Cond: (id = '1'::bigint)\n    ->  Bitmap Heap Scan on orders  (cost=4.18..12.64 rows=4 width=8)\n          Recheck Cond: (customer_id = '1'::bigint)\n          ->  Bitmap Index Scan on index_orders_on_customer_id  (cost=0.00..4.18 rows=4 width=0)\n                Index Cond: (customer_id = '1'::bigint)\n(7 rows)\n\nEXPLAIN for: SELECT \"customers\".* FROM \"customers\" INNER JOIN \"orders\" ON \"orders\".\"customer_id\" = \"customers\".\"id\" WHERE \"customers\".\"id\" = $1 [[\"id\", 1]]\n                                  QUERY PLAN\n------------------------------------------------------------------------------\n Nested Loop  (cost=4.33..20.85 rows=4 width=164)\n    ->  Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)\n          Index Cond: (id = '1'::bigint)\n    ->  Bitmap Heap Scan on orders  (cost=4.18..12.64 rows=4 width=8)\n          Recheck Cond: (customer_id = '1'::bigint)\n          ->  Bitmap Index Scan on index_orders_on_customer_id  (cost=0.00..4.18 rows=4 width=0)\n                Index Cond: (customer_id = '1'::bigint)\n(7 rows)\n\nCopy\n","\nCustomer.where(id: 1).includes(:orders).explain\n\nCustomer.where(id: 1).includes(:orders).explain\n\nCopy\n","\nEXPLAIN for: SELECT `customers`.* FROM `customers`  WHERE `customers`.`id` = 1\n+----+-------------+-----------+-------+---------------+\n| id | select_type | table     | type  | possible_keys |\n+----+-------------+-----------+-------+---------------+\n|  1 | SIMPLE      | customers | const | PRIMARY       |\n+----+-------------+-----------+-------+---------------+\n+---------+---------+-------+------+-------+\n| key     | key_len | ref   | rows | Extra |\n+---------+---------+-------+------+-------+\n| PRIMARY | 4       | const |    1 |       |\n+---------+---------+-------+------+-------+\n\n1 row in set (0.00 sec)\n\nEXPLAIN for: SELECT `orders`.* FROM `orders`  WHERE `orders`.`customer_id` IN (1)\n+----+-------------+--------+------+---------------+\n| id | select_type | table  | type | possible_keys |\n+----+-------------+--------+------+---------------+\n|  1 | SIMPLE      | orders | ALL  | NULL          |\n+----+-------------+--------+------+---------------+\n+------+---------+------+------+-------------+\n| key  | key_len | ref  | rows | Extra       |\n+------+---------+------+------+-------------+\n| NULL | NULL    | NULL |    1 | Using where |\n+------+---------+------+------+-------------+\n\n\n1 row in set (0.00 sec)\n\nEXPLAIN for: SELECT `customers`.* FROM `customers`  WHERE `customers`.`id` = 1\n+----+-------------+-----------+-------+---------------+\n| id | select_type | table     | type  | possible_keys |\n+----+-------------+-----------+-------+---------------+\n|  1 | SIMPLE      | customers | const | PRIMARY       |\n+----+-------------+-----------+-------+---------------+\n+---------+---------+-------+------+-------+\n| key     | key_len | ref   | rows | Extra |\n+---------+---------+-------+------+-------+\n| PRIMARY | 4       | const |    1 |       |\n+---------+---------+-------+------+-------+\n\n1 row in set (0.00 sec)\n\nEXPLAIN for: SELECT `orders`.* FROM `orders`  WHERE `orders`.`customer_id` IN (1)\n+----+-------------+--------+------+---------------+\n| id | select_type | table  | type | possible_keys |\n+----+-------------+--------+------+---------------+\n|  1 | SIMPLE      | orders | ALL  | NULL          |\n+----+-------------+--------+------+---------------+\n+------+---------+------+------+-------------+\n| key  | key_len | ref  | rows | Extra       |\n+------+---------+------+------+-------------+\n| NULL | NULL    | NULL |    1 | Using where |\n+------+---------+------+------+-------------+\n\n\n1 row in set (0.00 sec)\n\nCopy\n","\n  Customer Load (0.3ms)  SELECT \"customers\".* FROM \"customers\" WHERE \"customers\".\"id\" = $1  [[\"id\", 1]]\n  Order Load (0.3ms)  SELECT \"orders\".* FROM \"orders\" WHERE \"orders\".\"customer_id\" = $1  [[\"customer_id\", 1]]\n=> EXPLAIN for: SELECT \"customers\".* FROM \"customers\" WHERE \"customers\".\"id\" = $1 [[\"id\", 1]]\n                                    QUERY PLAN\n----------------------------------------------------------------------------------\n Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)\n   Index Cond: (id = '1'::bigint)\n(2 rows)\n\n  Customer Load (0.3ms)  SELECT \"customers\".* FROM \"customers\" WHERE \"customers\".\"id\" = $1  [[\"id\", 1]]\n  Order Load (0.3ms)  SELECT \"orders\".* FROM \"orders\" WHERE \"orders\".\"customer_id\" = $1  [[\"customer_id\", 1]]\n=> EXPLAIN for: SELECT \"customers\".* FROM \"customers\" WHERE \"customers\".\"id\" = $1 [[\"id\", 1]]\n                                    QUERY PLAN\n----------------------------------------------------------------------------------\n Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)\n   Index Cond: (id = '1'::bigint)\n(2 rows)\n\nCopy\n"],"body":"You can run explain on a relation. EXPLAIN output varies for each database.For example, runningmay yieldunder MySQL and MariaDB.Active Record performs a pretty printing that emulates that of the\ncorresponding database shell. So, the same query running with the\nPostgreSQL adapter would yield insteadEager loading may trigger more than one query under the hood, and some queries\nmay need the results of previous ones. Because of that, explain actually\nexecutes the query, and then asks for the query plans. For example,may yield this for MySQL and MariaDB:and may yield this for PostgreSQL:"},{"code":[],"body":"Interpretation of the output of EXPLAIN is beyond the scope of this guide. The\nfollowing pointers may be helpful:","title":"23.1 Interpreting EXPLAIN","anchor":"#interpreting-explain"}]