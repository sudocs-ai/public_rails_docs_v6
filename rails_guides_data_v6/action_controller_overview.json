[{"code":[],"body":"Action Controller is the C in MVC. After the router has determined which controller to use for a request, the controller is responsible for making sense of the request, and producing the appropriate output. Luckily, Action Controller does most of the groundwork for you and uses smart conventions to make this as straightforward as possible.For most conventional RESTful applications, the controller will receive the request (this is invisible to you as the developer), fetch or save data from a model, and use a view to create HTML output. If your controller needs to do things a little differently, that's not a problem, this is just the most common way for a controller to work.A controller can thus be thought of as a middleman between models and views. It makes the model data available to the view so it can display that data to the user, and it saves or updates user data to the model.","title":"1 What Does a Controller Do?","anchor":"#what-does-a-controller-do-questionmark"},{"title":"2 Controller Naming Convention","anchor":"#controller-naming-convention","code":[],"body":"The naming convention of controllers in Rails favors pluralization of the last word in the controller's name, although it is not strictly required (e.g. ApplicationController). For example, ClientsController is preferable to ClientController, SiteAdminsController is preferable to SiteAdminController or SitesAdminsController, and so on.Following this convention will allow you to use the default route generators (e.g. resources, etc) without needing to qualify each :path or :controller, and will keep named route helpers' usage consistent throughout your application. See Layouts and Rendering Guide for more details."},{"title":"3 Methods and Actions","anchor":"#methods-and-actions","code":["\nclass ClientsController < ApplicationController\n  def new\n  end\nend\n\nclass ClientsController < ApplicationController\n  def new\n  end\nend\n\nCopy\n","\ndef new\n  @client = Client.new\nend\n\ndef new\n  @client = Client.new\nend\n\nCopy\n"],"body":"A controller is a Ruby class which inherits from ApplicationController and has methods just like any other class. When your application receives a request, the routing will determine which controller and action to run, then Rails creates an instance of that controller and runs the method with the same name as the action.As an example, if a user goes to /clients/new in your application to add a new client, Rails will create an instance of ClientsController and call its new method. Note that the empty method from the example above would work just fine because Rails will by default render the new.html.erb view unless the action says otherwise. By creating a new Client, the new method can make a @client instance variable accessible in the view:The Layouts and Rendering Guide explains this in more detail.ApplicationController inherits from ActionController::Base, which defines a number of helpful methods. This guide will cover some of these, but if you're curious to see what's in there, you can see all of them in the API documentation or in the source itself.Only public methods are callable as actions. It is a best practice to lower the visibility of methods (with private or protected) which are not intended to be actions, like auxiliary methods or filters."},{"title":"4 Parameters","anchor":"#parameters","code":["\nclass ClientsController < ApplicationController\n  # This action uses query string parameters because it gets run\n  # by an HTTP GET request, but this does not make any difference\n  # to the way in which the parameters are accessed. The URL for\n  # this action would look like this in order to list activated\n  # clients: /clients?status=activated\n  def index\n    if params[:status] == \"activated\"\n      @clients = Client.activated\n    else\n      @clients = Client.inactivated\n    end\n  end\n\n  # This action uses POST parameters. They are most likely coming\n  # from an HTML form which the user has submitted. The URL for\n  # this RESTful request will be \"/clients\", and the data will be\n  # sent as part of the request body.\n  def create\n    @client = Client.new(params[:client])\n    if @client.save\n      redirect_to @client\n    else\n      # This line overrides the default rendering behavior, which\n      # would have been to render the \"create\" view.\n      render \"new\"\n    end\n  end\nend\n\nclass ClientsController < ApplicationController\n  # This action uses query string parameters because it gets run\n  # by an HTTP GET request, but this does not make any difference\n  # to the way in which the parameters are accessed. The URL for\n  # this action would look like this in order to list activated\n  # clients: /clients?status=activated\n  def index\n    if params[:status] == \"activated\"\n      @clients = Client.activated\n    else\n      @clients = Client.inactivated\n    end\n  end\n\n  # This action uses POST parameters. They are most likely coming\n  # from an HTML form which the user has submitted. The URL for\n  # this RESTful request will be \"/clients\", and the data will be\n  # sent as part of the request body.\n  def create\n    @client = Client.new(params[:client])\n    if @client.save\n      redirect_to @client\n    else\n      # This line overrides the default rendering behavior, which\n      # would have been to render the \"create\" view.\n      render \"new\"\n    end\n  end\nend\n\nCopy\n"],"body":"You will probably want to access data sent in by the user or other parameters in your controller actions. There are two kinds of parameters possible in a web application. The first are parameters that are sent as part of the URL, called query string parameters. The query string is everything after \"?\" in the URL. The second type of parameter is usually referred to as POST data. This information usually comes from an HTML form which has been filled in by the user. It's called POST data because it can only be sent as part of an HTTP POST request. Rails does not make any distinction between query string parameters and POST parameters, and both are available in the params hash in your controller:"},{"code":["\nGET /clients?ids[]=1&ids[]=2&ids[]=3\n\nGET /clients?ids[]=1&ids[]=2&ids[]=3\n\nCopy\n","\n<form accept-charset=\"UTF-8\" action=\"/clients\" method=\"post\">\n  <input type=\"text\" name=\"client[name]\" value=\"Acme\" />\n  <input type=\"text\" name=\"client[phone]\" value=\"12345\" />\n  <input type=\"text\" name=\"client[address][postcode]\" value=\"12345\" />\n  <input type=\"text\" name=\"client[address][city]\" value=\"Carrot City\" />\n</form>\n\n<form accept-charset=\"UTF-8\" action=\"/clients\" method=\"post\">\n  <input type=\"text\" name=\"client[name]\" value=\"Acme\" />\n  <input type=\"text\" name=\"client[phone]\" value=\"12345\" />\n  <input type=\"text\" name=\"client[address][postcode]\" value=\"12345\" />\n  <input type=\"text\" name=\"client[address][city]\" value=\"Carrot City\" />\n</form>\n\nCopy\n"],"body":"The params hash is not limited to one-dimensional keys and values. It can contain nested arrays and hashes. To send an array of values, append an empty pair of square brackets \"[]\" to the key name:The value of params[:ids] will now be [\"1\", \"2\", \"3\"]. Note that parameter values are always strings; Rails makes no attempt to guess or cast the type.To send a hash, you include the key name inside the brackets:When this form is submitted, the value of params[:client] will be { \"name\" => \"Acme\", \"phone\" => \"12345\", \"address\" => { \"postcode\" => \"12345\", \"city\" => \"Carrot City\" } }. Note the nested hash in params[:client][:address].The params object acts like a Hash, but lets you use symbols and strings interchangeably as keys.","title":"4.1 Hash and Array Parameters","anchor":"#hash-and-array-parameters"},{"title":"4.2 JSON parameters","anchor":"#json-parameters","code":["\n{ \"company\": { \"name\": \"acme\", \"address\": \"123 Carrot Street\" } }\n\n{ \"company\": { \"name\": \"acme\", \"address\": \"123 Carrot Street\" } }\n\nCopy\n","\n{ \"name\": \"acme\", \"address\": \"123 Carrot Street\" }\n\n{ \"name\": \"acme\", \"address\": \"123 Carrot Street\" }\n\nCopy\n","\n{ name: \"acme\", address: \"123 Carrot Street\", company: { name: \"acme\", address: \"123 Carrot Street\" } }\n\n{ name: \"acme\", address: \"123 Carrot Street\", company: { name: \"acme\", address: \"123 Carrot Street\" } }\n\nCopy\n"],"body":"If you're writing a web service application, you might find yourself more comfortable accepting parameters in JSON format. If the \"Content-Type\" header of your request is set to \"application/json\", Rails will automatically load your parameters into the params hash, which you can access as you would normally.So for example, if you are sending this JSON content:Your controller will receive params[:company] as { \"name\" => \"acme\", \"address\" => \"123 Carrot Street\" }.Also, if you've turned on config.wrap_parameters in your initializer or called wrap_parameters in your controller, you can safely omit the root element in the JSON parameter. In this case, the parameters will be cloned and wrapped with a key chosen based on your controller's name. So the above JSON request can be written as:And, assuming that you're sending the data to CompaniesController, it would then be wrapped within the :company key like this:You can customize the name of the key or specific parameters you want to wrap by consulting the API documentation"},{"title":"4.3 Routing Parameters","anchor":"#routing-parameters","code":["\nget '/clients/:status', to: 'clients#index', foo: 'bar'\n\nget '/clients/:status', to: 'clients#index', foo: 'bar'\n\nCopy\n"],"body":"The params hash will always contain the :controller and :action keys, but you should use the methods controller_name and action_name instead to access these values. Any other parameters defined by the routing, such as :id, will also be available. As an example, consider a listing of clients where the list can show either active or inactive clients. We can add a route which captures the :status parameter in a \"pretty\" URL:In this case, when a user opens the URL /clients/active, params[:status] will be set to \"active\". When this route is used, params[:foo] will also be set to \"bar\", as if it were passed in the query string. Your controller will also receive params[:action] as \"index\" and params[:controller] as \"clients\"."},{"title":"4.4 default_url_options","anchor":"#default-url-options","code":["\nclass ApplicationController < ActionController::Base\n  def default_url_options\n    { locale: I18n.locale }\n  end\nend\n\nclass ApplicationController < ActionController::Base\n  def default_url_options\n    { locale: I18n.locale }\n  end\nend\n\nCopy\n"],"body":"You can set global default parameters for URL generation by defining a method called default_url_options in your controller. Such a method must return a hash with the desired defaults, whose keys must be symbols:These options will be used as a starting point when generating URLs, so it's possible they'll be overridden by the options passed to url_for calls.If you define default_url_options in ApplicationController, as in the example above, these defaults will be used for all URL generation. The method can also be defined in a specific controller, in which case it only affects URLs generated there.In a given request, the method is not actually called for every single generated URL. For performance reasons, the returned hash is cached, and there is at most one invocation per request."},{"title":"4.5 Strong Parameters","anchor":"#strong-parameters","code":["\nclass PeopleController < ActionController::Base\n  # This will raise an ActiveModel::ForbiddenAttributesError exception\n  # because it's using mass assignment without an explicit permit\n  # step.\n  def create\n    Person.create(params[:person])\n  end\n\n  # This will pass with flying colors as long as there's a person key\n  # in the parameters, otherwise it'll raise an\n  # ActionController::ParameterMissing exception, which will get\n  # caught by ActionController::Base and turned into a 400 Bad\n  # Request error.\n  def update\n    person = current_account.people.find(params[:id])\n    person.update!(person_params)\n    redirect_to person\n  end\n\n  private\n    # Using a private method to encapsulate the permissible parameters\n    # is just a good pattern since you'll be able to reuse the same\n    # permit list between create and update. Also, you can specialize\n    # this method with per-user checking of permissible attributes.\n    def person_params\n      params.require(:person).permit(:name, :age)\n    end\nend\n\nclass PeopleController < ActionController::Base\n  # This will raise an ActiveModel::ForbiddenAttributesError exception\n  # because it's using mass assignment without an explicit permit\n  # step.\n  def create\n    Person.create(params[:person])\n  end\n\n  # This will pass with flying colors as long as there's a person key\n  # in the parameters, otherwise it'll raise an\n  # ActionController::ParameterMissing exception, which will get\n  # caught by ActionController::Base and turned into a 400 Bad\n  # Request error.\n  def update\n    person = current_account.people.find(params[:id])\n    person.update!(person_params)\n    redirect_to person\n  end\n\n  private\n    # Using a private method to encapsulate the permissible parameters\n    # is just a good pattern since you'll be able to reuse the same\n    # permit list between create and update. Also, you can specialize\n    # this method with per-user checking of permissible attributes.\n    def person_params\n      params.require(:person).permit(:name, :age)\n    end\nend\n\nCopy\n"],"body":"With strong parameters, Action Controller parameters are forbidden to\nbe used in Active Model mass assignments until they have been\npermitted. This means that you'll have to make a conscious decision about\nwhich attributes to permit for mass update. This is a better security\npractice to help prevent accidentally allowing users to update sensitive\nmodel attributes.In addition, parameters can be marked as required and will flow through a\npredefined raise/rescue flow that will result in a 400 Bad Request being\nreturned if not all required parameters are passed in."},{"code":["\nparams.permit(:id)\n\nparams.permit(:id)\n\nCopy\n","\nparams.permit(id: [])\n\nparams.permit(id: [])\n\nCopy\n","\nparams.permit(preferences: {})\n\nparams.permit(preferences: {})\n\nCopy\n","\nparams.require(:log_entry).permit!\n\nparams.require(:log_entry).permit!\n\nCopy\n"],"body":"Calling permit like:permits the specified key (:id) for inclusion if it appears in params and\nit has a permitted scalar value associated. Otherwise, the key is going\nto be filtered out, so arrays, hashes, or any other objects cannot be\ninjected.The permitted scalar types are String, Symbol, NilClass,\nNumeric, TrueClass, FalseClass, Date, Time, DateTime,\nStringIO, IO, ActionDispatch::Http::UploadedFile, and\nRack::Test::UploadedFile.To declare that the value in params must be an array of permitted\nscalar values, map the key to an empty array:Sometimes it is not possible or convenient to declare the valid keys of\na hash parameter or its internal structure. Just map to an empty hash:but be careful because this opens the door to arbitrary input. In this\ncase, permit ensures values in the returned structure are permitted\nscalars and filters out anything else.To permit an entire hash of parameters, the permit! method can be\nused:This marks the :log_entry parameters hash and any sub-hash of it as\npermitted and does not check for permitted scalars, anything is accepted.\nExtreme care should be taken when using permit!, as it will allow all current\nand future model attributes to be mass-assigned.","title":"4.5.1 Permitted Scalar Values","anchor":"#permitted-scalar-values"},{"title":"4.5.2 Nested Parameters","anchor":"#nested-parameters","code":["\nparams.permit(:name, { emails: [] },\n              friends: [ :name,\n                         { family: [ :name ], hobbies: [] }])\n\nparams.permit(:name, { emails: [] },\n              friends: [ :name,\n                         { family: [ :name ], hobbies: [] }])\n\nCopy\n"],"body":"You can also use permit on nested parameters, like:This declaration permits the name, emails, and friends\nattributes. It is expected that emails will be an array of permitted\nscalar values, and that friends will be an array of resources with\nspecific attributes: they should have a name attribute (any\npermitted scalar values allowed), a hobbies attribute as an array of\npermitted scalar values, and a family attribute which is restricted\nto having a name (any permitted scalar values allowed here, too)."},{"title":"4.5.3 More Examples","anchor":"#more-examples","code":["\n# using `fetch` you can supply a default and use\n# the Strong Parameters API from there.\nparams.fetch(:blog, {}).permit(:title, :author)\n\n# using `fetch` you can supply a default and use\n# the Strong Parameters API from there.\nparams.fetch(:blog, {}).permit(:title, :author)\n\nCopy\n","\n# permit :id and :_destroy\nparams.require(:author).permit(:name, books_attributes: [:title, :id, :_destroy])\n\n# permit :id and :_destroy\nparams.require(:author).permit(:name, books_attributes: [:title, :id, :_destroy])\n\nCopy\n","\n# To permit the following data:\n# {\"book\" => {\"title\" => \"Some Book\",\n#             \"chapters_attributes\" => { \"1\" => {\"title\" => \"First Chapter\"},\n#                                        \"2\" => {\"title\" => \"Second Chapter\"}}}}\n\nparams.require(:book).permit(:title, chapters_attributes: [:title])\n\n# To permit the following data:\n# {\"book\" => {\"title\" => \"Some Book\",\n#             \"chapters_attributes\" => { \"1\" => {\"title\" => \"First Chapter\"},\n#                                        \"2\" => {\"title\" => \"Second Chapter\"}}}}\n\nparams.require(:book).permit(:title, chapters_attributes: [:title])\n\nCopy\n","\ndef product_params\n  params.require(:product).permit(:name, data: {})\nend\n\ndef product_params\n  params.require(:product).permit(:name, data: {})\nend\n\nCopy\n"],"body":"You may want to also use the permitted attributes in your new\naction. This raises the problem that you can't use require on the\nroot key because, normally, it does not exist when calling new:The model class method accepts_nested_attributes_for allows you to\nupdate and destroy associated records. This is based on the id and _destroy\nparameters:Hashes with integer keys are treated differently, and you can declare\nthe attributes as if they were direct children. You get these kinds of\nparameters when you use accepts_nested_attributes_for in combination\nwith a has_many association:Imagine a scenario where you have parameters representing a product\nname and a hash of arbitrary data associated with that product, and\nyou want to permit the product name attribute and also the whole\ndata hash:"},{"code":[],"body":"The strong parameter API was designed with the most common use cases\nin mind. It is not meant as a silver bullet to handle all of your\nparameter filtering problems. However, you can easily mix the API with your\nown code to adapt to your situation.","title":"4.5.4 Outside the Scope of Strong Parameters","anchor":"#outside-the-scope-of-strong-parameters"},{"title":"5 Session","anchor":"#session","code":["\n# Use the database for sessions instead of the cookie-based default,\n# which shouldn't be used to store highly confidential information\n# (create the session table with \"rails g active_record:session_migration\")\n# Rails.application.config.session_store :active_record_store\n\n# Use the database for sessions instead of the cookie-based default,\n# which shouldn't be used to store highly confidential information\n# (create the session table with \"rails g active_record:session_migration\")\n# Rails.application.config.session_store :active_record_store\n\nCopy\n","\n# Be sure to restart your server when you modify this file.\nRails.application.config.session_store :cookie_store, key: '_your_app_session'\n\n# Be sure to restart your server when you modify this file.\nRails.application.config.session_store :cookie_store, key: '_your_app_session'\n\nCopy\n","\n# Be sure to restart your server when you modify this file.\nRails.application.config.session_store :cookie_store, key: '_your_app_session', domain: \".example.com\"\n\n# Be sure to restart your server when you modify this file.\nRails.application.config.session_store :cookie_store, key: '_your_app_session', domain: \".example.com\"\n\nCopy\n","\n# aws:\n#   access_key_id: 123\n#   secret_access_key: 345\n\n# Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.\nsecret_key_base: 492f...\n\n# aws:\n#   access_key_id: 123\n#   secret_access_key: 345\n\n# Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.\nsecret_key_base: 492f...\n\nCopy\n"],"body":"Your application has a session for each user in which you can store small amounts of data that will be persisted between requests. The session is only available in the controller and the view and can use one of a number of different storage mechanisms:All session stores use a cookie to store a unique ID for each session (you must use a cookie, Rails will not allow you to pass the session ID in the URL as this is less secure).For most stores, this ID is used to look up the session data on the server, e.g. in a database table. There is one exception, and that is the default and recommended session store - the CookieStore - which stores all session data in the cookie itself (the ID is still available to you if you need it). This has the advantage of being very lightweight and it requires zero setup in a new application in order to use the session. The cookie data is cryptographically signed to make it tamper-proof. And it is also encrypted so anyone with access to it can't read its contents. (Rails will not accept it if it has been edited).The CookieStore can store around 4kB of data - much less than the others - but this is usually enough. Storing large amounts of data in the session is discouraged no matter which session store your application uses. You should especially avoid storing complex objects (such as model instances) in the session, as the server might not be able to reassemble them between requests, which will result in an error.If your user sessions don't store critical data or don't need to be around for long periods (for instance if you just use the flash for messaging), you can consider using ActionDispatch::Session::CacheStore. This will store sessions using the cache implementation you have configured for your application. The advantage of this is that you can use your existing cache infrastructure for storing sessions without requiring any additional setup or administration. The downside, of course, is that the sessions will be ephemeral and could disappear at any time.Read more about session storage in the Security Guide.If you need a different session storage mechanism, you can change it in an initializer:Rails sets up a session key (the name of the cookie) when signing the session data. These can also be changed in an initializer:You can also pass a :domain key and specify the domain name for the cookie:Rails sets up (for the CookieStore) a secret key used for signing the session data in config/credentials.yml.enc. This can be changed with bin/rails credentials:edit."},{"title":"5.1 Accessing the Session","anchor":"#accessing-the-session","code":["\nclass ApplicationController < ActionController::Base\n\n  private\n\n  # Finds the User with the ID stored in the session with the key\n  # :current_user_id This is a common way to handle user login in\n  # a Rails application; logging in sets the session value and\n  # logging out removes it.\n  def current_user\n    @_current_user ||= session[:current_user_id] &&\n      User.find_by(id: session[:current_user_id])\n  end\nend\n\nclass ApplicationController < ActionController::Base\n\n  private\n\n  # Finds the User with the ID stored in the session with the key\n  # :current_user_id This is a common way to handle user login in\n  # a Rails application; logging in sets the session value and\n  # logging out removes it.\n  def current_user\n    @_current_user ||= session[:current_user_id] &&\n      User.find_by(id: session[:current_user_id])\n  end\nend\n\nCopy\n","\nclass LoginsController < ApplicationController\n  # \"Create\" a login, aka \"log the user in\"\n  def create\n    if user = User.authenticate(params[:username], params[:password])\n      # Save the user ID in the session so it can be used in\n      # subsequent requests\n      session[:current_user_id] = user.id\n      redirect_to root_url\n    end\n  end\nend\n\nclass LoginsController < ApplicationController\n  # \"Create\" a login, aka \"log the user in\"\n  def create\n    if user = User.authenticate(params[:username], params[:password])\n      # Save the user ID in the session so it can be used in\n      # subsequent requests\n      session[:current_user_id] = user.id\n      redirect_to root_url\n    end\n  end\nend\n\nCopy\n","\nclass LoginsController < ApplicationController\n  # \"Delete\" a login, aka \"log the user out\"\n  def destroy\n    # Remove the user id from the session\n    session.delete(:current_user_id)\n    # Clear the memoized current user\n    @_current_user = nil\n    redirect_to root_url\n  end\nend\n\nclass LoginsController < ApplicationController\n  # \"Delete\" a login, aka \"log the user out\"\n  def destroy\n    # Remove the user id from the session\n    session.delete(:current_user_id)\n    # Clear the memoized current user\n    @_current_user = nil\n    redirect_to root_url\n  end\nend\n\nCopy\n"],"body":"In your controller you can access the session through the session instance method.Session values are stored using key/value pairs like a hash:To store something in the session, just assign it to the key like a hash:To remove something from the session, delete the key/value pair:To reset the entire session, use reset_session."},{"title":"5.2 The Flash","anchor":"#the-flash","code":["\nclass LoginsController < ApplicationController\n  def destroy\n    session.delete(:current_user_id)\n    flash[:notice] = \"You have successfully logged out.\"\n    redirect_to root_url\n  end\nend\n\nclass LoginsController < ApplicationController\n  def destroy\n    session.delete(:current_user_id)\n    flash[:notice] = \"You have successfully logged out.\"\n    redirect_to root_url\n  end\nend\n\nCopy\n","\nredirect_to root_url, notice: \"You have successfully logged out.\"\nredirect_to root_url, alert: \"You're stuck here!\"\nredirect_to root_url, flash: { referral_code: 1234 }\n\nredirect_to root_url, notice: \"You have successfully logged out.\"\nredirect_to root_url, alert: \"You're stuck here!\"\nredirect_to root_url, flash: { referral_code: 1234 }\n\nCopy\n","\n<html>\n  <!-- <head/> -->\n  <body>\n    <% flash.each do |name, msg| -%>\n      <%= content_tag :div, msg, class: name %>\n    <% end -%>\n\n    <!-- more content -->\n  </body>\n</html>\n\n<html>\n  <!-- <head/> -->\n  <body>\n    <% flash.each do |name, msg| -%>\n      <%= content_tag :div, msg, class: name %>\n    <% end -%>\n\n    <!-- more content -->\n  </body>\n</html>\n\nCopy\n","\n<% if flash[:just_signed_up] %>\n  <p class=\"welcome\">Welcome to our site!</p>\n<% end %>\n\n<% if flash[:just_signed_up] %>\n  <p class=\"welcome\">Welcome to our site!</p>\n<% end %>\n\nCopy\n","\nclass MainController < ApplicationController\n  # Let's say this action corresponds to root_url, but you want\n  # all requests here to be redirected to UsersController#index.\n  # If an action sets the flash and redirects here, the values\n  # would normally be lost when another redirect happens, but you\n  # can use 'keep' to make it persist for another request.\n  def index\n    # Will persist all flash values.\n    flash.keep\n\n    # You can also use a key to keep only some kind of value.\n    # flash.keep(:notice)\n    redirect_to users_url\n  end\nend\n\nclass MainController < ApplicationController\n  # Let's say this action corresponds to root_url, but you want\n  # all requests here to be redirected to UsersController#index.\n  # If an action sets the flash and redirects here, the values\n  # would normally be lost when another redirect happens, but you\n  # can use 'keep' to make it persist for another request.\n  def index\n    # Will persist all flash values.\n    flash.keep\n\n    # You can also use a key to keep only some kind of value.\n    # flash.keep(:notice)\n    redirect_to users_url\n  end\nend\n\nCopy\n"],"body":"The flash is a special part of the session which is cleared with each request. This means that values stored there will only be available in the next request, which is useful for passing error messages, etc.The flash is accessed via the flash method. Like the session, the flash is represented as a hash.Let's use the act of logging out as an example. The controller can send a message which will be displayed to the user on the next request:Note that it is also possible to assign a flash message as part of the redirection. You can assign :notice, :alert or the general purpose :flash:The destroy action redirects to the application's root_url, where the message will be displayed. Note that it's entirely up to the next action to decide what, if anything, it will do with what the previous action put in the flash. It's conventional to display any error alerts or notices from the flash in the application's layout:This way, if an action sets a notice or an alert message, the layout will display it automatically.You can pass anything that the session can store; you're not limited to notices and alerts:If you want a flash value to be carried over to another request, use flash.keep:"},{"code":["\nclass ClientsController < ApplicationController\n  def create\n    @client = Client.new(client_params)\n    if @client.save\n      # ...\n    else\n      flash.now[:error] = \"Could not save client\"\n      render action: \"new\"\n    end\n  end\nend\n\nclass ClientsController < ApplicationController\n  def create\n    @client = Client.new(client_params)\n    if @client.save\n      # ...\n    else\n      flash.now[:error] = \"Could not save client\"\n      render action: \"new\"\n    end\n  end\nend\n\nCopy\n"],"body":"By default, adding values to the flash will make them available to the next request, but sometimes you may want to access those values in the same request. For example, if the create action fails to save a resource and you render the new template directly, that's not going to result in a new request, but you may still want to display a message using the flash. To do this, you can use flash.now in the same way you use the normal flash:","title":"5.2.1 flash.now","anchor":"#flash-now"},{"code":["\nclass CommentsController < ApplicationController\n  def new\n    # Auto-fill the commenter's name if it has been stored in a cookie\n    @comment = Comment.new(author: cookies[:commenter_name])\n  end\n\n  def create\n    @comment = Comment.new(comment_params)\n    if @comment.save\n      flash[:notice] = \"Thanks for your comment!\"\n      if params[:remember_name]\n        # Remember the commenter's name.\n        cookies[:commenter_name] = @comment.author\n      else\n        # Delete cookie for the commenter's name cookie, if any.\n        cookies.delete(:commenter_name)\n      end\n      redirect_to @comment.article\n    else\n      render action: \"new\"\n    end\n  end\nend\n\nclass CommentsController < ApplicationController\n  def new\n    # Auto-fill the commenter's name if it has been stored in a cookie\n    @comment = Comment.new(author: cookies[:commenter_name])\n  end\n\n  def create\n    @comment = Comment.new(comment_params)\n    if @comment.save\n      flash[:notice] = \"Thanks for your comment!\"\n      if params[:remember_name]\n        # Remember the commenter's name.\n        cookies[:commenter_name] = @comment.author\n      else\n        # Delete cookie for the commenter's name cookie, if any.\n        cookies.delete(:commenter_name)\n      end\n      redirect_to @comment.article\n    else\n      render action: \"new\"\n    end\n  end\nend\n\nCopy\n","\nRails.application.config.action_dispatch.cookies_serializer = :json\n\nRails.application.config.action_dispatch.cookies_serializer = :json\n\nCopy\n","\nRails.application.config.action_dispatch.cookies_serializer = MyCustomSerializer\n\nRails.application.config.action_dispatch.cookies_serializer = MyCustomSerializer\n\nCopy\n","\nclass CookiesController < ApplicationController\n  def set_cookie\n    cookies.encrypted[:expiration_date] = Date.tomorrow # => Thu, 20 Mar 2014\n    redirect_to action: 'read_cookie'\n  end\n\n  def read_cookie\n    cookies.encrypted[:expiration_date] # => \"2014-03-20\"\n  end\nend\n\nclass CookiesController < ApplicationController\n  def set_cookie\n    cookies.encrypted[:expiration_date] = Date.tomorrow # => Thu, 20 Mar 2014\n    redirect_to action: 'read_cookie'\n  end\n\n  def read_cookie\n    cookies.encrypted[:expiration_date] # => \"2014-03-20\"\n  end\nend\n\nCopy\n"],"body":"Your application can store small amounts of data on the client - called cookies - that will be persisted across requests and even sessions. Rails provides easy access to cookies via the cookies method, which - much like the session - works like a hash:Note that while for session values you can set the key to nil, to delete a cookie value you should use cookies.delete(:key).Rails also provides a signed cookie jar and an encrypted cookie jar for storing\nsensitive data. The signed cookie jar appends a cryptographic signature on the\ncookie values to protect their integrity. The encrypted cookie jar encrypts the\nvalues in addition to signing them, so that they cannot be read by the end user.\nRefer to the API documentation\nfor more details.These special cookie jars use a serializer to serialize the assigned values into\nstrings and deserializes them into Ruby objects on read.You can specify what serializer to use:The default serializer for new applications is :json. For compatibility with\nold applications with existing cookies, :marshal is used when serializer\noption is not specified.You may also set this option to :hybrid, in which case Rails would transparently\ndeserialize existing (Marshal-serialized) cookies on read and re-write them in\nthe JSON format. This is useful for migrating existing applications to the\n:json serializer.It is also possible to pass a custom serializer that responds to load and\ndump:When using the :json or :hybrid serializer, you should beware that not all\nRuby objects can be serialized as JSON. For example, Date and Time objects\nwill be serialized as strings, and Hashes will have their keys stringified.It's advisable that you only store simple data (strings and numbers) in cookies.\nIf you have to store complex objects, you would need to handle the conversion\nmanually when reading the values on subsequent requests.If you use the cookie session store, this would apply to the session and\nflash hash as well.","title":"6 Cookies","anchor":"#cookies"},{"title":"7 Rendering XML and JSON data","anchor":"#rendering-xml-and-json-data","code":["\nclass UsersController < ApplicationController\n  def index\n    @users = User.all\n    respond_to do |format|\n      format.html # index.html.erb\n      format.xml  { render xml: @users }\n      format.json { render json: @users }\n    end\n  end\nend\n\nclass UsersController < ApplicationController\n  def index\n    @users = User.all\n    respond_to do |format|\n      format.html # index.html.erb\n      format.xml  { render xml: @users }\n      format.json { render json: @users }\n    end\n  end\nend\n\nCopy\n"],"body":"ActionController makes it extremely easy to render XML or JSON data. If you've generated a controller using scaffolding, it would look something like this:You may notice in the above code that we're using render xml: @users, not render xml: @users.to_xml. If the object is not a String, then Rails will automatically invoke to_xml for us."},{"title":"8 Filters","anchor":"#filters","code":["\nclass ApplicationController < ActionController::Base\n  before_action :require_login\n\n  private\n\n  def require_login\n    unless logged_in?\n      flash[:error] = \"You must be logged in to access this section\"\n      redirect_to new_login_url # halts request cycle\n    end\n  end\nend\n\nclass ApplicationController < ActionController::Base\n  before_action :require_login\n\n  private\n\n  def require_login\n    unless logged_in?\n      flash[:error] = \"You must be logged in to access this section\"\n      redirect_to new_login_url # halts request cycle\n    end\n  end\nend\n\nCopy\n","\nclass LoginsController < ApplicationController\n  skip_before_action :require_login, only: [:new, :create]\nend\n\nclass LoginsController < ApplicationController\n  skip_before_action :require_login, only: [:new, :create]\nend\n\nCopy\n"],"body":"Filters are methods that are run \"before\", \"after\" or \"around\" a controller action.Filters are inherited, so if you set a filter on ApplicationController, it will be run on every controller in your application.\"before\" filters are registered via before_action. They may halt the request cycle. A common \"before\" filter is one which requires that a user is logged in for an action to be run. You can define the filter method this way:The method simply stores an error message in the flash and redirects to the login form if the user is not logged in. If a \"before\" filter renders or redirects, the action will not run. If there are additional filters scheduled to run after that filter, they are also cancelled.In this example the filter is added to ApplicationController and thus all controllers in the application inherit it. This will make everything in the application require the user to be logged in in order to use it. For obvious reasons (the user wouldn't be able to log in in the first place!), not all controllers or actions should require this. You can prevent this filter from running before particular actions with skip_before_action:Now, the LoginsController's new and create actions will work as before without requiring the user to be logged in. The :only option is used to skip this filter only for these actions, and there is also an :except option which works the other way. These options can be used when adding filters too, so you can add a filter which only runs for selected actions in the first place."},{"title":"8.1 After Filters and Around Filters","anchor":"#after-filters-and-around-filters","code":["\nclass ChangesController < ApplicationController\n  around_action :wrap_in_transaction, only: :show\n\n  private\n\n  def wrap_in_transaction\n    ActiveRecord::Base.transaction do\n      begin\n        yield\n      ensure\n        raise ActiveRecord::Rollback\n      end\n    end\n  end\nend\n\nclass ChangesController < ApplicationController\n  around_action :wrap_in_transaction, only: :show\n\n  private\n\n  def wrap_in_transaction\n    ActiveRecord::Base.transaction do\n      begin\n        yield\n      ensure\n        raise ActiveRecord::Rollback\n      end\n    end\n  end\nend\n\nCopy\n"],"body":"In addition to \"before\" filters, you can also run filters after an action has been executed, or both before and after.\"after\" filters are registered via after_action. They are similar to \"before\" filters, but because the action has already been run they have access to the response data that's about to be sent to the client. Obviously, \"after\" filters cannot stop the action from running. Please note that \"after\" filters are executed only after a successful action, but not when an exception is raised in the request cycle.\"around\" filters are registered via around_action. They are responsible for running their associated actions by yielding, similar to how Rack middlewares work.For example, in a website where changes have an approval workflow, an administrator could preview them easily by applying them within a transaction:Note that an \"around\" filter also wraps rendering. In particular, in the example above, if the view itself reads from the database (e.g. via a scope), it will do so within the transaction and thus present the data to preview.You can choose not to yield and build the response yourself, in which case the action will not be run."},{"title":"8.2 Other Ways to Use Filters","anchor":"#other-ways-to-use-filters","code":["\nclass ApplicationController < ActionController::Base\n  before_action do |controller|\n    unless controller.send(:logged_in?)\n      flash[:error] = \"You must be logged in to access this section\"\n      redirect_to new_login_url\n    end\n  end\nend\n\nclass ApplicationController < ActionController::Base\n  before_action do |controller|\n    unless controller.send(:logged_in?)\n      flash[:error] = \"You must be logged in to access this section\"\n      redirect_to new_login_url\n    end\n  end\nend\n\nCopy\n","\naround_action { |_controller, action| time(&action) }\n\naround_action { |_controller, action| time(&action) }\n\nCopy\n","\nclass ApplicationController < ActionController::Base\n  before_action LoginFilter\nend\n\nclass LoginFilter\n  def self.before(controller)\n    unless controller.send(:logged_in?)\n      controller.flash[:error] = \"You must be logged in to access this section\"\n      controller.redirect_to controller.new_login_url\n    end\n  end\nend\n\nclass ApplicationController < ActionController::Base\n  before_action LoginFilter\nend\n\nclass LoginFilter\n  def self.before(controller)\n    unless controller.send(:logged_in?)\n      controller.flash[:error] = \"You must be logged in to access this section\"\n      controller.redirect_to controller.new_login_url\n    end\n  end\nend\n\nCopy\n"],"body":"While the most common way to use filters is by creating private methods and using before_action, after_action, or around_action to add them, there are two other ways to do the same thing.The first is to use a block directly with the *_action methods. The block receives the controller as an argument. The require_login filter from above could be rewritten to use a block:Note that the filter in this case uses send because the logged_in? method is private and the filter does not run in the scope of the controller. This is not the recommended way to implement this particular filter, but in simpler cases it might be useful.Specifically for around_action, the block also yields in the action:The second way is to use a class (actually, any object that responds to the right methods will do) to handle the filtering. This is useful in cases that are more complex and cannot be implemented in a readable and reusable way using the two other methods. As an example, you could rewrite the login filter again to use a class:Again, this is not an ideal example for this filter, because it's not run in the scope of the controller but gets the controller passed as an argument. The filter class must implement a method with the same name as the filter, so for the before_action filter the class must implement a before method, and so on. The around method must yield to execute the action."},{"title":"9 Request Forgery Protection","anchor":"#request-forgery-protection","code":["\n<%= form_with model: @user do |form| %>\n  <%= form.text_field :username %>\n  <%= form.text_field :password %>\n<% end %>\n\n<%= form_with model: @user do |form| %>\n  <%= form.text_field :username %>\n  <%= form.text_field :password %>\n<% end %>\n\nCopy\n","\n<form accept-charset=\"UTF-8\" action=\"/users/1\" method=\"post\">\n<input type=\"hidden\"\n       value=\"67250ab105eb5ad10851c00a5621854a23af5489\"\n       name=\"authenticity_token\"/>\n<!-- fields -->\n</form>\n\n<form accept-charset=\"UTF-8\" action=\"/users/1\" method=\"post\">\n<input type=\"hidden\"\n       value=\"67250ab105eb5ad10851c00a5621854a23af5489\"\n       name=\"authenticity_token\"/>\n<!-- fields -->\n</form>\n\nCopy\n"],"body":"Cross-site request forgery is a type of attack in which a site tricks a user into making requests on another site, possibly adding, modifying, or deleting data on that site without the user's knowledge or permission.The first step to avoid this is to make sure all \"destructive\" actions (create, update, and destroy) can only be accessed with non-GET requests. If you're following RESTful conventions you're already doing this. However, a malicious site can still send a non-GET request to your site quite easily, and that's where the request forgery protection comes in. As the name says, it protects from forged requests.The way this is done is to add a non-guessable token which is only known to your server to each request. This way, if a request comes in without the proper token, it will be denied access.If you generate a form like this:You will see how the token gets added as a hidden field:Rails adds this token to every form that's generated using the form helpers, so most of the time you don't have to worry about it. If you're writing a form manually or need to add the token for another reason, it's available through the method form_authenticity_token:The form_authenticity_token generates a valid authentication token. That's useful in places where Rails does not add it automatically, like in custom Ajax calls.The Security Guide has more about this and a lot of other security-related issues that you should be aware of when developing a web application."},{"title":"10 The Request and Response Objects","anchor":"#the-request-and-response-objects","code":[],"body":"In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The request method contains an instance of ActionDispatch::Request and the response method returns a response object representing what is going to be sent back to the client."},{"title":"10.1 The request Object","anchor":"#the-request-object","code":[],"body":"The request object contains a lot of useful information about the request coming in from the client. To get a full list of the available methods, refer to the Rails API documentation and Rack Documentation. Among the properties that you can access on this object are:"},{"code":[],"body":"Rails collects all of the parameters sent along with the request in the params hash, whether they are sent as part of the query string or the post body. The request object has three accessors that give you access to these parameters depending on where they came from. The query_parameters hash contains parameters that were sent as part of the query string while the request_parameters hash contains parameters sent as part of the post body. The path_parameters hash contains parameters that were recognized by the routing as being part of the path leading to this particular controller and action.","title":"10.1.1 path_parameters, query_parameters, and request_parameters","anchor":"#path-parameters-query-parameters-and-request-parameters"},{"title":"10.2 The response Object","anchor":"#the-response-object","code":[],"body":"The response object is not usually used directly, but is built up during the execution of the action and rendering of the data that is being sent back to the user, but sometimes - like in an after filter - it can be useful to access the response directly. Some of these accessor methods also have setters, allowing you to change their values. To get a full list of the available methods, refer to the Rails API documentation and Rack Documentation."},{"code":["\nresponse.headers[\"Content-Type\"] = \"application/pdf\"\n\nresponse.headers[\"Content-Type\"] = \"application/pdf\"\n\nCopy\n"],"body":"If you want to set custom headers for a response then response.headers is the place to do it. The headers attribute is a hash which maps header names to their values, and Rails will set some of them automatically. If you want to add or change a header, just assign it to response.headers this way:","title":"10.2.1 Setting Custom Headers","anchor":"#setting-custom-headers"},{"title":"11 HTTP Authentications","anchor":"#http-authentications","code":[],"body":"Rails comes with three built-in HTTP authentication mechanisms:"},{"code":["\nclass AdminsController < ApplicationController\n  http_basic_authenticate_with name: \"humbaba\", password: \"5baa61e4\"\nend\n\nclass AdminsController < ApplicationController\n  http_basic_authenticate_with name: \"humbaba\", password: \"5baa61e4\"\nend\n\nCopy\n"],"body":"HTTP basic authentication is an authentication scheme that is supported by the majority of browsers and other HTTP clients. As an example, consider an administration section which will only be available by entering a username and a password into the browser's HTTP basic dialog window. Using the built-in authentication is quite easy and only requires you to use one method, http_basic_authenticate_with.With this in place, you can create namespaced controllers that inherit from AdminsController. The filter will thus be run for all actions in those controllers, protecting them with HTTP basic authentication.","title":"11.1 HTTP Basic Authentication","anchor":"#http-basic-authentication"},{"title":"11.2 HTTP Digest Authentication","anchor":"#http-digest-authentication","code":["\nclass AdminsController < ApplicationController\n  USERS = { \"lifo\" => \"world\" }\n\n  before_action :authenticate\n\n  private\n    def authenticate\n      authenticate_or_request_with_http_digest do |username|\n        USERS[username]\n      end\n    end\nend\n\nclass AdminsController < ApplicationController\n  USERS = { \"lifo\" => \"world\" }\n\n  before_action :authenticate\n\n  private\n    def authenticate\n      authenticate_or_request_with_http_digest do |username|\n        USERS[username]\n      end\n    end\nend\n\nCopy\n"],"body":"HTTP digest authentication is superior to the basic authentication as it does not require the client to send an unencrypted password over the network (though HTTP basic authentication is safe over HTTPS). Using digest authentication with Rails is quite easy and only requires using one method, authenticate_or_request_with_http_digest.As seen in the example above, the authenticate_or_request_with_http_digest block takes only one argument - the username. And the block returns the password. Returning false or nil from the authenticate_or_request_with_http_digest will cause authentication failure."},{"title":"11.3 HTTP Token Authentication","anchor":"#http-token-authentication","code":["\nclass PostsController < ApplicationController\n  TOKEN = \"secret\"\n\n  before_action :authenticate\n\n  private\n    def authenticate\n      authenticate_or_request_with_http_token do |token, options|\n        ActiveSupport::SecurityUtils.secure_compare(token, TOKEN)\n      end\n    end\nend\n\nclass PostsController < ApplicationController\n  TOKEN = \"secret\"\n\n  before_action :authenticate\n\n  private\n    def authenticate\n      authenticate_or_request_with_http_token do |token, options|\n        ActiveSupport::SecurityUtils.secure_compare(token, TOKEN)\n      end\n    end\nend\n\nCopy\n"],"body":"HTTP token authentication is a scheme to enable the usage of Bearer tokens in the HTTP Authorization header. There are many token formats available and describing them is outside the scope of this document.As an example, suppose you want to use an authentication token that has been issued in advance to perform authentication and access. Implementing token authentication with Rails is quite easy and only requires using one method, authenticate_or_request_with_http_token.As seen in the example above, the authenticate_or_request_with_http_token block takes two arguments - the token and a Hash containing the options that were parsed from the HTTP Authorization header. The block should return true if the authentication is successful. Returning false or nil on it will cause an authentication failure."},{"title":"12 Streaming and File Downloads","anchor":"#streaming-and-file-downloads","code":["\nrequire \"prawn\"\nclass ClientsController < ApplicationController\n  # Generates a PDF document with information on the client and\n  # returns it. The user will get the PDF as a file download.\n  def download_pdf\n    client = Client.find(params[:id])\n    send_data generate_pdf(client),\n              filename: \"#{client.name}.pdf\",\n              type: \"application/pdf\"\n  end\n\n  private\n    def generate_pdf(client)\n      Prawn::Document.new do\n        text client.name, align: :center\n        text \"Address: #{client.address}\"\n        text \"Email: #{client.email}\"\n      end.render\n    end\nend\n\nrequire \"prawn\"\nclass ClientsController < ApplicationController\n  # Generates a PDF document with information on the client and\n  # returns it. The user will get the PDF as a file download.\n  def download_pdf\n    client = Client.find(params[:id])\n    send_data generate_pdf(client),\n              filename: \"#{client.name}.pdf\",\n              type: \"application/pdf\"\n  end\n\n  private\n    def generate_pdf(client)\n      Prawn::Document.new do\n        text client.name, align: :center\n        text \"Address: #{client.address}\"\n        text \"Email: #{client.email}\"\n      end.render\n    end\nend\n\nCopy\n"],"body":"Sometimes you may want to send a file to the user instead of rendering an HTML page. All controllers in Rails have the send_data and the send_file methods, which will both stream data to the client. send_file is a convenience method that lets you provide the name of a file on the disk and it will stream the contents of that file for you.To stream data to the client, use send_data:The download_pdf action in the example above will call a private method which actually generates the PDF document and returns it as a string. This string will then be streamed to the client as a file download and a filename will be suggested to the user. Sometimes when streaming files to the user, you may not want them to download the file. Take images, for example, which can be embedded into HTML pages. To tell the browser a file is not meant to be downloaded, you can set the :disposition option to \"inline\". The opposite and default value for this option is \"attachment\"."},{"title":"12.1 Sending Files","anchor":"#sending-files","code":["\nclass ClientsController < ApplicationController\n  # Stream a file that has already been generated and stored on disk.\n  def download_pdf\n    client = Client.find(params[:id])\n    send_file(\"#{Rails.root}/files/clients/#{client.id}.pdf\",\n              filename: \"#{client.name}.pdf\",\n              type: \"application/pdf\")\n  end\nend\n\nclass ClientsController < ApplicationController\n  # Stream a file that has already been generated and stored on disk.\n  def download_pdf\n    client = Client.find(params[:id])\n    send_file(\"#{Rails.root}/files/clients/#{client.id}.pdf\",\n              filename: \"#{client.name}.pdf\",\n              type: \"application/pdf\")\n  end\nend\n\nCopy\n"],"body":"If you want to send a file that already exists on disk, use the send_file method.This will read and stream the file 4kB at the time, avoiding loading the entire file into memory at once. You can turn off streaming with the :stream option or adjust the block size with the :buffer_size option.If :type is not specified, it will be guessed from the file extension specified in :filename. If the content type is not registered for the extension, application/octet-stream will be used."},{"title":"12.2 RESTful Downloads","anchor":"#restful-downloads","code":["\nclass ClientsController < ApplicationController\n  # The user can request to receive this resource as HTML or PDF.\n  def show\n    @client = Client.find(params[:id])\n\n    respond_to do |format|\n      format.html\n      format.pdf { render pdf: generate_pdf(@client) }\n    end\n  end\nend\n\nclass ClientsController < ApplicationController\n  # The user can request to receive this resource as HTML or PDF.\n  def show\n    @client = Client.find(params[:id])\n\n    respond_to do |format|\n      format.html\n      format.pdf { render pdf: generate_pdf(@client) }\n    end\n  end\nend\n\nCopy\n","\nMime::Type.register \"application/pdf\", :pdf\n\nMime::Type.register \"application/pdf\", :pdf\n\nCopy\n","\nGET /clients/1.pdf\n\nGET /clients/1.pdf\n\nCopy\n"],"body":"While send_data works just fine, if you are creating a RESTful application having separate actions for file downloads is usually not necessary. In REST terminology, the PDF file from the example above can be considered just another representation of the client resource. Rails provides an easy and quite sleek way of doing \"RESTful downloads\". Here's how you can rewrite the example so that the PDF download is a part of the show action, without any streaming:In order for this example to work, you have to add the PDF MIME type to Rails. This can be done by adding the following line to the file config/initializers/mime_types.rb:Now the user can request to get a PDF version of a client just by adding \".pdf\" to the URL:"},{"code":[],"body":"Rails allows you to stream more than just files. In fact, you can stream anything\nyou would like in a response object. The ActionController::Live module allows\nyou to create a persistent connection with a browser. Using this module, you will\nbe able to send arbitrary data to the browser at specific points in time.","title":"12.3 Live Streaming of Arbitrary Data","anchor":"#live-streaming-of-arbitrary-data"},{"title":"12.3.1 Incorporating Live Streaming","anchor":"#incorporating-live-streaming","code":["\nclass MyController < ActionController::Base\n  include ActionController::Live\n\n  def stream\n    response.headers['Content-Type'] = 'text/event-stream'\n    100.times {\n      response.stream.write \"hello world\\n\"\n      sleep 1\n    }\n  ensure\n    response.stream.close\n  end\nend\n\nclass MyController < ActionController::Base\n  include ActionController::Live\n\n  def stream\n    response.headers['Content-Type'] = 'text/event-stream'\n    100.times {\n      response.stream.write \"hello world\\n\"\n      sleep 1\n    }\n  ensure\n    response.stream.close\n  end\nend\n\nCopy\n"],"body":"Including ActionController::Live inside of your controller class will provide\nall actions inside of the controller the ability to stream data. You can mix in\nthe module like so:The above code will keep a persistent connection with the browser and send 100\nmessages of \"hello world\\n\", each one second apart.There are a couple of things to notice in the above example. We need to make\nsure to close the response stream. Forgetting to close the stream will leave\nthe socket open forever. We also have to set the content type to text/event-stream\nbefore we write to the response stream. This is because headers cannot be written\nafter the response has been committed (when response.committed? returns a truthy\nvalue), which occurs when you write or commit the response stream."},{"title":"12.3.2 Example Usage","anchor":"#example-usage","code":["\nclass LyricsController < ActionController::Base\n  include ActionController::Live\n\n  def show\n    response.headers['Content-Type'] = 'text/event-stream'\n    song = Song.find(params[:id])\n\n    song.each do |line|\n      response.stream.write line.lyrics\n      sleep line.num_beats\n    end\n  ensure\n    response.stream.close\n  end\nend\n\nclass LyricsController < ActionController::Base\n  include ActionController::Live\n\n  def show\n    response.headers['Content-Type'] = 'text/event-stream'\n    song = Song.find(params[:id])\n\n    song.each do |line|\n      response.stream.write line.lyrics\n      sleep line.num_beats\n    end\n  ensure\n    response.stream.close\n  end\nend\n\nCopy\n"],"body":"Let's suppose that you were making a Karaoke machine and a user wants to get the\nlyrics for a particular song. Each Song has a particular number of lines and\neach line takes time num_beats to finish singing.If we wanted to return the lyrics in Karaoke fashion (only sending the line when\nthe singer has finished the previous line), then we could use ActionController::Live\nas follows:The above code sends the next line only after the singer has completed the previous\nline."},{"title":"12.3.3 Streaming Considerations","anchor":"#streaming-considerations","code":[],"body":"Streaming arbitrary data is an extremely powerful tool. As shown in the previous\nexamples, you can choose when and what to send across a response stream. However,\nyou should also note the following things:"},{"code":[],"body":"Rails keeps a log file for each environment in the log folder. These are extremely useful when debugging what's actually going on in your application, but in a live application you may not want every bit of information to be stored in the log file.","title":"13 Log Filtering","anchor":"#log-filtering"},{"title":"13.1 Parameters Filtering","anchor":"#parameters-filtering","code":["\nconfig.filter_parameters << :password\n\nconfig.filter_parameters << :password\n\nCopy\n"],"body":"You can filter out sensitive request parameters from your log files by appending them to config.filter_parameters in the application configuration. These parameters will be marked [FILTERED] in the log."},{"title":"13.2 Redirects Filtering","anchor":"#redirects-filtering","code":["\nconfig.filter_redirect << 's3.amazonaws.com'\n\nconfig.filter_redirect << 's3.amazonaws.com'\n\nCopy\n","\nconfig.filter_redirect.concat ['s3.amazonaws.com', /private_path/]\n\nconfig.filter_redirect.concat ['s3.amazonaws.com', /private_path/]\n\nCopy\n"],"body":"Sometimes it's desirable to filter out from log files some sensitive locations your application is redirecting to.\nYou can do that by using the config.filter_redirect configuration option:You can set it to a String, a Regexp, or an array of both.Matching URLs will be marked as '[FILTERED]'."},{"title":"14 Rescue","anchor":"#rescue","code":[],"body":"Most likely your application is going to contain bugs or otherwise throw an exception that needs to be handled. For example, if the user follows a link to a resource that no longer exists in the database, Active Record will throw the ActiveRecord::RecordNotFound exception.Rails default exception handling displays a \"500 Server Error\" message for all exceptions. If the request was made locally, a nice traceback and some added information gets displayed so you can figure out what went wrong and deal with it. If the request was remote Rails will just display a simple \"500 Server Error\" message to the user, or a \"404 Not Found\" if there was a routing error or a record could not be found. Sometimes you might want to customize how these errors are caught and how they're displayed to the user. There are several levels of exception handling available in a Rails application:"},{"title":"14.1 The Default 500 and 404 Templates","anchor":"#the-default-500-and-404-templates","code":[],"body":"By default, in the production environment the application will render either a 404 or a 500 error message. In the development environment all unhandled exceptions are simply raised. These messages are contained in static HTML files in the public folder, in 404.html and 500.html respectively. You can customize these files to add some extra information and style, but remember that they are static HTML; i.e. you can't use ERB, SCSS, CoffeeScript, or layouts for them."},{"title":"14.2 rescue_from","anchor":"#rescue-from","code":["\nclass ApplicationController < ActionController::Base\n  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found\n\n  private\n    def record_not_found\n      render plain: \"404 Not Found\", status: 404\n    end\nend\n\nclass ApplicationController < ActionController::Base\n  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found\n\n  private\n    def record_not_found\n      render plain: \"404 Not Found\", status: 404\n    end\nend\n\nCopy\n","\nclass ApplicationController < ActionController::Base\n  rescue_from User::NotAuthorized, with: :user_not_authorized\n\n  private\n    def user_not_authorized\n      flash[:error] = \"You don't have access to this section.\"\n      redirect_back(fallback_location: root_path)\n    end\nend\n\nclass ClientsController < ApplicationController\n  # Check that the user has the right authorization to access clients.\n  before_action :check_authorization\n\n  # Note how the actions don't have to worry about all the auth stuff.\n  def edit\n    @client = Client.find(params[:id])\n  end\n\n  private\n    # If the user is not authorized, just throw the exception.\n    def check_authorization\n      raise User::NotAuthorized unless current_user.admin?\n    end\nend\n\nclass ApplicationController < ActionController::Base\n  rescue_from User::NotAuthorized, with: :user_not_authorized\n\n  private\n    def user_not_authorized\n      flash[:error] = \"You don't have access to this section.\"\n      redirect_back(fallback_location: root_path)\n    end\nend\n\nclass ClientsController < ApplicationController\n  # Check that the user has the right authorization to access clients.\n  before_action :check_authorization\n\n  # Note how the actions don't have to worry about all the auth stuff.\n  def edit\n    @client = Client.find(params[:id])\n  end\n\n  private\n    # If the user is not authorized, just throw the exception.\n    def check_authorization\n      raise User::NotAuthorized unless current_user.admin?\n    end\nend\n\nCopy\n"],"body":"If you want to do something a bit more elaborate when catching errors, you can use rescue_from, which handles exceptions of a certain type (or multiple types) in an entire controller and its subclasses.When an exception occurs which is caught by a rescue_from directive, the exception object is passed to the handler. The handler can be a method or a Proc object passed to the :with option. You can also use a block directly instead of an explicit Proc object.Here's how you can use rescue_from to intercept all ActiveRecord::RecordNotFound errors and do something with them.Of course, this example is anything but elaborate and doesn't improve on the default exception handling at all, but once you can catch all those exceptions you're free to do whatever you want with them. For example, you could create custom exception classes that will be thrown when a user doesn't have access to a certain section of your application:"},{"title":"15 Force HTTPS protocol","anchor":"#force-https-protocol","code":[],"body":"If you'd like to ensure that communication to your controller is only possible\nvia HTTPS, you should do so by enabling the ActionDispatch::SSL middleware via\nconfig.force_ssl in your environment configuration."}]