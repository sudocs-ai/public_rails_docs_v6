[{"code":[],"body":"Engines can be considered miniature applications that provide functionality to\ntheir host applications. A Rails application is actually just a \"supercharged\"\nengine, with the Rails::Application class inheriting a lot of its behavior\nfrom Rails::Engine.Therefore, engines and applications can be thought of as almost the same thing,\njust with subtle differences, as you'll see throughout this guide. Engines and\napplications also share a common structure.Engines are also closely related to plugins. The two share a common lib\ndirectory structure, and are both generated using the rails plugin new\ngenerator. The difference is that an engine is considered a \"full plugin\" by\nRails (as indicated by the --full option that's passed to the generator\ncommand). We'll actually be using the --mountable option here, which includes\nall the features of --full, and then some. This guide will refer to these\n\"full plugins\" simply as \"engines\" throughout. An engine can be a plugin,\nand a plugin can be an engine.The engine that will be created in this guide will be called \"blorgh\". This\nengine will provide blogging functionality to its host applications, allowing\nfor new articles and comments to be created. At the beginning of this guide, you\nwill be working solely within the engine itself, but in later sections you'll\nsee how to hook it into an application.Engines can also be isolated from their host applications. This means that an\napplication is able to have a path provided by a routing helper such as\narticles_path and use an engine that also provides a path also called\narticles_path, and the two would not clash. Along with this, controllers, models\nand table names are also namespaced. You'll see how to do this later in this\nguide.It's important to keep in mind at all times that the application should\nalways take precedence over its engines. An application is the object that\nhas final say in what goes on in its environment. The engine should\nonly be enhancing it, rather than changing it drastically.To see demonstrations of other engines, check out\nDevise, an engine that provides\nauthentication for its parent applications, or\nThredded, an engine that provides forum\nfunctionality. There's also Spree which\nprovides an e-commerce platform, and\nRefinery CMS, a CMS engine.Finally, engines would not have been possible without the work of James Adam,\nPiotr Sarnacki, the Rails Core Team, and a number of other people. If you ever\nmeet them, don't forget to say thanks!","title":"1 What are Engines?","anchor":"#what-are-engines-questionmark"},{"title":"2 Generating an Engine","anchor":"#generating-an-engine","code":["\n$ rails plugin new blorgh --mountable\n\nrails plugin new blorgh --mountable\n\nCopy\n","\n$ rails plugin --help\n\nrails plugin --help\n\nCopy\n","\nmount Blorgh::Engine => \"/blorgh\"\n\nmount Blorgh::Engine => \"/blorgh\"\n\nCopy\n"],"body":"To generate an engine, you will need to run the plugin generator and pass it\noptions as appropriate to the need. For the \"blorgh\" example, you will need to\ncreate a \"mountable\" engine, running this command in a terminal:The full list of options for the plugin generator may be seen by typing:The --mountable option tells the generator that you want to create a\n\"mountable\" and namespace-isolated engine. This generator will provide the same\nskeleton structure as would the --full option. The --full option tells the\ngenerator that you want to create an engine, including a skeleton structure\nthat provides the following:The --mountable option will add to the --full option:Additionally, the --mountable option tells the generator to mount the engine\ninside the dummy testing application located at test/dummy by adding the\nfollowing to the dummy application's routes file at\ntest/dummy/config/routes.rb:"},{"code":[],"body":"","title":"2.1 Inside an Engine","anchor":"#inside-an-engine"},{"title":"2.1.1 Critical Files","anchor":"#critical-files","code":["\ngem 'blorgh', path: 'engines/blorgh'\n\ngem 'blorgh', path: 'engines/blorgh'\n\nCopy\n","\nrequire \"blorgh/engine\"\n\nmodule Blorgh\nend\n\nrequire \"blorgh/engine\"\n\nmodule Blorgh\nend\n\nCopy\n","\nmodule Blorgh\n  class Engine < ::Rails::Engine\n    isolate_namespace Blorgh\n  end\nend\n\nmodule Blorgh\n  class Engine < ::Rails::Engine\n    isolate_namespace Blorgh\n  end\nend\n\nCopy\n"],"body":"At the root of this brand new engine's directory lives a blorgh.gemspec file.\nWhen you include the engine into an application later on, you will do so with\nthis line in the Rails application's Gemfile:Don't forget to run bundle install as usual. By specifying it as a gem within\nthe Gemfile, Bundler will load it as such, parsing this blorgh.gemspec file\nand requiring a file within the lib directory called lib/blorgh.rb. This\nfile requires the blorgh/engine.rb file (located at lib/blorgh/engine.rb)\nand defines a base module called Blorgh.Within lib/blorgh/engine.rb is the base class for the engine:By inheriting from the Rails::Engine class, this gem notifies Rails that\nthere's an engine at the specified path, and will correctly mount the engine\ninside the application, performing tasks such as adding the app directory of\nthe engine to the load path for models, mailers, controllers, and views.The isolate_namespace method here deserves special notice. This call is\nresponsible for isolating the controllers, models, routes, and other things into\ntheir own namespace, away from similar components inside the application.\nWithout this, there is a possibility that the engine's components could \"leak\"\ninto the application, causing unwanted disruption, or that important engine\ncomponents could be overridden by similarly named things within the application.\nOne of the examples of such conflicts is helpers. Without calling\nisolate_namespace, the engine's helpers would be included in an application's\ncontrollers.What this isolation of the namespace means is that a model generated by a call\nto bin/rails generate model, such as bin/rails generate model article, won't be called Article, but\ninstead be namespaced and called Blorgh::Article. In addition, the table for the\nmodel is namespaced, becoming blorgh_articles, rather than simply articles.\nSimilar to the model namespacing, a controller called ArticlesController becomes\nBlorgh::ArticlesController and the views for that controller will not be at\napp/views/articles, but app/views/blorgh/articles instead. Mailers, jobs\nand helpers are namespaced as well.Finally, routes will also be isolated within the engine. This is one of the most\nimportant parts about namespacing, and is discussed later in the\nRoutes section of this guide."},{"title":"2.1.2 app Directory","anchor":"#app-directory","code":["\n# app/controllers/blorgh/articles_controller.rb:\nrequire_dependency \"blorgh/application_controller\"\n\nmodule Blorgh\n  class ArticlesController < ApplicationController\n    # ...\n  end\nend\n\n# app/controllers/blorgh/articles_controller.rb:\nrequire_dependency \"blorgh/application_controller\"\n\nmodule Blorgh\n  class ArticlesController < ApplicationController\n    # ...\n  end\nend\n\nCopy\n"],"body":"Inside the app directory are the standard assets, controllers, helpers,\njobs, mailers, models, and views directories that you should be familiar with\nfrom an application. We'll look more into models in a future section, when we're writing the engine.Within the app/assets directory, there are the images and\nstylesheets directories which, again, you should be familiar with due to their\nsimilarity to an application. One difference here, however, is that each\ndirectory contains a sub-directory with the engine name. Because this engine is\ngoing to be namespaced, its assets should be too.Within the app/controllers directory there is a blorgh directory that\ncontains a file called application_controller.rb. This file will provide any\ncommon functionality for the controllers of the engine. The blorgh directory\nis where the other controllers for the engine will go. By placing them within\nthis namespaced directory, you prevent them from possibly clashing with\nidentically-named controllers within other engines or even within the\napplication.Just like for app/controllers, you will find a blorgh subdirectory under\nthe app/helpers, app/jobs, app/mailers and app/models directories\ncontaining the associated application_*.rb file for gathering common\nfunctionalities. By placing your files under this subdirectory and namespacing\nyour objects, you prevent them from possibly clashing with identically-named\nelements within other engines or even within the application.Lastly, the app/views directory contains a layouts folder, which contains a\nfile at blorgh/application.html.erb. This file allows you to specify a layout\nfor the engine. If this engine is to be used as a stand-alone engine, then you\nwould add any customization to its layout in this file, rather than the\napplication's app/views/layouts/application.html.erb file.If you don't want to force a layout on to users of the engine, then you can\ndelete this file and reference a different layout in the controllers of your\nengine."},{"title":"2.1.3 bin Directory","anchor":"#bin-directory","code":["\n$ bin/rails generate model\n\nbin/rails generate model\n\nCopy\n"],"body":"This directory contains one file, bin/rails, which enables you to use the\nrails sub-commands and generators just like you would within an application.\nThis means that you will be able to generate new controllers and models for this\nengine very easily by running commands like this:Keep in mind, of course, that anything generated with these commands inside of\nan engine that has isolate_namespace in the Engine class will be namespaced."},{"title":"2.1.4 test Directory","anchor":"#test-directory","code":["\nRails.application.routes.draw do\n  mount Blorgh::Engine => \"/blorgh\"\nend\n\nRails.application.routes.draw do\n  mount Blorgh::Engine => \"/blorgh\"\nend\n\nCopy\n"],"body":"The test directory is where tests for the engine will go. To test the engine,\nthere is a cut-down version of a Rails application embedded within it at\ntest/dummy. This application will mount the engine in the\ntest/dummy/config/routes.rb file:This line mounts the engine at the path /blorgh, which will make it accessible\nthrough the application only at that path.Inside the test directory there is the test/integration directory, where\nintegration tests for the engine should be placed. Other directories can be\ncreated in the test directory as well. For example, you may wish to create a\ntest/models directory for your model tests."},{"title":"3 Providing Engine Functionality","anchor":"#providing-engine-functionality","code":[],"body":"The engine that this guide covers provides submitting articles and commenting\nfunctionality and follows a similar thread to the Getting Started\nGuide, with some new twists."},{"title":"3.1 Generating an Article Resource","anchor":"#generating-an-article-resource","code":["\n$ bin/rails generate scaffold article title:string text:text\n\nbin/rails generate scaffold article title:string text:text\n\nCopy\n","\ninvoke  active_record\ncreate    db/migrate/[timestamp]_create_blorgh_articles.rb\ncreate    app/models/blorgh/article.rb\ninvoke    test_unit\ncreate      test/models/blorgh/article_test.rb\ncreate      test/fixtures/blorgh/articles.yml\ninvoke  resource_route\n route    resources :articles\ninvoke  scaffold_controller\ncreate    app/controllers/blorgh/articles_controller.rb\ninvoke    erb\ncreate      app/views/blorgh/articles\ncreate      app/views/blorgh/articles/index.html.erb\ncreate      app/views/blorgh/articles/edit.html.erb\ncreate      app/views/blorgh/articles/show.html.erb\ncreate      app/views/blorgh/articles/new.html.erb\ncreate      app/views/blorgh/articles/_form.html.erb\ninvoke    test_unit\ncreate      test/controllers/blorgh/articles_controller_test.rb\ncreate      test/system/blorgh/articles_test.rb\ninvoke    helper\ncreate      app/helpers/blorgh/articles_helper.rb\ninvoke      test_unit\ninvoke  assets\ninvoke    css\ncreate      app/assets/stylesheets/blorgh/articles.css\ninvoke  css\ncreate    app/assets/stylesheets/scaffold.css\n\ninvoke  active_record\ncreate    db/migrate/[timestamp]_create_blorgh_articles.rb\ncreate    app/models/blorgh/article.rb\ninvoke    test_unit\ncreate      test/models/blorgh/article_test.rb\ncreate      test/fixtures/blorgh/articles.yml\ninvoke  resource_route\n route    resources :articles\ninvoke  scaffold_controller\ncreate    app/controllers/blorgh/articles_controller.rb\ninvoke    erb\ncreate      app/views/blorgh/articles\ncreate      app/views/blorgh/articles/index.html.erb\ncreate      app/views/blorgh/articles/edit.html.erb\ncreate      app/views/blorgh/articles/show.html.erb\ncreate      app/views/blorgh/articles/new.html.erb\ncreate      app/views/blorgh/articles/_form.html.erb\ninvoke    test_unit\ncreate      test/controllers/blorgh/articles_controller_test.rb\ncreate      test/system/blorgh/articles_test.rb\ninvoke    helper\ncreate      app/helpers/blorgh/articles_helper.rb\ninvoke      test_unit\ninvoke  assets\ninvoke    css\ncreate      app/assets/stylesheets/blorgh/articles.css\ninvoke  css\ncreate    app/assets/stylesheets/scaffold.css\n\nCopy\n","\nBlorgh::Engine.routes.draw do\n  resources :articles\nend\n\nBlorgh::Engine.routes.draw do\n  resources :articles\nend\n\nCopy\n","\nmodule Blorgh\n  class ArticlesController < ApplicationController\n    # ...\n  end\nend\n\nmodule Blorgh\n  class ArticlesController < ApplicationController\n    # ...\n  end\nend\n\nCopy\n","\nmodule Blorgh\n  module ArticlesHelper\n    # ...\n  end\nend\n\nmodule Blorgh\n  module ArticlesHelper\n    # ...\n  end\nend\n\nCopy\n","\nirb> Blorgh::Article.find(1)\n=> #<Blorgh::Article id: 1 ...>\n\nBlorgh::Article.find(1)\n\nCopy\n","\nroot to: \"articles#index\"\n\nroot to: \"articles#index\"\n\nCopy\n"],"body":"The first thing to generate for a blog engine is the Article model and related\ncontroller. To quickly generate this, you can use the Rails scaffold generator.This command will output this information:The first thing that the scaffold generator does is invoke the active_record\ngenerator, which generates a migration and a model for the resource. Note here,\nhowever, that the migration is called create_blorgh_articles rather than the\nusual create_articles. This is due to the isolate_namespace method called in\nthe Blorgh::Engine class's definition. The model here is also namespaced,\nbeing placed at app/models/blorgh/article.rb rather than app/models/article.rb due\nto the isolate_namespace call within the Engine class.Next, the test_unit generator is invoked for this model, generating a model\ntest at test/models/blorgh/article_test.rb (rather than\ntest/models/article_test.rb) and a fixture at test/fixtures/blorgh/articles.yml\n(rather than test/fixtures/articles.yml).After that, a line for the resource is inserted into the config/routes.rb file\nfor the engine. This line is simply resources :articles, turning the\nconfig/routes.rb file for the engine into this:Note here that the routes are drawn upon the Blorgh::Engine object rather than\nthe YourApp::Application class. This is so that the engine routes are confined\nto the engine itself and can be mounted at a specific point as shown in the\ntest directory section. It also causes the engine's routes to\nbe isolated from those routes that are within the application. The\nRoutes section of this guide describes it in detail.Next, the scaffold_controller generator is invoked, generating a controller\ncalled Blorgh::ArticlesController (at\napp/controllers/blorgh/articles_controller.rb) and its related views at\napp/views/blorgh/articles. This generator also generates tests for the\ncontroller (test/controllers/blorgh/articles_controller_test.rb and test/system/blorgh/articles_test.rb) and a helper (app/helpers/blorgh/articles_helper.rb).Everything this generator has created is neatly namespaced. The controller's\nclass is defined within the Blorgh module:The helper inside app/helpers/blorgh/articles_helper.rb is also namespaced:This helps prevent conflicts with any other engine or application that may have\nan article resource as well.Finally, the assets for this resource are generated in one file: app/assets/stylesheets/blorgh/articles.css. You'll see how to use these a little later.You can see what the engine has so far by running bin/rails db:migrate at the root\nof our engine to run the migration generated by the scaffold generator, and then\nrunning bin/rails server in test/dummy. When you open\nhttp://localhost:3000/blorgh/articles you will see the default scaffold that has\nbeen generated. Click around! You've just generated your first engine's first\nfunctions.If you'd rather play around in the console, bin/rails console will also work just\nlike a Rails application. Remember: the Article model is namespaced, so to\nreference it you must call it as Blorgh::Article.One final thing is that the articles resource for this engine should be the root\nof the engine. Whenever someone goes to the root path where the engine is\nmounted, they should be shown a list of articles. This can be made to happen if\nthis line is inserted into the config/routes.rb file inside the engine:Now people will only need to go to the root of the engine to see all the articles,\nrather than visiting /articles. This means that instead of\nhttp://localhost:3000/blorgh/articles, you only need to go to\nhttp://localhost:3000/blorgh now."},{"title":"3.2 Generating a Comments Resource","anchor":"#generating-a-comments-resource","code":["\n$ bin/rails generate model Comment article_id:integer text:text\n\nbin/rails generate model Comment article_id:integer text:text\n\nCopy\n","\ninvoke  active_record\ncreate    db/migrate/[timestamp]_create_blorgh_comments.rb\ncreate    app/models/blorgh/comment.rb\ninvoke    test_unit\ncreate      test/models/blorgh/comment_test.rb\ncreate      test/fixtures/blorgh/comments.yml\n\ninvoke  active_record\ncreate    db/migrate/[timestamp]_create_blorgh_comments.rb\ncreate    app/models/blorgh/comment.rb\ninvoke    test_unit\ncreate      test/models/blorgh/comment_test.rb\ncreate      test/fixtures/blorgh/comments.yml\n\nCopy\n","\n$ bin/rails db:migrate\n\nbin/rails db:migrate\n\nCopy\n","\n<h3>Comments</h3>\n<%= render @article.comments %>\n\n<h3>Comments</h3>\n<%= render @article.comments %>\n\nCopy\n","\nhas_many :comments\n\nhas_many :comments\n\nCopy\n","\nmodule Blorgh\n  class Article < ApplicationRecord\n    has_many :comments\n  end\nend\n\nmodule Blorgh\n  class Article < ApplicationRecord\n    has_many :comments\n  end\nend\n\nCopy\n","\n<%= render \"blorgh/comments/form\" %>\n\n<%= render \"blorgh/comments/form\" %>\n\nCopy\n","\n<h3>New comment</h3>\n<%= form_with model: [@article, @article.comments.build] do |form| %>\n  <p>\n    <%= form.label :text %><br>\n    <%= form.text_area :text %>\n  </p>\n  <%= form.submit %>\n<% end %>\n\n<h3>New comment</h3>\n<%= form_with model: [@article, @article.comments.build] do |form| %>\n  <p>\n    <%= form.label :text %><br>\n    <%= form.text_area :text %>\n  </p>\n  <%= form.submit %>\n<% end %>\n\nCopy\n","\nresources :articles do\n  resources :comments\nend\n\nresources :articles do\n  resources :comments\nend\n\nCopy\n","\n$ bin/rails generate controller comments\n\nbin/rails generate controller comments\n\nCopy\n","\ncreate  app/controllers/blorgh/comments_controller.rb\ninvoke  erb\n exist    app/views/blorgh/comments\ninvoke  test_unit\ncreate    test/controllers/blorgh/comments_controller_test.rb\ninvoke  helper\ncreate    app/helpers/blorgh/comments_helper.rb\ninvoke    test_unit\ninvoke  assets\ninvoke    css\ncreate      app/assets/stylesheets/blorgh/comments.css\n\ncreate  app/controllers/blorgh/comments_controller.rb\ninvoke  erb\n exist    app/views/blorgh/comments\ninvoke  test_unit\ncreate    test/controllers/blorgh/comments_controller_test.rb\ninvoke  helper\ncreate    app/helpers/blorgh/comments_helper.rb\ninvoke    test_unit\ninvoke  assets\ninvoke    css\ncreate      app/assets/stylesheets/blorgh/comments.css\n\nCopy\n","\ndef create\n  @article = Article.find(params[:article_id])\n  @comment = @article.comments.create(comment_params)\n  flash[:notice] = \"Comment has been created!\"\n  redirect_to articles_path\nend\n\nprivate\n  def comment_params\n    params.require(:comment).permit(:text)\n  end\n\ndef create\n  @article = Article.find(params[:article_id])\n  @comment = @article.comments.create(comment_params)\n  flash[:notice] = \"Comment has been created!\"\n  redirect_to articles_path\nend\n\nprivate\n  def comment_params\n    params.require(:comment).permit(:text)\n  end\n\nCopy\n","\nMissing partial blorgh/comments/_comment with {:handlers=>[:erb, :builder],\n:formats=>[:html], :locale=>[:en, :en]}. Searched in:   *\n\"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views\"   *\n\"/Users/ryan/Sites/side_projects/blorgh/app/views\"\n\nMissing partial blorgh/comments/_comment with {:handlers=>[:erb, :builder],\n:formats=>[:html], :locale=>[:en, :en]}. Searched in:   *\n\"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views\"   *\n\"/Users/ryan/Sites/side_projects/blorgh/app/views\"\n\nCopy\n","\n<%= comment_counter + 1 %>. <%= comment.text %>\n\n<%= comment_counter + 1 %>. <%= comment.text %>\n\nCopy\n"],"body":"Now that the engine can create new articles, it only makes sense to add\ncommenting functionality as well. To do this, you'll need to generate a comment\nmodel, a comment controller, and then modify the articles scaffold to display\ncomments and allow people to create new ones.From the engine root, run the model generator. Tell it to generate a\nComment model, with the related table having two columns: an article_id integer\nand text text column.This will output the following:This generator call will generate just the necessary model files it needs,\nnamespacing the files under a blorgh directory and creating a model class\ncalled Blorgh::Comment. Now run the migration to create our blorgh_comments\ntable:To show the comments on an article, edit app/views/blorgh/articles/show.html.erb and\nadd this line before the \"Edit\" link:This line will require there to be a has_many association for comments defined\non the Blorgh::Article model, which there isn't right now. To define one, open\napp/models/blorgh/article.rb and add this line into the model:Turning the model into this:Next, there needs to be a form so that comments can be created on an article. To\nadd this, put this line underneath the call to render @article.comments in\napp/views/blorgh/articles/show.html.erb:Next, the partial that this line will render needs to exist. Create a new\ndirectory at app/views/blorgh/comments and in it a new file called\n_form.html.erb which has this content to create the required partial:When this form is submitted, it is going to attempt to perform a POST request\nto a route of /articles/:article_id/comments within the engine. This route doesn't\nexist at the moment, but can be created by changing the resources :articles line\ninside config/routes.rb into these lines:This creates a nested route for the comments, which is what the form requires.The route now exists, but the controller that this route goes to does not. To\ncreate it, run this command from the engine root:This will generate the following things:The form will be making a POST request to /articles/:article_id/comments, which\nwill correspond with the create action in Blorgh::CommentsController. This\naction needs to be created, which can be done by putting the following lines\ninside the class definition in app/controllers/blorgh/comments_controller.rb:This is the final step required to get the new comment form working. Displaying\nthe comments, however, is not quite right yet. If you were to create a comment\nright now, you would see this error:The engine is unable to find the partial required for rendering the comments.\nRails looks first in the application's (test/dummy) app/views directory and\nthen in the engine's app/views directory. When it can't find it, it will throw\nthis error. The engine knows to look for blorgh/comments/_comment because the\nmodel object it is receiving is from the Blorgh::Comment class.This partial will be responsible for rendering just the comment text, for now.\nCreate a new file at app/views/blorgh/comments/_comment.html.erb and put this\nline inside it:The comment_counter local variable is given to us by the <%= render\n@article.comments %> call, which will define it automatically and increment the\ncounter as it iterates through each comment. It's used in this example to\ndisplay a small number next to each comment when it's created.That completes the comment function of the blogging engine. Now it's time to use\nit within an application."},{"title":"4 Hooking Into an Application","anchor":"#hooking-into-an-application","code":[],"body":"Using an engine within an application is very easy. This section covers how to\nmount the engine into an application and the initial setup required, as well as\nlinking the engine to a User class provided by the application to provide\nownership for articles and comments within the engine."},{"title":"4.1 Mounting the Engine","anchor":"#mounting-the-engine","code":["\n$ rails new unicorn\n\nrails new unicorn\n\nCopy\n","\ngem 'devise'\n\ngem 'devise'\n\nCopy\n","\ngem 'blorgh', path: 'engines/blorgh'\n\ngem 'blorgh', path: 'engines/blorgh'\n\nCopy\n","\nmount Blorgh::Engine, at: \"/blog\"\n\nmount Blorgh::Engine, at: \"/blog\"\n\nCopy\n"],"body":"First, the engine needs to be specified inside the application's Gemfile. If\nthere isn't an application handy to test this out in, generate one using the\nrails new command outside of the engine directory like this:Usually, specifying the engine inside the Gemfile would be done by specifying it\nas a normal, everyday gem.However, because you are developing the blorgh engine on your local machine,\nyou will need to specify the :path option in your Gemfile:Then run bundle to install the gem.As described earlier, by placing the gem in the Gemfile it will be loaded when\nRails is loaded. It will first require lib/blorgh.rb from the engine, then\nlib/blorgh/engine.rb, which is the file that defines the major pieces of\nfunctionality for the engine.To make the engine's functionality accessible from within an application, it\nneeds to be mounted in that application's config/routes.rb file:This line will mount the engine at /blog in the application. Making it\naccessible at http://localhost:3000/blog when the application runs with bin/rails\nserver."},{"title":"4.2 Engine Setup","anchor":"#engine-setup","code":["\n$ bin/rails blorgh:install:migrations\n\nbin/rails blorgh:install:migrations\n\nCopy\n","\n$ bin/rails railties:install:migrations\n\nbin/rails railties:install:migrations\n\nCopy\n","\nCopied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh\nCopied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh\n\nCopied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh\nCopied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh\n\nCopy\n","\n$ bin/rails db:migrate SCOPE=blorgh\n\nbin/rails db:migrate SCOPE=blorgh\n\nCopy\n","\n$ bin/rails db:migrate SCOPE=blorgh VERSION=0\n\nbin/rails db:migrate SCOPE=blorgh VERSION=0\n\nCopy\n"],"body":"The engine contains migrations for the blorgh_articles and blorgh_comments\ntable which need to be created in the application's database so that the\nengine's models can query them correctly. To copy these migrations into the\napplication run the following command from the application's root:If you have multiple engines that need migrations copied over, use\nrailties:install:migrations instead:This command, when run for the first time, will copy over all the migrations\nfrom the engine. When run the next time, it will only copy over migrations that\nhaven't been copied over already. The first run for this command will output\nsomething such as this:The first timestamp ([timestamp_1]) will be the current time, and the second\ntimestamp ([timestamp_2]) will be the current time plus a second. The reason\nfor this is so that the migrations for the engine are run after any existing\nmigrations in the application.To run these migrations within the context of the application, simply run bin/rails\ndb:migrate. When accessing the engine through http://localhost:3000/blog, the\narticles will be empty. This is because the table created inside the application is\ndifferent from the one created within the engine. Go ahead, play around with the\nnewly mounted engine. You'll find that it's the same as when it was only an\nengine.If you would like to run migrations only from one engine, you can do it by\nspecifying SCOPE:This may be useful if you want to revert engine's migrations before removing it.\nTo revert all migrations from blorgh engine you can run code such as:"},{"code":[],"body":"","title":"4.3 Using a Class Provided by the Application","anchor":"#using-a-class-provided-by-the-application"},{"title":"4.3.1 Using a Model Provided by the Application","anchor":"#using-a-model-provided-by-the-application","code":["\n$ bin/rails generate model user name:string\n\nbin/rails generate model user name:string\n\nCopy\n","\n<div class=\"field\">\n  <%= form.label :author_name %><br>\n  <%= form.text_field :author_name %>\n</div>\n\n<div class=\"field\">\n  <%= form.label :author_name %><br>\n  <%= form.text_field :author_name %>\n</div>\n\nCopy\n","\ndef article_params\n  params.require(:article).permit(:title, :text, :author_name)\nend\n\ndef article_params\n  params.require(:article).permit(:title, :text, :author_name)\nend\n\nCopy\n","\nattr_accessor :author_name\nbelongs_to :author, class_name: \"User\"\n\nbefore_validation :set_author\n\nprivate\n  def set_author\n    self.author = User.find_or_create_by(name: author_name)\n  end\n\nattr_accessor :author_name\nbelongs_to :author, class_name: \"User\"\n\nbefore_validation :set_author\n\nprivate\n  def set_author\n    self.author = User.find_or_create_by(name: author_name)\n  end\n\nCopy\n","\n$ bin/rails generate migration add_author_id_to_blorgh_articles author_id:integer\n\nbin/rails generate migration add_author_id_to_blorgh_articles author_id:integer\n\nCopy\n","\n$ bin/rails blorgh:install:migrations\n\nbin/rails blorgh:install:migrations\n\nCopy\n","\nNOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.\nNOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.\nCopied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh\n\nNOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.\nNOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.\nCopied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh\n\nCopy\n","\n$ bin/rails db:migrate\n\nbin/rails db:migrate\n\nCopy\n","\n<p>\n  <b>Author:</b>\n  <%= @article.author.name %>\n</p>\n\n<p>\n  <b>Author:</b>\n  <%= @article.author.name %>\n</p>\n\nCopy\n"],"body":"When an engine is created, it may want to use specific classes from an\napplication to provide links between the pieces of the engine and the pieces of\nthe application. In the case of the blorgh engine, making articles and comments\nhave authors would make a lot of sense.A typical application might have a User class that would be used to represent\nauthors for an article or a comment. But there could be a case where the\napplication calls this class something different, such as Person. For this\nreason, the engine should not hardcode associations specifically for a User\nclass.To keep it simple in this case, the application will have a class called User\nthat represents the users of the application (we'll get into making this\nconfigurable further on). It can be generated using this command inside the\napplication:The bin/rails db:migrate command needs to be run here to ensure that our\napplication has the users table for future use.Also, to keep it simple, the articles form will have a new text field called\nauthor_name, where users can elect to put their name. The engine will then\ntake this name and either create a new User object from it, or find one that\nalready has that name. The engine will then associate the article with the found or\ncreated User object.First, the author_name text field needs to be added to the\napp/views/blorgh/articles/_form.html.erb partial inside the engine. This can be\nadded above the title field with this code:Next, we need to update our Blorgh::ArticlesController#article_params method to\npermit the new form parameter:The Blorgh::Article model should then have some code to convert the author_name\nfield into an actual User object and associate it as that article's author\nbefore the article is saved. It will also need to have an attr_accessor set up\nfor this field, so that the setter and getter methods are defined for it.To do all this, you'll need to add the attr_accessor for author_name, the\nassociation for the author and the before_validation call into\napp/models/blorgh/article.rb. The author association will be hard-coded to the\nUser class for the time being.By representing the author association's object with the User class, a link\nis established between the engine and the application. There needs to be a way\nof associating the records in the blorgh_articles table with the records in the\nusers table. Because the association is called author, there should be an\nauthor_id column added to the blorgh_articles table.To generate this new column, run this command within the engine:This migration will need to be run on the application. To do that, it must first\nbe copied using this command:Notice that only one migration was copied over here. This is because the first\ntwo migrations were copied over the first time this command was run.Run the migration using:Now with all the pieces in place, an action will take place that will associate\nan author - represented by a record in the users table - with an article,\nrepresented by the blorgh_articles table from the engine.Finally, the author's name should be displayed on the article's page. Add this code\nabove the \"Title\" output inside app/views/blorgh/articles/show.html.erb:"},{"code":["\nmodule Blorgh\n  class ApplicationController < ::ApplicationController\n  end\nend\n\nmodule Blorgh\n  class ApplicationController < ::ApplicationController\n  end\nend\n\nCopy\n"],"body":"Because Rails controllers generally share code for things like authentication\nand accessing session variables, they inherit from ApplicationController by\ndefault. Rails engines, however are scoped to run independently from the main\napplication, so each engine gets a scoped ApplicationController. This\nnamespace prevents code collisions, but often engine controllers need to access\nmethods in the main application's ApplicationController. An easy way to\nprovide this access is to change the engine's scoped ApplicationController to\ninherit from the main application's ApplicationController. For our Blorgh\nengine this would be done by changing\napp/controllers/blorgh/application_controller.rb to look like:By default, the engine's controllers inherit from\nBlorgh::ApplicationController. So, after making this change they will have\naccess to the main application's ApplicationController, as though they were\npart of the main application.This change does require that the engine is run from a Rails application that\nhas an ApplicationController.","title":"4.3.2 Using a Controller Provided by the Application","anchor":"#using-a-controller-provided-by-the-application"},{"title":"4.4 Configuring an Engine","anchor":"#configuring-an-engine","code":[],"body":"This section covers how to make the User class configurable, followed by\ngeneral configuration tips for the engine."},{"title":"4.4.1 Setting Configuration Settings in the Application","anchor":"#setting-configuration-settings-in-the-application","code":["\nmattr_accessor :author_class\n\nmattr_accessor :author_class\n\nCopy\n","\nbelongs_to :author, class_name: Blorgh.author_class\n\nbelongs_to :author, class_name: Blorgh.author_class\n\nCopy\n","\nself.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name)\n\nself.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name)\n\nCopy\n","\ndef self.author_class\n  @@author_class.constantize\nend\n\ndef self.author_class\n  @@author_class.constantize\nend\n\nCopy\n","\nself.author = Blorgh.author_class.find_or_create_by(name: author_name)\n\nself.author = Blorgh.author_class.find_or_create_by(name: author_name)\n\nCopy\n","\nbelongs_to :author, class_name: Blorgh.author_class.to_s\n\nbelongs_to :author, class_name: Blorgh.author_class.to_s\n\nCopy\n","\nBlorgh.author_class = \"User\"\n\nBlorgh.author_class = \"User\"\n\nCopy\n"],"body":"The next step is to make the class that represents a User in the application\ncustomizable for the engine. This is because that class may not always be\nUser, as previously explained. To make this setting customizable, the engine\nwill have a configuration setting called author_class that will be used to\nspecify which class represents users inside the application.To define this configuration setting, you should use a mattr_accessor inside\nthe Blorgh module for the engine. Add this line to lib/blorgh.rb inside the\nengine:This method works like its siblings, attr_accessor and cattr_accessor, but\nprovides a setter and getter method on the module with the specified name. To\nuse it, it must be referenced using Blorgh.author_class.The next step is to switch the Blorgh::Article model over to this new setting.\nChange the belongs_to association inside this model\n(app/models/blorgh/article.rb) to this:The set_author method in the Blorgh::Article model should also use this class:To save having to call constantize on the author_class result all the time,\nyou could instead just override the author_class getter method inside the\nBlorgh module in the lib/blorgh.rb file to always call constantize on the\nsaved value before returning the result:This would then turn the above code for set_author into this:Resulting in something a little shorter, and more implicit in its behavior. The\nauthor_class method should always return a Class object.Since we changed the author_class method to return a Class instead of a\nString, we must also modify our belongs_to definition in the Blorgh::Article\nmodel:To set this configuration setting within the application, an initializer should\nbe used. By using an initializer, the configuration will be set up before the\napplication starts and calls the engine's models, which may depend on this\nconfiguration setting existing.Create a new initializer at config/initializers/blorgh.rb inside the\napplication where the blorgh engine is installed and put this content in it:Go ahead and try to create a new article. You will see that it works exactly in the\nsame way as before, except this time the engine is using the configuration\nsetting in config/initializers/blorgh.rb to learn what the class is.There are now no strict dependencies on what the class is, only what the API for\nthe class must be. The engine simply requires this class to define a\nfind_or_create_by method which returns an object of that class, to be\nassociated with an article when it's created. This object, of course, should have\nsome sort of identifier by which it can be referenced."},{"title":"4.4.2 General Engine Configuration","anchor":"#general-engine-configuration","code":[],"body":"Within an engine, there may come a time where you wish to use things such as\ninitializers, internationalization, or other configuration options. The great\nnews is that these things are entirely possible, because a Rails engine shares\nmuch the same functionality as a Rails application. In fact, a Rails\napplication's functionality is actually a superset of what is provided by\nengines!If you wish to use an initializer - code that should run before the engine is\nloaded - the place for it is the config/initializers folder. This directory's\nfunctionality is explained in the Initializers\nsection of the Configuring guide, and works\nprecisely the same way as the config/initializers directory inside an\napplication. The same thing goes if you want to use a standard initializer.For locales, simply place the locale files in the config/locales directory,\njust like you would in an application."},{"title":"5 Testing an Engine","anchor":"#testing-an-engine","code":[],"body":"When an engine is generated, there is a smaller dummy application created inside\nit at test/dummy. This application is used as a mounting point for the engine,\nto make testing the engine extremely simple. You may extend this application by\ngenerating controllers, models, or views from within the directory, and then use\nthose to test your engine.The test directory should be treated like a typical Rails testing environment,\nallowing for unit, functional, and integration tests."},{"title":"5.1 Functional Tests","anchor":"#functional-tests","code":["\nmodule Blorgh\n  class FooControllerTest < ActionDispatch::IntegrationTest\n    include Engine.routes.url_helpers\n\n    def test_index\n      get foos_url\n      # ...\n    end\n  end\nend\n\nmodule Blorgh\n  class FooControllerTest < ActionDispatch::IntegrationTest\n    include Engine.routes.url_helpers\n\n    def test_index\n      get foos_url\n      # ...\n    end\n  end\nend\n\nCopy\n","\nmodule Blorgh\n  class FooControllerTest < ActionDispatch::IntegrationTest\n    include Engine.routes.url_helpers\n\n    setup do\n      @routes = Engine.routes\n    end\n\n    def test_index\n      get foos_url\n      # ...\n    end\n  end\nend\n\nmodule Blorgh\n  class FooControllerTest < ActionDispatch::IntegrationTest\n    include Engine.routes.url_helpers\n\n    setup do\n      @routes = Engine.routes\n    end\n\n    def test_index\n      get foos_url\n      # ...\n    end\n  end\nend\n\nCopy\n"],"body":"A matter worth taking into consideration when writing functional tests is that\nthe tests are going to be running on an application - the test/dummy\napplication - rather than your engine. This is due to the setup of the testing\nenvironment; an engine needs an application as a host for testing its main\nfunctionality, especially controllers. This means that if you were to make a\ntypical GET to a controller in a controller's functional test like this:It may not function correctly. This is because the application doesn't know how\nto route these requests to the engine unless you explicitly tell it how. To\ndo this, you must set the @routes instance variable to the engine's route set\nin your setup code:This tells the application that you still want to perform a GET request to the\nindex action of this controller, but you want to use the engine's route to get\nthere, rather than the application's one.This also ensures that the engine's URL helpers will work as expected in your\ntests."},{"title":"6 Improving Engine Functionality","anchor":"#improving-engine-functionality","code":[],"body":"This section explains how to add and/or override engine MVC functionality in the\nmain Rails application."},{"title":"6.1 Overriding Models and Controllers","anchor":"#overriding-models-and-controllers","code":["\n# config/application.rb\nmodule MyApp\n  class Application < Rails::Application\n    # ...\n\n    overrides = \"#{Rails.root}/app/overrides\"\n    Rails.autoloaders.main.ignore(overrides)\n    config.to_prepare do\n      Dir.glob(\"#{overrides}/**/*_override.rb\").each do |override|\n        load override\n      end\n    end\n  end\nend\n\n# config/application.rb\nmodule MyApp\n  class Application < Rails::Application\n    # ...\n\n    overrides = \"#{Rails.root}/app/overrides\"\n    Rails.autoloaders.main.ignore(overrides)\n    config.to_prepare do\n      Dir.glob(\"#{overrides}/**/*_override.rb\").each do |override|\n        load override\n      end\n    end\n  end\nend\n\nCopy\n","\n# config/application.rb\nmodule MyApp\n  class Application < Rails::Application\n    # ...\n\n    config.to_prepare do\n      Dir.glob(\"#{Rails.root}/app/overrides/**/*_override.rb\").each do |override|\n        require_dependency override\n      end\n    end\n  end\nend\n\n# config/application.rb\nmodule MyApp\n  class Application < Rails::Application\n    # ...\n\n    config.to_prepare do\n      Dir.glob(\"#{Rails.root}/app/overrides/**/*_override.rb\").each do |override|\n        require_dependency override\n      end\n    end\n  end\nend\n\nCopy\n"],"body":"Engine models and controllers can be reopened by the parent application to extend or decorate them.Overrides may be organized in a dedicated directory app/overrides that is preloaded in a to_prepare callback.In zeitwerk mode you'd do this:and in classic mode this:"},{"code":["\n# Blorgh/app/models/blorgh/article.rb\nmodule Blorgh\n  class Article < ApplicationRecord\n    has_many :comments\n\n    def summary\n      \"#{title}\"\n    end\n  end\nend\n\n# Blorgh/app/models/blorgh/article.rb\nmodule Blorgh\n  class Article < ApplicationRecord\n    has_many :comments\n\n    def summary\n      \"#{title}\"\n    end\n  end\nend\n\nCopy\n","\n# MyApp/app/overrides/models/blorgh/article_override.rb\nBlorgh::Article.class_eval do\n  def time_since_created\n    Time.current - created_at\n  end\n\n  def summary\n    \"#{title} - #{truncate(text)}\"\n  end\nend\n\n# MyApp/app/overrides/models/blorgh/article_override.rb\nBlorgh::Article.class_eval do\n  def time_since_created\n    Time.current - created_at\n  end\n\n  def summary\n    \"#{title} - #{truncate(text)}\"\n  end\nend\n\nCopy\n"],"body":"For example, in order to override the engine modelyou just create a file that reopens that class:It is very important that the override reopens the class or module. Using the class or module keywords would define them if they were not already in memory, which would be incorrect because the definition lives in the engine. Using class_eval as shown above ensures you are reopening.","title":"6.1.1 Reopening existing classes using class_eval","anchor":"#reopening-existing-classes-using-class-eval"},{"title":"6.1.2 Reopening existing classes using ActiveSupport::Concern","anchor":"#reopening-existing-classes-using-activesupport-concern","code":["\n# MyApp/app/models/blorgh/article.rb\n\nclass Blorgh::Article < ApplicationRecord\n  include Blorgh::Concerns::Models::Article\n\n  def time_since_created\n    Time.current - created_at\n  end\n\n  def summary\n    \"#{title} - #{truncate(text)}\"\n  end\nend\n\n# MyApp/app/models/blorgh/article.rb\n\nclass Blorgh::Article < ApplicationRecord\n  include Blorgh::Concerns::Models::Article\n\n  def time_since_created\n    Time.current - created_at\n  end\n\n  def summary\n    \"#{title} - #{truncate(text)}\"\n  end\nend\n\nCopy\n","\n# Blorgh/app/models/blorgh/article.rb\nmodule Blorgh\n  class Article < ApplicationRecord\n    include Blorgh::Concerns::Models::Article\n  end\nend\n\n# Blorgh/app/models/blorgh/article.rb\nmodule Blorgh\n  class Article < ApplicationRecord\n    include Blorgh::Concerns::Models::Article\n  end\nend\n\nCopy\n","\n# Blorgh/lib/concerns/models/article.rb\n\nmodule Blorgh::Concerns::Models::Article\n  extend ActiveSupport::Concern\n\n  # 'included do' causes the included code to be evaluated in the\n  # context where it is included (article.rb), rather than being\n  # executed in the module's context (blorgh/concerns/models/article).\n  included do\n    attr_accessor :author_name\n    belongs_to :author, class_name: \"User\"\n\n    before_validation :set_author\n\n    private\n      def set_author\n        self.author = User.find_or_create_by(name: author_name)\n      end\n  end\n\n  def summary\n    \"#{title}\"\n  end\n\n  module ClassMethods\n    def some_class_method\n      'some class method string'\n    end\n  end\nend\n\n# Blorgh/lib/concerns/models/article.rb\n\nmodule Blorgh::Concerns::Models::Article\n  extend ActiveSupport::Concern\n\n  # 'included do' causes the included code to be evaluated in the\n  # context where it is included (article.rb), rather than being\n  # executed in the module's context (blorgh/concerns/models/article).\n  included do\n    attr_accessor :author_name\n    belongs_to :author, class_name: \"User\"\n\n    before_validation :set_author\n\n    private\n      def set_author\n        self.author = User.find_or_create_by(name: author_name)\n      end\n  end\n\n  def summary\n    \"#{title}\"\n  end\n\n  module ClassMethods\n    def some_class_method\n      'some class method string'\n    end\n  end\nend\n\nCopy\n"],"body":"Using Class#class_eval is great for simple adjustments, but for more complex\nclass modifications, you might want to consider using ActiveSupport::Concern.\nActiveSupport::Concern manages load order of interlinked dependent modules and\nclasses at run time allowing you to significantly modularize your code.Adding Article#time_since_created and Overriding Article#summary:"},{"code":["\n<h1>Articles</h1>\n<%= link_to \"New Article\", new_article_path %>\n<% @articles.each do |article| %>\n  <h2><%= article.title %></h2>\n  <small>By <%= article.author %></small>\n  <%= simple_format(article.text) %>\n  <hr>\n<% end %>\n\n<h1>Articles</h1>\n<%= link_to \"New Article\", new_article_path %>\n<% @articles.each do |article| %>\n  <h2><%= article.title %></h2>\n  <small>By <%= article.author %></small>\n  <%= simple_format(article.text) %>\n  <hr>\n<% end %>\n\nCopy\n"],"body":"When Rails looks for a view to render, it will first look in the app/views\ndirectory of the application. If it cannot find the view there, it will check in\nthe app/views directories of all engines that have this directory.When the application is asked to render the view for Blorgh::ArticlesController's\nindex action, it will first look for the path\napp/views/blorgh/articles/index.html.erb within the application. If it cannot\nfind it, it will look inside the engine.You can override this view in the application by simply creating a new file at\napp/views/blorgh/articles/index.html.erb. Then you can completely change what\nthis view would normally output.Try this now by creating a new file at app/views/blorgh/articles/index.html.erb\nand put this content in it:","title":"6.2 Overriding Views","anchor":"#overriding-views"},{"code":["\nBlorgh::Engine.routes.draw do\n  resources :articles\nend\n\nBlorgh::Engine.routes.draw do\n  resources :articles\nend\n\nCopy\n","\n<%= link_to \"Blog articles\", articles_path %>\n\n<%= link_to \"Blog articles\", articles_path %>\n\nCopy\n","\n<%= link_to \"Blog articles\", blorgh.articles_path %>\n\n<%= link_to \"Blog articles\", blorgh.articles_path %>\n\nCopy\n","\n<%= link_to \"Home\", main_app.root_path %>\n\n<%= link_to \"Home\", main_app.root_path %>\n\nCopy\n"],"body":"Routes inside an engine are isolated from the application by default. This is\ndone by the isolate_namespace call inside the Engine class. This essentially\nmeans that the application and its engines can have identically named routes and\nthey will not clash.Routes inside an engine are drawn on the Engine class within\nconfig/routes.rb, like this:By having isolated routes such as this, if you wish to link to an area of an\nengine from within an application, you will need to use the engine's routing\nproxy method. Calls to normal routing methods such as articles_path may end up\ngoing to undesired locations if both the application and the engine have such a\nhelper defined.For instance, the following example would go to the application's articles_path\nif that template was rendered from the application, or the engine's articles_path\nif it was rendered from the engine:To make this route always use the engine's articles_path routing helper method,\nwe must call the method on the routing proxy method that shares the same name as\nthe engine.If you wish to reference the application inside the engine in a similar way, use\nthe main_app helper:If you were to use this inside an engine, it would always go to the\napplication's root. If you were to leave off the main_app \"routing proxy\"\nmethod call, it could potentially go to the engine's or application's root,\ndepending on where it was called from.If a template rendered from within an engine attempts to use one of the\napplication's routing helper methods, it may result in an undefined method call.\nIf you encounter such an issue, ensure that you're not attempting to call the\napplication's routing methods without the main_app prefix from within the\nengine.","title":"6.3 Routes","anchor":"#routes"},{"title":"6.4 Assets","anchor":"#assets","code":["\n<%= stylesheet_link_tag \"blorgh/style.css\" %>\n\n<%= stylesheet_link_tag \"blorgh/style.css\" %>\n\nCopy\n","\n/*\n *= require blorgh/style\n */\n\n/*\n *= require blorgh/style\n */\n\nCopy\n"],"body":"Assets within an engine work in an identical way to a full application. Because\nthe engine class inherits from Rails::Engine, the application will know to\nlook up assets in the engine's app/assets and lib/assets directories.Like all of the other components of an engine, the assets should be namespaced.\nThis means that if you have an asset called style.css, it should be placed at\napp/assets/stylesheets/[engine name]/style.css, rather than\napp/assets/stylesheets/style.css. If this asset isn't namespaced, there is a\npossibility that the host application could have an asset named identically, in\nwhich case the application's asset would take precedence and the engine's one\nwould be ignored.Imagine that you did have an asset located at\napp/assets/stylesheets/blorgh/style.css. To include this asset inside an\napplication, just use stylesheet_link_tag and reference the asset as if it\nwere inside the engine:You can also specify these assets as dependencies of other assets using Asset\nPipeline require statements in processed files:"},{"title":"6.5 Separate Assets and Precompiling","anchor":"#separate-assets-and-precompiling","code":["\ninitializer \"blorgh.assets.precompile\" do |app|\n  app.config.assets.precompile += %w( admin.js admin.css )\nend\n\ninitializer \"blorgh.assets.precompile\" do |app|\n  app.config.assets.precompile += %w( admin.js admin.css )\nend\n\nCopy\n"],"body":"There are some situations where your engine's assets are not required by the\nhost application. For example, say that you've created an admin functionality\nthat only exists for your engine. In this case, the host application doesn't\nneed to require admin.css or admin.js. Only the gem's admin layout needs\nthese assets. It doesn't make sense for the host app to include\n\"blorgh/admin.css\" in its stylesheets. In this situation, you should\nexplicitly define these assets for precompilation.  This tells Sprockets to add\nyour engine assets when bin/rails assets:precompile is triggered.You can define assets for precompilation in engine.rb:For more information, read the Asset Pipeline guide."},{"title":"6.6 Other Gem Dependencies","anchor":"#other-gem-dependencies","code":["\ns.add_dependency \"moo\"\n\ns.add_dependency \"moo\"\n\nCopy\n","\ns.add_development_dependency \"moo\"\n\ns.add_development_dependency \"moo\"\n\nCopy\n","\nrequire \"other_engine/engine\"\nrequire \"yet_another_engine/engine\"\n\nmodule MyEngine\n  class Engine < ::Rails::Engine\n  end\nend\n\nrequire \"other_engine/engine\"\nrequire \"yet_another_engine/engine\"\n\nmodule MyEngine\n  class Engine < ::Rails::Engine\n  end\nend\n\nCopy\n"],"body":"Gem dependencies inside an engine should be specified inside the .gemspec file\nat the root of the engine. The reason is that the engine may be installed as a\ngem. If dependencies were to be specified inside the Gemfile, these would not\nbe recognized by a traditional gem install and so they would not be installed,\ncausing the engine to malfunction.To specify a dependency that should be installed with the engine during a\ntraditional gem install, specify it inside the Gem::Specification block\ninside the .gemspec file in the engine:To specify a dependency that should only be installed as a development\ndependency of the application, specify it like this:Both kinds of dependencies will be installed when bundle install is run inside\nof the application. The development dependencies for the gem will only be used\nwhen the development and tests for the engine are running.Note that if you want to immediately require dependencies when the engine is\nrequired, you should require them before the engine's initialization. For\nexample:"},{"code":[],"body":"Rails code can often be referenced on load of an application. Rails is responsible for the load order of these frameworks, so when you load frameworks, such as ActiveRecord::Base, prematurely you are violating an implicit contract your application has with Rails. Moreover, by loading code such as ActiveRecord::Base on boot of your application you are loading entire frameworks which may slow down your boot time and could cause conflicts with load order and boot of your application.Load and configuration hooks are the API that allow you to hook into this initialization process without violating the load contract with Rails. This will also mitigate boot performance degradation and avoid conflicts.","title":"7 Load and Configuration Hooks","anchor":"#load-and-configuration-hooks"},{"title":"7.1 Avoid loading Rails Frameworks","anchor":"#avoid-loading-rails-frameworks","code":["\nActiveRecord::Base.include(MyActiveRecordHelper)\n\nActiveRecord::Base.include(MyActiveRecordHelper)\n\nCopy\n","\nActiveSupport.on_load(:active_record) do\n  include MyActiveRecordHelper\nend\n\nActiveSupport.on_load(:active_record) do\n  include MyActiveRecordHelper\nend\n\nCopy\n"],"body":"Since Ruby is a dynamic language, some code will cause different Rails frameworks to load. Take this snippet for instance:This snippet means that when this file is loaded, it will encounter ActiveRecord::Base. This encounter causes Ruby to look for the definition of that constant and will require it. This causes the entire Active Record framework to be loaded on boot.ActiveSupport.on_load is a mechanism that can be used to defer the loading of code until it is actually needed. The snippet above can be changed to:This new snippet will only include MyActiveRecordHelper when ActiveRecord::Base is loaded."},{"title":"7.2 When are Hooks called?","anchor":"#when-are-hooks-called-questionmark","code":[],"body":"In the Rails framework these hooks are called when a specific library is loaded. For example, when ActionController::Base is loaded, the :action_controller_base hook is called. This means that all ActiveSupport.on_load calls with :action_controller_base hooks will be called in the context of ActionController::Base (that means self will be an ActionController::Base)."},{"title":"7.3 Modifying Code to use Load Hooks","anchor":"#modifying-code-to-use-load-hooks","code":["\nActiveRecord::Base.include(MyActiveRecordHelper)\n\nActiveRecord::Base.include(MyActiveRecordHelper)\n\nCopy\n","\nActiveSupport.on_load(:active_record) do\n  # self refers to ActiveRecord::Base here,\n  # so we can call .include\n  include MyActiveRecordHelper\nend\n\nActiveSupport.on_load(:active_record) do\n  # self refers to ActiveRecord::Base here,\n  # so we can call .include\n  include MyActiveRecordHelper\nend\n\nCopy\n","\nActionController::Base.prepend(MyActionControllerHelper)\n\nActionController::Base.prepend(MyActionControllerHelper)\n\nCopy\n","\nActiveSupport.on_load(:action_controller_base) do\n  # self refers to ActionController::Base here,\n  # so we can call .prepend\n  prepend MyActionControllerHelper\nend\n\nActiveSupport.on_load(:action_controller_base) do\n  # self refers to ActionController::Base here,\n  # so we can call .prepend\n  prepend MyActionControllerHelper\nend\n\nCopy\n","\nActiveRecord::Base.include_root_in_json = true\n\nActiveRecord::Base.include_root_in_json = true\n\nCopy\n","\nActiveSupport.on_load(:active_record) do\n  # self refers to ActiveRecord::Base here\n  self.include_root_in_json = true\nend\n\nActiveSupport.on_load(:active_record) do\n  # self refers to ActiveRecord::Base here\n  self.include_root_in_json = true\nend\n\nCopy\n"],"body":"Modifying code is generally straightforward. If you have a line of code that refers to a Rails framework such as ActiveRecord::Base you can wrap that code in a load hook.Modifying calls to includebecomesModifying calls to prependbecomesModifying calls to class methodsbecomes"},{"code":[],"body":"These are the load hooks you can use in your own code. To hook into the initialization process of one of the following classes use the available hook.","title":"7.4 Available Load Hooks","anchor":"#available-load-hooks"},{"code":["\nmodule Blorgh\n  class Engine < ::Rails::Engine\n    config.before_configuration do\n      puts 'I am called before any initializers'\n    end\n  end\nend\n\nmodule Blorgh\n  class Engine < ::Rails::Engine\n    config.before_configuration do\n      puts 'I am called before any initializers'\n    end\n  end\nend\n\nCopy\n"],"body":"Configuration hooks do not hook into any particular framework, but instead they run in context of the entire application.Configuration hooks can be called in the Engine class.","title":"7.5 Available Configuration Hooks","anchor":"#available-configuration-hooks"}]