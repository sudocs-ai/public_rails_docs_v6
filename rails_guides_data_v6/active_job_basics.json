[{"code":[],"body":"Active Job is a framework for declaring jobs and making them run on a variety\nof queuing backends. These jobs can be everything from regularly scheduled\nclean-ups, to billing charges, to mailings. Anything that can be chopped up\ninto small units of work and run in parallel, really.","title":"1 What is Active Job?","anchor":"#what-is-active-job-questionmark"},{"title":"2 The Purpose of Active Job","anchor":"#the-purpose-of-active-job","code":[],"body":"The main point is to ensure that all Rails apps will have a job infrastructure\nin place. We can then have framework features and other gems build on top of that,\nwithout having to worry about API differences between various job runners such as\nDelayed Job and Resque. Picking your queuing backend becomes more of an operational\nconcern, then. And you'll be able to switch between them without having to rewrite\nyour jobs."},{"title":"3 Creating a Job","anchor":"#creating-a-job","code":[],"body":"This section will provide a step-by-step guide to creating a job and enqueuing it."},{"title":"3.1 Create the Job","anchor":"#create-the-job","code":["\n$ bin/rails generate job guests_cleanup\ninvoke  test_unit\ncreate    test/jobs/guests_cleanup_job_test.rb\ncreate  app/jobs/guests_cleanup_job.rb\n\nbin/rails generate job guests_cleanup\n\nCopy\n","\n$ bin/rails generate job guests_cleanup --queue urgent\n\nbin/rails generate job guests_cleanup --queue urgent\n\nCopy\n","\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :default\n\n  def perform(*guests)\n    # Do something later\n  end\nend\n\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :default\n\n  def perform(*guests)\n    # Do something later\n  end\nend\n\nCopy\n"],"body":"Active Job provides a Rails generator to create jobs. The following will create a\njob in app/jobs (with an attached test case under test/jobs):You can also create a job that will run on a specific queue:If you don't want to use a generator, you could create your own file inside of\napp/jobs, just make sure that it inherits from ApplicationJob.Here's what a job looks like:Note that you can define perform with as many arguments as you want."},{"title":"3.2 Enqueue the Job","anchor":"#enqueue-the-job","code":["\n# Enqueue a job to be performed as soon as the queuing system is\n# free.\nGuestsCleanupJob.perform_later guest\n\n# Enqueue a job to be performed as soon as the queuing system is\n# free.\nGuestsCleanupJob.perform_later guest\n\nCopy\n","\n# Enqueue a job to be performed tomorrow at noon.\nGuestsCleanupJob.set(wait_until: Date.tomorrow.noon).perform_later(guest)\n\n# Enqueue a job to be performed tomorrow at noon.\nGuestsCleanupJob.set(wait_until: Date.tomorrow.noon).perform_later(guest)\n\nCopy\n","\n# Enqueue a job to be performed 1 week from now.\nGuestsCleanupJob.set(wait: 1.week).perform_later(guest)\n\n# Enqueue a job to be performed 1 week from now.\nGuestsCleanupJob.set(wait: 1.week).perform_later(guest)\n\nCopy\n","\n# `perform_now` and `perform_later` will call `perform` under the hood so\n# you can pass as many arguments as defined in the latter.\nGuestsCleanupJob.perform_later(guest1, guest2, filter: 'some_filter')\n\n# `perform_now` and `perform_later` will call `perform` under the hood so\n# you can pass as many arguments as defined in the latter.\nGuestsCleanupJob.perform_later(guest1, guest2, filter: 'some_filter')\n\nCopy\n"],"body":"Enqueue a job like so:That's it!"},{"title":"4 Job Execution","anchor":"#job-execution","code":[],"body":"For enqueuing and executing jobs in production you need to set up a queuing backend,\nthat is to say you need to decide on a 3rd-party queuing library that Rails should use.\nRails itself only provides an in-process queuing system, which only keeps the jobs in RAM.\nIf the process crashes or the machine is reset, then all outstanding jobs are lost with the\ndefault async backend. This may be fine for smaller apps or non-critical jobs, but most\nproduction apps will need to pick a persistent backend."},{"title":"4.1 Backends","anchor":"#backends","code":[],"body":"Active Job has built-in adapters for multiple queuing backends (Sidekiq,\nResque, Delayed Job, and others). To get an up-to-date list of the adapters\nsee the API Documentation for ActiveJob::QueueAdapters."},{"title":"4.2 Setting the Backend","anchor":"#setting-the-backend","code":["\n# config/application.rb\nmodule YourApp\n  class Application < Rails::Application\n    # Be sure to have the adapter's gem in your Gemfile\n    # and follow the adapter's specific installation\n    # and deployment instructions.\n    config.active_job.queue_adapter = :sidekiq\n  end\nend\n\n# config/application.rb\nmodule YourApp\n  class Application < Rails::Application\n    # Be sure to have the adapter's gem in your Gemfile\n    # and follow the adapter's specific installation\n    # and deployment instructions.\n    config.active_job.queue_adapter = :sidekiq\n  end\nend\n\nCopy\n","\nclass GuestsCleanupJob < ApplicationJob\n  self.queue_adapter = :resque\n  # ...\nend\n\n# Now your job will use `resque` as its backend queue adapter, overriding what\n# was configured in `config.active_job.queue_adapter`.\n\nclass GuestsCleanupJob < ApplicationJob\n  self.queue_adapter = :resque\n  # ...\nend\n\n# Now your job will use `resque` as its backend queue adapter, overriding what\n# was configured in `config.active_job.queue_adapter`.\n\nCopy\n"],"body":"You can easily set your queuing backend:You can also configure your backend on a per job basis:"},{"code":[],"body":"Since jobs run in parallel to your Rails application, most queuing libraries\nrequire that you start a library-specific queuing service (in addition to\nstarting your Rails app) for the job processing to work. Refer to library\ndocumentation for instructions on starting your queue backend.Here is a noncomprehensive list of documentation:","title":"4.3 Starting the Backend","anchor":"#starting-the-backend"},{"code":["\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  # ...\nend\n\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  # ...\nend\n\nCopy\n","\n# config/application.rb\nmodule YourApp\n  class Application < Rails::Application\n    config.active_job.queue_name_prefix = Rails.env\n  end\nend\n\n# config/application.rb\nmodule YourApp\n  class Application < Rails::Application\n    config.active_job.queue_name_prefix = Rails.env\n  end\nend\n\nCopy\n","\n# app/jobs/guests_cleanup_job.rb\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  # ...\nend\n\n# Now your job will run on queue production_low_priority on your\n# production environment and on staging_low_priority\n# on your staging environment\n\n# app/jobs/guests_cleanup_job.rb\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  # ...\nend\n\n# Now your job will run on queue production_low_priority on your\n# production environment and on staging_low_priority\n# on your staging environment\n\nCopy\n","\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  self.queue_name_prefix = nil\n  # ...\nend\n\n# Now your job's queue won't be prefixed, overriding what\n# was configured in `config.active_job.queue_name_prefix`.\n\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  self.queue_name_prefix = nil\n  # ...\nend\n\n# Now your job's queue won't be prefixed, overriding what\n# was configured in `config.active_job.queue_name_prefix`.\n\nCopy\n","\n# config/application.rb\nmodule YourApp\n  class Application < Rails::Application\n    config.active_job.queue_name_prefix = Rails.env\n    config.active_job.queue_name_delimiter = '.'\n  end\nend\n\n# config/application.rb\nmodule YourApp\n  class Application < Rails::Application\n    config.active_job.queue_name_prefix = Rails.env\n    config.active_job.queue_name_delimiter = '.'\n  end\nend\n\nCopy\n","\n# app/jobs/guests_cleanup_job.rb\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  # ...\nend\n\n# Now your job will run on queue production.low_priority on your\n# production environment and on staging.low_priority\n# on your staging environment\n\n# app/jobs/guests_cleanup_job.rb\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :low_priority\n  # ...\nend\n\n# Now your job will run on queue production.low_priority on your\n# production environment and on staging.low_priority\n# on your staging environment\n\nCopy\n","\nMyJob.set(queue: :another_queue).perform_later(record)\n\nMyJob.set(queue: :another_queue).perform_later(record)\n\nCopy\n","\nclass ProcessVideoJob < ApplicationJob\n  queue_as do\n    video = self.arguments.first\n    if video.owner.premium?\n      :premium_videojobs\n    else\n      :videojobs\n    end\n  end\n\n  def perform(video)\n    # Do process video\n  end\nend\n\nclass ProcessVideoJob < ApplicationJob\n  queue_as do\n    video = self.arguments.first\n    if video.owner.premium?\n      :premium_videojobs\n    else\n      :videojobs\n    end\n  end\n\n  def perform(video)\n    # Do process video\n  end\nend\n\nCopy\n","\nProcessVideoJob.perform_later(Video.last)\n\nProcessVideoJob.perform_later(Video.last)\n\nCopy\n"],"body":"Most of the adapters support multiple queues. With Active Job you can schedule\nthe job to run on a specific queue:You can prefix the queue name for all your jobs using\nconfig.active_job.queue_name_prefix in application.rb:You can also configure the prefix on a per job basis.The default queue name prefix delimiter is '_'.  This can be changed by setting\nconfig.active_job.queue_name_delimiter in application.rb:If you want more control on what queue a job will be run you can pass a :queue\noption to set:To control the queue from the job level you can pass a block to queue_as. The\nblock will be executed in the job context (so it can access self.arguments),\nand it must return the queue name:","title":"5 Queues","anchor":"#queues"},{"title":"6 Callbacks","anchor":"#callbacks","code":["\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :default\n\n  around_perform :around_cleanup\n\n  def perform\n    # Do something later\n  end\n\n  private\n    def around_cleanup\n      # Do something before perform\n      yield\n      # Do something after perform\n    end\nend\n\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :default\n\n  around_perform :around_cleanup\n\n  def perform\n    # Do something later\n  end\n\n  private\n    def around_cleanup\n      # Do something before perform\n      yield\n      # Do something after perform\n    end\nend\n\nCopy\n","\nclass ApplicationJob < ActiveJob::Base\n  before_enqueue { |job| $statsd.increment \"#{job.class.name.underscore}.enqueue\" }\nend\n\nclass ApplicationJob < ActiveJob::Base\n  before_enqueue { |job| $statsd.increment \"#{job.class.name.underscore}.enqueue\" }\nend\n\nCopy\n"],"body":"Active Job provides hooks to trigger logic during the life cycle of a job. Like\nother callbacks in Rails, you can implement the callbacks as ordinary methods\nand use a macro-style class method to register them as callbacks:The macro-style class methods can also receive a block. Consider using this\nstyle if the code inside your block is so short that it fits in a single line.\nFor example, you could send metrics for every job enqueued:"},{"code":[],"body":"","title":"6.1 Available callbacks","anchor":"#available-callbacks"},{"code":["\n# If you want to send the email now use #deliver_now\nUserMailer.welcome(@user).deliver_now\n\n# If you want to send the email through Active Job use #deliver_later\nUserMailer.welcome(@user).deliver_later\n\n# If you want to send the email now use #deliver_now\nUserMailer.welcome(@user).deliver_now\n\n# If you want to send the email through Active Job use #deliver_later\nUserMailer.welcome(@user).deliver_later\n\nCopy\n"],"body":"One of the most common jobs in a modern web application is sending emails outside\nof the request-response cycle, so the user doesn't have to wait on it. Active Job\nis integrated with Action Mailer so you can easily send emails asynchronously:","title":"7 Action Mailer","anchor":"#action-mailer"},{"title":"8 Internationalization","anchor":"#internationalization","code":["\nI18n.locale = :eo\n\nUserMailer.welcome(@user).deliver_later # Email will be localized to Esperanto.\n\nI18n.locale = :eo\n\nUserMailer.welcome(@user).deliver_later # Email will be localized to Esperanto.\n\nCopy\n"],"body":"Each job uses the I18n.locale set when the job was created. This is useful if you send\nemails asynchronously:"},{"code":[],"body":"ActiveJob supports the following types of arguments by default:","title":"9 Supported types for arguments","anchor":"#supported-types-for-arguments"},{"code":["\nclass TrashableCleanupJob < ApplicationJob\n  def perform(trashable_class, trashable_id, depth)\n    trashable = trashable_class.constantize.find(trashable_id)\n    trashable.cleanup(depth)\n  end\nend\n\nclass TrashableCleanupJob < ApplicationJob\n  def perform(trashable_class, trashable_id, depth)\n    trashable = trashable_class.constantize.find(trashable_id)\n    trashable.cleanup(depth)\n  end\nend\n\nCopy\n","\nclass TrashableCleanupJob < ApplicationJob\n  def perform(trashable, depth)\n    trashable.cleanup(depth)\n  end\nend\n\nclass TrashableCleanupJob < ApplicationJob\n  def perform(trashable, depth)\n    trashable.cleanup(depth)\n  end\nend\n\nCopy\n"],"body":"Active Job supports GlobalID for parameters. This makes it possible to pass live\nActive Record objects to your job instead of class/id pairs, which you then have\nto manually deserialize. Before, jobs would look like this:Now you can simply do:This works with any class that mixes in GlobalID::Identification, which\nby default has been mixed into Active Record classes.","title":"9.1 GlobalID","anchor":"#globalid"},{"title":"9.2 Serializers","anchor":"#serializers","code":["\nclass MoneySerializer < ActiveJob::Serializers::ObjectSerializer\n  # Checks if an argument should be serialized by this serializer.\n  def serialize?(argument)\n    argument.is_a? Money\n  end\n\n  # Converts an object to a simpler representative using supported object types.\n  # The recommended representative is a Hash with a specific key. Keys can be of basic types only.\n  # You should call `super` to add the custom serializer type to the hash.\n  def serialize(money)\n    super(\n      \"amount\" => money.amount,\n      \"currency\" => money.currency\n    )\n  end\n\n  # Converts serialized value into a proper object.\n  def deserialize(hash)\n    Money.new(hash[\"amount\"], hash[\"currency\"])\n  end\nend\n\nclass MoneySerializer < ActiveJob::Serializers::ObjectSerializer\n  # Checks if an argument should be serialized by this serializer.\n  def serialize?(argument)\n    argument.is_a? Money\n  end\n\n  # Converts an object to a simpler representative using supported object types.\n  # The recommended representative is a Hash with a specific key. Keys can be of basic types only.\n  # You should call `super` to add the custom serializer type to the hash.\n  def serialize(money)\n    super(\n      \"amount\" => money.amount,\n      \"currency\" => money.currency\n    )\n  end\n\n  # Converts serialized value into a proper object.\n  def deserialize(hash)\n    Money.new(hash[\"amount\"], hash[\"currency\"])\n  end\nend\n\nCopy\n","\nRails.application.config.active_job.custom_serializers << MoneySerializer\n\nRails.application.config.active_job.custom_serializers << MoneySerializer\n\nCopy\n"],"body":"You can extend the list of supported argument types. You just need to define your own serializer:and add this serializer to the list:"},{"code":["\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :default\n\n  rescue_from(ActiveRecord::RecordNotFound) do |exception|\n    # Do something with the exception\n  end\n\n  def perform\n    # Do something later\n  end\nend\n\nclass GuestsCleanupJob < ApplicationJob\n  queue_as :default\n\n  rescue_from(ActiveRecord::RecordNotFound) do |exception|\n    # Do something with the exception\n  end\n\n  def perform\n    # Do something later\n  end\nend\n\nCopy\n"],"body":"Active Job provides a way to catch exceptions raised during the execution of the\njob:If an exception from a job is not rescued, then the job is referred to as \"failed\".","title":"10 Exceptions","anchor":"#exceptions"},{"title":"10.1 Retrying or Discarding failed jobs","anchor":"#retrying-or-discarding-failed-jobs","code":["\nclass RemoteServiceJob < ApplicationJob\n  retry_on CustomAppException # defaults to 3s wait, 5 attempts\n\n  discard_on ActiveJob::DeserializationError\n\n  def perform(*args)\n    # Might raise CustomAppException or ActiveJob::DeserializationError\n  end\nend\n\nclass RemoteServiceJob < ApplicationJob\n  retry_on CustomAppException # defaults to 3s wait, 5 attempts\n\n  discard_on ActiveJob::DeserializationError\n\n  def perform(*args)\n    # Might raise CustomAppException or ActiveJob::DeserializationError\n  end\nend\n\nCopy\n"],"body":"A failed job will not be retried, unless configured otherwise.It's also possible to retry or discard a job if an exception is raised during execution.\nFor example:To get more details see the API Documentation for ActiveJob::Exceptions."},{"title":"10.2 Deserialization","anchor":"#deserialization","code":[],"body":"GlobalID allows serializing full Active Record objects passed to #perform.If a passed record is deleted after the job is enqueued but before the #perform\nmethod is called Active Job will raise an ActiveJob::DeserializationError\nexception."},{"title":"11 Job Testing","anchor":"#job-testing","code":[],"body":"You can find detailed instructions on how to test your jobs in the\ntesting guide."}]