[{"code":["\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :products do |t|\n      t.string :name\n      t.text :description\n\n      t.timestamps\n    end\n  end\nend\n\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :products do |t|\n      t.string :name\n      t.text :description\n\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\nclass ChangeProductsPrice < ActiveRecord::Migration[6.0]\n  def change\n    reversible do |dir|\n      change_table :products do |t|\n        dir.up   { t.change :price, :string }\n        dir.down { t.change :price, :integer }\n      end\n    end\n  end\nend\n\nclass ChangeProductsPrice < ActiveRecord::Migration[6.0]\n  def change\n    reversible do |dir|\n      change_table :products do |t|\n        dir.up   { t.change :price, :string }\n        dir.down { t.change :price, :integer }\n      end\n    end\n  end\nend\n\nCopy\n","\nclass ChangeProductsPrice < ActiveRecord::Migration[6.0]\n  def up\n    change_table :products do |t|\n      t.change :price, :string\n    end\n  end\n\n  def down\n    change_table :products do |t|\n      t.change :price, :integer\n    end\n  end\nend\n\nclass ChangeProductsPrice < ActiveRecord::Migration[6.0]\n  def up\n    change_table :products do |t|\n      t.change :price, :string\n    end\n  end\n\n  def down\n    change_table :products do |t|\n      t.change :price, :integer\n    end\n  end\nend\n\nCopy\n"],"body":"Migrations are a convenient way to\nalter your database schema over time\nin a consistent way. They use a Ruby DSL so that you don't have to\nwrite SQL by hand, allowing your schema and changes to be database independent.You can think of each migration as being a new 'version' of the database. A\nschema starts off with nothing in it, and each migration modifies it to add or\nremove tables, columns, or entries. Active Record knows how to update your\nschema along this timeline, bringing it from whatever point it is in the\nhistory to the latest version. Active Record will also update your\ndb/schema.rb file to match the up-to-date structure of your database.Here's an example of a migration:This migration adds a table called products with a string column called\nname and a text column called description. A primary key column called id\nwill also be added implicitly, as it's the default primary key for all Active\nRecord models. The timestamps macro adds two columns, created_at and\nupdated_at. These special columns are automatically managed by Active Record\nif they exist.Note that we define the change that we want to happen moving forward in time.\nBefore this migration is run, there will be no table. After, the table will\nexist. Active Record knows how to reverse this migration as well: if we roll\nthis migration back, it will remove the table.On databases that support transactions with statements that change the schema,\nmigrations are wrapped in a transaction. If the database does not support this\nthen when a migration fails the parts of it that succeeded will not be rolled\nback. You will have to rollback the changes that were made by hand.If you wish for a migration to do something that Active Record doesn't know how\nto reverse, you can use reversible:Alternatively, you can use up and down instead of change:","title":"1 Migration Overview","anchor":"#migration-overview"},{"code":[],"body":"","title":"2 Creating a Migration","anchor":"#creating-a-migration"},{"title":"2.1 Creating a Standalone Migration","anchor":"#creating-a-standalone-migration","code":["\n$ bin/rails generate migration AddPartNumberToProducts\n\nbin/rails generate migration AddPartNumberToProducts\n\nCopy\n","\nclass AddPartNumberToProducts < ActiveRecord::Migration[6.0]\n  def change\n  end\nend\n\nclass AddPartNumberToProducts < ActiveRecord::Migration[6.0]\n  def change\n  end\nend\n\nCopy\n","\n$ bin/rails generate migration AddPartNumberToProducts part_number:string\n\nbin/rails generate migration AddPartNumberToProducts part_number:string\n\nCopy\n","\nclass AddPartNumberToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :part_number, :string\n  end\nend\n\nclass AddPartNumberToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :part_number, :string\n  end\nend\n\nCopy\n","\n$ bin/rails generate migration AddPartNumberToProducts part_number:string:index\n\nbin/rails generate migration AddPartNumberToProducts part_number:string:index\n\nCopy\n","\nclass AddPartNumberToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :part_number, :string\n    add_index :products, :part_number\n  end\nend\n\nclass AddPartNumberToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :part_number, :string\n    add_index :products, :part_number\n  end\nend\n\nCopy\n","\n$ bin/rails generate migration RemovePartNumberFromProducts part_number:string\n\nbin/rails generate migration RemovePartNumberFromProducts part_number:string\n\nCopy\n","\nclass RemovePartNumberFromProducts < ActiveRecord::Migration[6.0]\n  def change\n    remove_column :products, :part_number, :string\n  end\nend\n\nclass RemovePartNumberFromProducts < ActiveRecord::Migration[6.0]\n  def change\n    remove_column :products, :part_number, :string\n  end\nend\n\nCopy\n","\n$ bin/rails generate migration AddDetailsToProducts part_number:string price:decimal\n\nbin/rails generate migration AddDetailsToProducts part_number:string price:decimal\n\nCopy\n","\nclass AddDetailsToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :part_number, :string\n    add_column :products, :price, :decimal\n  end\nend\n\nclass AddDetailsToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :part_number, :string\n    add_column :products, :price, :decimal\n  end\nend\n\nCopy\n","\n$ bin/rails generate migration CreateProducts name:string part_number:string\n\nbin/rails generate migration CreateProducts name:string part_number:string\n\nCopy\n","\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :products do |t|\n      t.string :name\n      t.string :part_number\n\n      t.timestamps\n    end\n  end\nend\n\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :products do |t|\n      t.string :name\n      t.string :part_number\n\n      t.timestamps\n    end\n  end\nend\n\nCopy\n","\n$ bin/rails generate migration AddUserRefToProducts user:references\n\nbin/rails generate migration AddUserRefToProducts user:references\n\nCopy\n","\nclass AddUserRefToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_reference :products, :user, foreign_key: true\n  end\nend\n\nclass AddUserRefToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_reference :products, :user, foreign_key: true\n  end\nend\n\nCopy\n","\n$ bin/rails generate migration CreateJoinTableCustomerProduct customer product\n\nbin/rails generate migration CreateJoinTableCustomerProduct customer product\n\nCopy\n","\nclass CreateJoinTableCustomerProduct < ActiveRecord::Migration[6.0]\n  def change\n    create_join_table :customers, :products do |t|\n      # t.index [:customer_id, :product_id]\n      # t.index [:product_id, :customer_id]\n    end\n  end\nend\n\nclass CreateJoinTableCustomerProduct < ActiveRecord::Migration[6.0]\n  def change\n    create_join_table :customers, :products do |t|\n      # t.index [:customer_id, :product_id]\n      # t.index [:product_id, :customer_id]\n    end\n  end\nend\n\nCopy\n"],"body":"Migrations are stored as files in the db/migrate directory, one for each\nmigration class. The name of the file is of the form\nYYYYMMDDHHMMSS_create_products.rb, that is to say a UTC timestamp\nidentifying the migration followed by an underscore followed by the name\nof the migration. The name of the migration class (CamelCased version)\nshould match the latter part of the file name. For example\n20080906120000_create_products.rb should define class CreateProducts and\n20080906120001_add_details_to_products.rb should define\nAddDetailsToProducts. Rails uses this timestamp to determine which migration\nshould be run and in what order, so if you're copying a migration from another\napplication or generate a file yourself, be aware of its position in the order.Of course, calculating timestamps is no fun, so Active Record provides a\ngenerator to handle making it for you:This will create an appropriately named empty migration:This generator can do much more than append a timestamp to the file name.\nBased on naming conventions and additional (optional) arguments it can\nalso start fleshing out the migration.If the migration name is of the form \"AddColumnToTable\" or\n\"RemoveColumnFromTable\" and is followed by a list of column names and\ntypes then a migration containing the appropriate add_column and\nremove_column statements will be created.will generateIf you'd like to add an index on the new column, you can do that as well.will generate the appropriate add_column and add_index statements:Similarly, you can generate a migration to remove a column from the command line:generatesYou are not limited to one magically generated column. For example:generatesIf the migration name is of the form \"CreateXXX\" and is\nfollowed by a list of column names and types then a migration creating the table\nXXX with the columns listed will be generated. For example:generatesAs always, what has been generated for you is just a starting point. You can add\nor remove from it as you see fit by editing the\ndb/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb file.Also, the generator accepts column type as references (also available as\nbelongs_to). For example,generates the following add_reference call:This migration will create a user_id column and appropriate index.There is also a generator which will produce join tables if JoinTable is part of the name:will produce the following migration:"},{"code":["\n$ bin/rails generate model Product name:string description:text\n\nbin/rails generate model Product name:string description:text\n\nCopy\n","\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :products do |t|\n      t.string :name\n      t.text :description\n\n      t.timestamps\n    end\n  end\nend\n\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    create_table :products do |t|\n      t.string :name\n      t.text :description\n\n      t.timestamps\n    end\n  end\nend\n\nCopy\n"],"body":"The model and scaffold generators will create migrations appropriate for adding\na new model. This migration will already contain instructions for creating the\nrelevant table. If you tell Rails what columns you want, then statements for\nadding these columns will also be created. For example, running:will create a migration that looks like thisYou can append as many column name/type pairs as you want.","title":"2.2 Model Generators","anchor":"#model-generators"},{"title":"2.3 Passing Modifiers","anchor":"#passing-modifiers","code":["\n$ bin/rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}\n\nbin/rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}\n\nCopy\n","\nclass AddDetailsToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :price, :decimal, precision: 5, scale: 2\n    add_reference :products, :supplier, polymorphic: true\n  end\nend\n\nclass AddDetailsToProducts < ActiveRecord::Migration[6.0]\n  def change\n    add_column :products, :price, :decimal, precision: 5, scale: 2\n    add_reference :products, :supplier, polymorphic: true\n  end\nend\n\nCopy\n"],"body":"Some commonly used type modifiers can be passed directly on\nthe command line. They are enclosed by curly braces and follow the field type:For instance, running:will produce a migration that looks like this"},{"title":"3 Writing a Migration","anchor":"#writing-a-migration","code":[],"body":"Once you have created your migration using one of the generators it's time to\nget to work!"},{"title":"3.1 Creating a Table","anchor":"#creating-a-table","code":["\ncreate_table :products do |t|\n  t.string :name\nend\n\ncreate_table :products do |t|\n  t.string :name\nend\n\nCopy\n","\ncreate_table :products, options: \"ENGINE=BLACKHOLE\" do |t|\n  t.string :name, null: false\nend\n\ncreate_table :products, options: \"ENGINE=BLACKHOLE\" do |t|\n  t.string :name, null: false\nend\n\nCopy\n"],"body":"The create_table method is one of the most fundamental, but most of the time,\nwill be generated for you from using a model or scaffold generator. A typical\nuse would bewhich creates a products table with a column called name (and as discussed\nbelow, an implicit id column).By default, create_table will create a primary key called id. You can change\nthe name of the primary key with the :primary_key option (don't forget to\nupdate the corresponding model) or, if you don't want a primary key at all, you\ncan pass the option id: false. If you need to pass database specific options\nyou can place an SQL fragment in the :options option. For example:will append ENGINE=BLACKHOLE to the SQL statement used to create the table.Also you can pass the :comment option with any description for the table\nthat will be stored in database itself and can be viewed with database administration\ntools, such as MySQL Workbench or PgAdmin III. It's highly recommended to specify\ncomments in migrations for applications with large databases as it helps people\nto understand data model and generate documentation.\nCurrently only the MySQL and PostgreSQL adapters support comments."},{"title":"3.2 Creating a Join Table","anchor":"#creating-a-join-table","code":["\ncreate_join_table :products, :categories\n\ncreate_join_table :products, :categories\n\nCopy\n","\ncreate_join_table :products, :categories, column_options: { null: true }\n\ncreate_join_table :products, :categories, column_options: { null: true }\n\nCopy\n","\ncreate_join_table :products, :categories, table_name: :categorization\n\ncreate_join_table :products, :categories, table_name: :categorization\n\nCopy\n","\ncreate_join_table :products, :categories do |t|\n  t.index :product_id\n  t.index :category_id\nend\n\ncreate_join_table :products, :categories do |t|\n  t.index :product_id\n  t.index :category_id\nend\n\nCopy\n"],"body":"The migration method create_join_table creates an HABTM (has and belongs to\nmany) join table. A typical use would be:which creates a categories_products table with two columns called\ncategory_id and product_id. These columns have the option :null set to\nfalse by default. This can be overridden by specifying the :column_options\noption:By default, the name of the join table comes from the union of the first two\narguments provided to create_join_table, in alphabetical order.\nTo customize the name of the table, provide a :table_name option:creates a categorization table.create_join_table also accepts a block, which you can use to add indices\n(which are not created by default) or additional columns:"},{"code":["\nchange_table :products do |t|\n  t.remove :description, :name\n  t.string :part_number\n  t.index :part_number\n  t.rename :upccode, :upc_code\nend\n\nchange_table :products do |t|\n  t.remove :description, :name\n  t.string :part_number\n  t.index :part_number\n  t.rename :upccode, :upc_code\nend\n\nCopy\n"],"body":"A close cousin of create_table is change_table, used for changing existing\ntables. It is used in a similar fashion to create_table but the object\nyielded to the block knows more tricks. For example:removes the description and name columns, creates a part_number string\ncolumn and adds an index on it. Finally it renames the upccode column.","title":"3.3 Changing Tables","anchor":"#changing-tables"},{"title":"3.4 Changing Columns","anchor":"#changing-columns","code":["\nchange_column :products, :part_number, :text\n\nchange_column :products, :part_number, :text\n\nCopy\n","\nchange_column_null :products, :name, false\nchange_column_default :products, :approved, from: true, to: false\n\nchange_column_null :products, :name, false\nchange_column_default :products, :approved, from: true, to: false\n\nCopy\n"],"body":"Like the remove_column and add_column Rails provides the change_column\nmigration method.This changes the column part_number on products table to be a :text field.\nNote that change_column command is irreversible.Besides change_column, the change_column_null and change_column_default\nmethods are used specifically to change a not null constraint and default\nvalues of a column.This sets :name field on products to a NOT NULL column and the default\nvalue of the :approved field from true to false."},{"title":"3.5 Column Modifiers","anchor":"#column-modifiers","code":[],"body":"Column modifiers can be applied when creating or changing a column:Some adapters may support additional options; see the adapter specific API docs\nfor further information."},{"title":"3.6 Foreign Keys","anchor":"#foreign-keys","code":["\nadd_foreign_key :articles, :authors\n\nadd_foreign_key :articles, :authors\n\nCopy\n","\n# let Active Record figure out the column name\nremove_foreign_key :accounts, :branches\n\n# remove foreign key for a specific column\nremove_foreign_key :accounts, column: :owner_id\n\n# remove foreign key by name\nremove_foreign_key :accounts, name: :special_fk_name\n\n# let Active Record figure out the column name\nremove_foreign_key :accounts, :branches\n\n# remove foreign key for a specific column\nremove_foreign_key :accounts, column: :owner_id\n\n# remove foreign key by name\nremove_foreign_key :accounts, name: :special_fk_name\n\nCopy\n"],"body":"While it's not required you might want to add foreign key constraints to\nguarantee referential integrity.This adds a new foreign key to the author_id column of the articles\ntable. The key references the id column of the authors table. If the\ncolumn names cannot be derived from the table names, you can use the\n:column and :primary_key options.Rails will generate a name for every foreign key starting with\nfk_rails_ followed by 10 characters which are deterministically\ngenerated from the from_table and column.\nThere is a :name option to specify a different name if needed.Foreign keys can also be removed:"},{"code":["\nProduct.connection.execute(\"UPDATE products SET price = 'free' WHERE 1=1\")\n\nProduct.connection.execute(\"UPDATE products SET price = 'free' WHERE 1=1\")\n\nCopy\n"],"body":"If the helpers provided by Active Record aren't enough you can use the execute\nmethod to execute arbitrary SQL:For more details and examples of individual methods, check the API documentation.\nIn particular the documentation for\nActiveRecord::ConnectionAdapters::SchemaStatements\n(which provides the methods available in the change, up and down methods),\nActiveRecord::ConnectionAdapters::TableDefinition\n(which provides the methods available on the object yielded by create_table)\nand\nActiveRecord::ConnectionAdapters::Table\n(which provides the methods available on the object yielded by change_table).","title":"3.7 When Helpers aren't Enough","anchor":"#when-helpers-aren-t-enough"},{"title":"3.8 Using the change Method","anchor":"#using-the-change-method","code":["\nremove_column :posts, :slug, :string, null: false, default: ''\n\nremove_column :posts, :slug, :string, null: false, default: ''\n\nCopy\n"],"body":"The change method is the primary way of writing migrations. It works for the\nmajority of cases, where Active Record knows how to reverse the migration\nautomatically. Currently, the change method supports only these migration\ndefinitions:change_table is also reversible, as long as the block does not call change,\nchange_default or remove.remove_column is reversible if you supply the column type as the third\nargument. Provide the original column options too, otherwise Rails can't\nrecreate the column exactly when rolling back:If you're going to need to use any other methods, you should use reversible\nor write the up and down methods instead of using the change method."},{"title":"3.9 Using reversible","anchor":"#using-reversible","code":["\nclass ExampleMigration < ActiveRecord::Migration[6.0]\n  def change\n    create_table :distributors do |t|\n      t.string :zipcode\n    end\n\n    reversible do |dir|\n      dir.up do\n        # add a CHECK constraint\n        execute <<-SQL\n          ALTER TABLE distributors\n            ADD CONSTRAINT zipchk\n              CHECK (char_length(zipcode) = 5) NO INHERIT;\n        SQL\n      end\n      dir.down do\n        execute <<-SQL\n          ALTER TABLE distributors\n            DROP CONSTRAINT zipchk\n        SQL\n      end\n    end\n\n    add_column :users, :home_page_url, :string\n    rename_column :users, :email, :email_address\n  end\nend\n\nclass ExampleMigration < ActiveRecord::Migration[6.0]\n  def change\n    create_table :distributors do |t|\n      t.string :zipcode\n    end\n\n    reversible do |dir|\n      dir.up do\n        # add a CHECK constraint\n        execute <<-SQL\n          ALTER TABLE distributors\n            ADD CONSTRAINT zipchk\n              CHECK (char_length(zipcode) = 5) NO INHERIT;\n        SQL\n      end\n      dir.down do\n        execute <<-SQL\n          ALTER TABLE distributors\n            DROP CONSTRAINT zipchk\n        SQL\n      end\n    end\n\n    add_column :users, :home_page_url, :string\n    rename_column :users, :email, :email_address\n  end\nend\n\nCopy\n"],"body":"Complex migrations may require processing that Active Record doesn't know how\nto reverse. You can use reversible to specify what to do when running a\nmigration and what else to do when reverting it. For example:Using reversible will ensure that the instructions are executed in the\nright order too. If the previous example migration is reverted,\nthe down block will be run after the home_page_url column is removed and\nright before the table distributors is dropped.Sometimes your migration will do something which is just plain irreversible; for\nexample, it might destroy some data. In such cases, you can raise\nActiveRecord::IrreversibleMigration in your down block. If someone tries\nto revert your migration, an error message will be displayed saying that it\ncan't be done."},{"title":"3.10 Using the up/down Methods","anchor":"#using-the-up-down-methods","code":["\nclass ExampleMigration < ActiveRecord::Migration[6.0]\n  def up\n    create_table :distributors do |t|\n      t.string :zipcode\n    end\n\n    # add a CHECK constraint\n    execute <<-SQL\n      ALTER TABLE distributors\n        ADD CONSTRAINT zipchk\n        CHECK (char_length(zipcode) = 5);\n    SQL\n\n    add_column :users, :home_page_url, :string\n    rename_column :users, :email, :email_address\n  end\n\n  def down\n    rename_column :users, :email_address, :email\n    remove_column :users, :home_page_url\n\n    execute <<-SQL\n      ALTER TABLE distributors\n        DROP CONSTRAINT zipchk\n    SQL\n\n    drop_table :distributors\n  end\nend\n\nclass ExampleMigration < ActiveRecord::Migration[6.0]\n  def up\n    create_table :distributors do |t|\n      t.string :zipcode\n    end\n\n    # add a CHECK constraint\n    execute <<-SQL\n      ALTER TABLE distributors\n        ADD CONSTRAINT zipchk\n        CHECK (char_length(zipcode) = 5);\n    SQL\n\n    add_column :users, :home_page_url, :string\n    rename_column :users, :email, :email_address\n  end\n\n  def down\n    rename_column :users, :email_address, :email\n    remove_column :users, :home_page_url\n\n    execute <<-SQL\n      ALTER TABLE distributors\n        DROP CONSTRAINT zipchk\n    SQL\n\n    drop_table :distributors\n  end\nend\n\nCopy\n"],"body":"You can also use the old style of migration using up and down methods\ninstead of the change method.\nThe up method should describe the transformation you'd like to make to your\nschema, and the down method of your migration should revert the\ntransformations done by the up method. In other words, the database schema\nshould be unchanged if you do an up followed by a down. For example, if you\ncreate a table in the up method, you should drop it in the down method. It\nis wise to perform the transformations in precisely the reverse order they were\nmade in the up method. The example in the reversible section is equivalent to:If your migration is irreversible, you should raise\nActiveRecord::IrreversibleMigration from your down method. If someone tries\nto revert your migration, an error message will be displayed saying that it\ncan't be done."},{"title":"3.11 Reverting Previous Migrations","anchor":"#reverting-previous-migrations","code":["\nrequire_relative \"20121212123456_example_migration\"\n\nclass FixupExampleMigration < ActiveRecord::Migration[6.0]\n  def change\n    revert ExampleMigration\n\n    create_table(:apples) do |t|\n      t.string :variety\n    end\n  end\nend\n\nrequire_relative \"20121212123456_example_migration\"\n\nclass FixupExampleMigration < ActiveRecord::Migration[6.0]\n  def change\n    revert ExampleMigration\n\n    create_table(:apples) do |t|\n      t.string :variety\n    end\n  end\nend\n\nCopy\n","\nclass DontUseConstraintForZipcodeValidationMigration < ActiveRecord::Migration[6.0]\n  def change\n    revert do\n      # copy-pasted code from ExampleMigration\n      reversible do |dir|\n        dir.up do\n          # add a CHECK constraint\n          execute <<-SQL\n            ALTER TABLE distributors\n              ADD CONSTRAINT zipchk\n                CHECK (char_length(zipcode) = 5);\n          SQL\n        end\n        dir.down do\n          execute <<-SQL\n            ALTER TABLE distributors\n              DROP CONSTRAINT zipchk\n          SQL\n        end\n      end\n\n      # The rest of the migration was ok\n    end\n  end\nend\n\nclass DontUseConstraintForZipcodeValidationMigration < ActiveRecord::Migration[6.0]\n  def change\n    revert do\n      # copy-pasted code from ExampleMigration\n      reversible do |dir|\n        dir.up do\n          # add a CHECK constraint\n          execute <<-SQL\n            ALTER TABLE distributors\n              ADD CONSTRAINT zipchk\n                CHECK (char_length(zipcode) = 5);\n          SQL\n        end\n        dir.down do\n          execute <<-SQL\n            ALTER TABLE distributors\n              DROP CONSTRAINT zipchk\n          SQL\n        end\n      end\n\n      # The rest of the migration was ok\n    end\n  end\nend\n\nCopy\n"],"body":"You can use Active Record's ability to rollback migrations using the revert method:The revert method also accepts a block of instructions to reverse.\nThis could be useful to revert selected parts of previous migrations.\nFor example, let's imagine that ExampleMigration is committed and it\nis later decided it would be best to use Active Record validations,\nin place of the CHECK constraint, to verify the zipcode.The same migration could also have been written without using revert\nbut this would have involved a few more steps: reversing the order\nof create_table and reversible, replacing create_table\nby drop_table, and finally replacing up by down and vice-versa.\nThis is all taken care of by revert."},{"title":"4 Running Migrations","anchor":"#running-migrations","code":["\n$ bin/rails db:migrate VERSION=20080906120000\n\nbin/rails db:migrate VERSION=20080906120000\n\nCopy\n"],"body":"Rails provides a set of rails commands to run certain sets of migrations.The very first migration related rails command you will use will probably be\nbin/rails db:migrate. In its most basic form it just runs the change or up\nmethod for all the migrations that have not yet been run. If there are\nno such migrations, it exits. It will run these migrations in order based\non the date of the migration.Note that running the db:migrate command also invokes the db:schema:dump command, which\nwill update your db/schema.rb file to match the structure of your database.If you specify a target version, Active Record will run the required migrations\n(change, up, down) until it has reached the specified version. The version\nis the numerical prefix on the migration's filename. For example, to migrate\nto version 20080906120000 run:If version 20080906120000 is greater than the current version (i.e., it is\nmigrating upwards), this will run the change (or up) method\non all migrations up to and\nincluding 20080906120000, and will not execute any later migrations. If\nmigrating downwards, this will run the down method on all the migrations\ndown to, but not including, 20080906120000."},{"title":"4.1 Rolling Back","anchor":"#rolling-back","code":["\n$ bin/rails db:rollback\n\nbin/rails db:rollback\n\nCopy\n","\n$ bin/rails db:rollback STEP=3\n\nbin/rails db:rollback STEP=3\n\nCopy\n","\n$ bin/rails db:migrate:redo STEP=3\n\nbin/rails db:migrate:redo STEP=3\n\nCopy\n"],"body":"A common task is to rollback the last migration. For example, if you made a\nmistake in it and wish to correct it. Rather than tracking down the version\nnumber associated with the previous migration you can run:This will rollback the latest migration, either by reverting the change\nmethod or by running the down method. If you need to undo\nseveral migrations you can provide a STEP parameter:will revert the last 3 migrations.The db:migrate:redo command is a shortcut for doing a rollback and then migrating\nback up again. As with the db:rollback command, you can use the STEP parameter\nif you need to go more than one version back, for example:Neither of these rails commands do anything you could not do with db:migrate. They\nare there for convenience, since you do not need to explicitly specify the\nversion to migrate to."},{"title":"4.2 Setup the Database","anchor":"#setup-the-database","code":[],"body":"The bin/rails db:setup command will create the database, load the schema, and initialize\nit with the seed data."},{"title":"4.3 Resetting the Database","anchor":"#resetting-the-database","code":[],"body":"The bin/rails db:reset command will drop the database and set it up again. This is\nfunctionally equivalent to bin/rails db:drop db:setup."},{"title":"4.4 Running Specific Migrations","anchor":"#running-specific-migrations","code":["\n$ bin/rails db:migrate:up VERSION=20080906120000\n\nbin/rails db:migrate:up VERSION=20080906120000\n\nCopy\n"],"body":"If you need to run a specific migration up or down, the db:migrate:up and\ndb:migrate:down commands will do that. Just specify the appropriate version and\nthe corresponding migration will have its change, up or down method\ninvoked, for example:will run the 20080906120000 migration by running the change method (or the\nup method). This command will\nfirst check whether the migration is already performed and will do nothing if\nActive Record believes that it has already been run."},{"title":"4.5 Running Migrations in Different Environments","anchor":"#running-migrations-in-different-environments","code":["\n$ bin/rails db:migrate RAILS_ENV=test\n\nbin/rails db:migrate RAILS_ENV=test\n\nCopy\n"],"body":"By default running bin/rails db:migrate will run in the development environment.\nTo run migrations against another environment you can specify it using the\nRAILS_ENV environment variable while running the command. For example to run\nmigrations against the test environment you could run:"},{"code":["\n==  CreateProducts: migrating =================================================\n-- create_table(:products)\n   -> 0.0028s\n==  CreateProducts: migrated (0.0028s) ========================================\n\n==  CreateProducts: migrating =================================================\n-- create_table(:products)\n   -> 0.0028s\n==  CreateProducts: migrated (0.0028s) ========================================\n\nCopy\n","\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    suppress_messages do\n      create_table :products do |t|\n        t.string :name\n        t.text :description\n        t.timestamps\n      end\n    end\n\n    say \"Created a table\"\n\n    suppress_messages {add_index :products, :name}\n    say \"and an index!\", true\n\n    say_with_time 'Waiting for a while' do\n      sleep 10\n      250\n    end\n  end\nend\n\nclass CreateProducts < ActiveRecord::Migration[6.0]\n  def change\n    suppress_messages do\n      create_table :products do |t|\n        t.string :name\n        t.text :description\n        t.timestamps\n      end\n    end\n\n    say \"Created a table\"\n\n    suppress_messages {add_index :products, :name}\n    say \"and an index!\", true\n\n    say_with_time 'Waiting for a while' do\n      sleep 10\n      250\n    end\n  end\nend\n\nCopy\n","\n==  CreateProducts: migrating =================================================\n-- Created a table\n   -> and an index!\n-- Waiting for a while\n   -> 10.0013s\n   -> 250 rows\n==  CreateProducts: migrated (10.0054s) =======================================\n\n==  CreateProducts: migrating =================================================\n-- Created a table\n   -> and an index!\n-- Waiting for a while\n   -> 10.0013s\n   -> 250 rows\n==  CreateProducts: migrated (10.0054s) =======================================\n\nCopy\n"],"body":"By default migrations tell you exactly what they're doing and how long it took.\nA migration creating a table and adding an index might produce output like thisSeveral methods are provided in migrations that allow you to control all this:For example, this migration:generates the following outputIf you want Active Record to not output anything, then running bin/rails db:migrate\nVERBOSE=false will suppress all output.","title":"4.6 Changing the Output of Running Migrations","anchor":"#changing-the-output-of-running-migrations"},{"title":"5 Changing Existing Migrations","anchor":"#changing-existing-migrations","code":[],"body":"Occasionally you will make a mistake when writing a migration. If you have\nalready run the migration, then you cannot just edit the migration and run the\nmigration again: Rails thinks it has already run the migration and so will do\nnothing when you run bin/rails db:migrate. You must rollback the migration (for\nexample with bin/rails db:rollback), edit your migration, and then run\nbin/rails db:migrate to run the corrected version.In general, editing existing migrations is not a good idea. You will be\ncreating extra work for yourself and your co-workers and cause major headaches\nif the existing version of the migration has already been run on production\nmachines. Instead, you should write a new migration that performs the changes\nyou require. Editing a freshly generated migration that has not yet been\ncommitted to source control (or, more generally, which has not been propagated\nbeyond your development machine) is relatively harmless.The revert method can be helpful when writing a new migration to undo\nprevious migrations in whole or in part\n(see Reverting Previous Migrations above)."},{"title":"6 Schema Dumping and You","anchor":"#schema-dumping-and-you","code":[],"body":""},{"title":"6.1 What are Schema Files for?","anchor":"#what-are-schema-files-for-questionmark","code":[],"body":"Migrations, mighty as they may be, are not the authoritative source for your\ndatabase schema. Your database remains the authoritative source. By default,\nRails generates db/schema.rb which attempts to capture the current state of\nyour database schema.It tends to be faster and less error prone to create a new instance of your\napplication's database by loading the schema file via bin/rails db:schema:load\nthan it is to replay the entire migration history.\nOld migrations may fail to apply correctly if those\nmigrations use changing external dependencies or rely on application code which\nevolves separately from your migrations.Schema files are also useful if you want a quick look at what attributes an\nActive Record object has. This information is not in the model's code and is\nfrequently spread across several migrations, but the information is nicely\nsummed up in the schema file."},{"title":"6.2 Types of Schema Dumps","anchor":"#types-of-schema-dumps","code":["\nActiveRecord::Schema.define(version: 2008_09_06_171750) do\n  create_table \"authors\", force: true do |t|\n    t.string   \"name\"\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n  end\n\n  create_table \"products\", force: true do |t|\n    t.string   \"name\"\n    t.text     \"description\"\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n    t.string   \"part_number\"\n  end\nend\n\nActiveRecord::Schema.define(version: 2008_09_06_171750) do\n  create_table \"authors\", force: true do |t|\n    t.string   \"name\"\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n  end\n\n  create_table \"products\", force: true do |t|\n    t.string   \"name\"\n    t.text     \"description\"\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n    t.string   \"part_number\"\n  end\nend\n\nCopy\n"],"body":"The format of the schema dump generated by Rails is controlled by the\nconfig.active_record.schema_format setting in config/application.rb. By\ndefault, the format is :ruby, but can also be set to :sql.If :ruby is selected, then the schema is stored in db/schema.rb. If you look\nat this file you'll find that it looks an awful lot like one very big migration:In many ways this is exactly what it is. This file is created by inspecting the\ndatabase and expressing its structure using create_table, add_index, and so\non.db/schema.rb cannot express everything your database may support such as\ntriggers, sequences, stored procedures, etc. While migrations\nmay use execute to create database constructs that are not supported by the\nRuby migration DSL, these constructs may not be able to be reconstituted by the\nschema dumper. If you are using features like these, you should set the schema\nformat to :sql in order to get an accurate schema file that is useful to\ncreate new database instances.When the schema format is set to :sql, the database structure will be dumped\nusing a tool specific to the database into db/structure.sql. For example, for\nPostgreSQL, the pg_dump utility is used. For MySQL and MariaDB, this file will\ncontain the output of SHOW CREATE TABLE for the various tables.To load the schema from db/structure.sql, run bin/rails db:schema:load.\nLoading this file is done by executing the SQL statements it contains. By\ndefinition, this will create a perfect copy of the database's structure."},{"title":"6.3 Schema Dumps and Source Control","anchor":"#schema-dumps-and-source-control","code":[],"body":"Because schema files are commonly used to create new databases, it is strongly\nrecommended that you check your schema file into source control.Merge conflicts can occur in your schema file when two branches modify schema.\nTo resolve these conflicts run bin/rails db:migrate to regenerate the schema file."},{"title":"7 Active Record and Referential Integrity","anchor":"#active-record-and-referential-integrity","code":[],"body":"The Active Record way claims that intelligence belongs in your models, not in\nthe database. As such, features such as triggers or constraints,\nwhich push some of that intelligence back into the database, are not heavily\nused.Validations such as validates :foreign_key, uniqueness: true are one way in\nwhich models can enforce data integrity. The :dependent option on\nassociations allows models to automatically destroy child objects when the\nparent is destroyed. Like anything which operates at the application level,\nthese cannot guarantee referential integrity and so some people augment them\nwith foreign key constraints in the database.Although Active Record does not provide all the tools for working directly with\nsuch features, the execute method can be used to execute arbitrary SQL."},{"title":"8 Migrations and Seed Data","anchor":"#migrations-and-seed-data","code":["\nclass AddInitialProducts < ActiveRecord::Migration[6.0]\n  def up\n    5.times do |i|\n      Product.create(name: \"Product ##{i}\", description: \"A product.\")\n    end\n  end\n\n  def down\n    Product.delete_all\n  end\nend\n\nclass AddInitialProducts < ActiveRecord::Migration[6.0]\n  def up\n    5.times do |i|\n      Product.create(name: \"Product ##{i}\", description: \"A product.\")\n    end\n  end\n\n  def down\n    Product.delete_all\n  end\nend\n\nCopy\n","\n5.times do |i|\n  Product.create(name: \"Product ##{i}\", description: \"A product.\")\nend\n\n5.times do |i|\n  Product.create(name: \"Product ##{i}\", description: \"A product.\")\nend\n\nCopy\n"],"body":"The main purpose of Rails' migration feature is to issue commands that modify the\nschema using a consistent process. Migrations can also be used\nto add or modify data. This is useful in an existing database that can't be destroyed\nand recreated, such as a production database.To add initial data after a database is created, Rails has a built-in\n'seeds' feature that speeds up the process. This is especially\nuseful when reloading the database frequently in development and test environments.\nTo get started with this feature, fill up db/seeds.rb with some\nRuby code, and run bin/rails db:seed:This is generally a much cleaner way to set up the database of a blank\napplication."},{"title":"9 Old Migrations","anchor":"#old-migrations","code":["\n# This migration comes from blorgh (originally 20210621082949)\n\n# This migration comes from blorgh (originally 20210621082949)\n\nCopy\n"],"body":"The db/schema.rb or db/structure.sql is a snapshot of the current state of your\ndatabase and is the authoritative source for rebuilding that database. This\nmakes it possible to delete old migration files.When you delete migration files in the db/migrate/ directory, any environment\nwhere bin/rails db:migrate was run when those files still existed will hold a reference\nto the migration timestamp specific to them inside an internal Rails database\ntable named schema_migrations. This table is used to keep track of whether\nmigrations have been executed in a specific environment.If you run the bin/rails db:migrate:status command, which displays the status\n(up or down) of each migration, you should see ********** NO FILE **********\ndisplayed next to any deleted migration file which was once executed on a\nspecific environment but can no longer be found in the db/migrate/ directory.There's a caveat, though. Rake tasks to install migrations from engines are idempotent. Migrations present in the parent application due to a previous installation are skipped, and missing ones are copied with a new leading timestamp. If you deleted old engine migrations and ran the install task again, you'd get new files with new timestamps, and db:migrate would attempt to run them again.Thus, you generally want to preserve migrations coming from engines. They have a special comment like this:"}]